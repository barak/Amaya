::::::::::::::
HTAABrow.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Client Side Authentication Challenges
  and Credentials


!
  Client Side Authentication Challenges and Credentials
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Contains code for parsing challenges and creating credentials for basic and
digest authentication schemes. See also the HTAAUtil module for how to handle
other authentication schemes. You don't have to use this code at all if you
better like to use your own functions for parsing challenges and generating
credentials. All functions are implemented as callback functions to the
Authentication Manager

This module is implemented by HTAABrow.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTAABROW_H
#define HTAABROW_H
#include "HTUTree.h"
#include "HTNet.h"

/*
.
  Basic Authentication
.

This is the set of callback functions for handling basic authentication.
*/

extern HTNetBefore	HTBasic_generate;
extern HTNetAfter 	HTBasic_parse;
extern HTUTree_gc	HTBasic_delete;

/*
.
  Digest Authentication
.

This is the set of callback functions for handling digest authentication.
*/

extern HTNetBefore	HTDigest_generate;
extern HTNetAfter 	HTDigest_parse;
extern HTNetAfter       HTDigest_updateInfo;
extern HTUTree_gc	HTDigest_delete;


/*
*/

#endif	/* NOT HTAABROW_H */

/*

  

  @(#) $Id: HTAABrow.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/


::::::::::::::
HTAAUtil.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Access Authentication


!
  Access Authentication Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Authentication Manager is a registry for Authentication
Schemes that follow the generic syntax defined by the
HTTP WWW-authenticate and
Authorization headers. Currently, the only scheme defined is
Basic Authentication, but Digest Authentication will soon follow.
All Authentication Schemes are registered at run-time in form of an
Authentication Module. An Authentication Module consists of
the following:

  
    scheme
  
    The name which is used to identify the scheme. This is equivalent to the
    <scheme> part of the WWW-authenticate HTTP
    header, for example "basic"
  
    BEFORE Filter
  
    When a new request is issued, the Authentication Manager looks in
    the URL tree to see if we have any access authentication information for
    this particular request. The search is based on the realm (if known) in which
    the request belongs and the URL itself. If a record is found then the
    Authentication Manager calls the Authentication Module in order
    to generate the credentials.
  
    AFTER Filter
  
    After a request has terminated and the result was lack of credentials, the
    request should normally be repeated with a new set of credentials. The AFTER
    filter is responsible for extracting the challenge from the HTTP response
    and store it in the URL tree, so that we next time we request the same URL
    we know that it is protected and we can ask the user for the appropriate
    credentials (user name and password, for example).
  
    garbage collection
  
    The authentication information is stored in a URL
    Tree but as it doesn't know the format of the scheme specific parts,
    you must register a garbage collector (gc). The gc is called when node is
    deleted in the tree.


Note: The Authentication Manager itself consists of
BEFORE and an AFTER filter - just
like the Authentication Modules. This means that any Authentication
Module also can be registered directly as a BEFORE and
AFTER filter by the Net
Manager. The reason for having the two layer model is that the
Authentication Manager maintains a single URL
tree for storing access information for all Authentication Schemes.

An Authentication Module has three resources, it can use when creating
challenges or credentials:
	 
	   o 
	     Handle the credentials which is a part of the
    Request obejct. The credentials are often
    generated by asking the user for a user name ansd a password.
  o 
	     Handle the challenges which is a part of the
    Request object. The MIME
    parser will normally find the credentials as we parse the HTTP response.
  o 
	     Add information to the URL Tree

	 
This module is implemented by HTAAUtil.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTAAUTIL_H
#define HTAAUTIL_H
#include "HTReq.h"
#include "HTNet.h"
#include "HTUTree.h"

/*
.
  Authentication Scheme Registration
.

An Authentication Scheme is registered by registering an
Authentication Module to in the Authentication Manager.
(
  Add an Authentication Module
)

You can add an authentication scheme by using the following method. Each
of the callback function must have the type as defined below.
*/

typedef struct _HTAAModule HTAAModule;

extern HTAAModule * HTAA_newModule (const char *		scheme,
				    HTNetBefore *		before,
				    HTNetAfter *		after,
				    HTNetAfter *                update,
				    HTUTree_gc *		gc);

/*
(
  Find an Authentication Module
)
*/
extern HTAAModule * HTAA_findModule (const char * scheme);

/*
(
  Delete an Authentication Module
)
*/
extern BOOL HTAA_deleteModule (const char * scheme);

/*
(
  Delete ALL Authentication modules
)
*/
extern BOOL HTAA_deleteAllModules (void);

/*
.
  Handling the URL Tree
.

The authentication information is stored as URL
Trees. &nbsp;The root of a URL Tree is identified by a hostname
and a port number. Each URL Tree contains a set of templates and realms
which can be used to predict what information to use in a hierarchical tree.

The URL trees are automatically collected after some time so the application
does not have to worry about freeing the trees. When a node in a tree is
freed, the gc registered as part of the Authentication Module is called.

Server applications can have different authentication setups for each hostname
and port number, they control. For example, a server with interfaces
"www.foo.com" and "internal.foo.com" can have different
protection setups for each interface.
(
  Add new or Update a Note in the UTree
)

Add an access authentication information node to the database or update an
existing one. If the entry is already found then it is replaced with the
new one. The template must follow normal URI syntax but can include a wildcard
Return YES if added (or replaced), else NO
*/
extern void * HTAA_updateNode (BOOL proxy,
                               char const * scheme,
			       const char * realm, const char * url,
			       void * context);

/*
(
  Delete a Node from the UTree
)

This is called if an already entered node has to be deleted, for example
if it is not used (the user cancelled entering a username and password),
or for some reason has expired.
*/
extern BOOL HTAA_deleteNode (BOOL proxy_access, char const * scheme,
                             const char * realm, const char * url);

/*
.
  The Authentication Manager Filters
.

As mentioned, the Access Authentication Manager is itself a set of
filters that can be registered by the
Net manager.
(
  Before Filter
)

Make a lookup in the URL tree to find any context for this node, If no context
is found then we assume that we don't know anything about this URL and hence
we don't call any BEFORE filters at all.
*/

HTNetBefore HTAA_beforeFilter;

/*
(
  After Filter
)

Call the AFTER filter that knows how to handle this scheme.
*/

HTNetAfter HTAA_afterFilter;

/*
(
  Update Filter
)

Call the UPDATE filter that knows how to handle this scheme.
*/

HTNetAfter HTAA_updateFilter;

/*
(
  Proxy Authentication Filter
)

Just as for normal authentication we have a filter for proxy authentication.
The proxy authentication uses exactly the same code as normal authentication
but it stores the information in a separate proxy authentication
URL tree. That way, we don't get any clashes between
a server acting as a proxy and a normal server at the same time on the same
port. The difference is that we only have a ingoing filter (a before filter)
as the out going filter is identical to the normal authentication filter.
The filter requires to be called after a proxy filter as we otherwise don't
know whether we are using a proxy or not.
*/

HTNetBefore HTAA_proxyBeforeFilter;

/*
*/

#endif	/* NOT HTAAUTIL_H */

/*

  

  @(#) $Id: HTAAUtil.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTAccess.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Accessing URIs


!
  Accessing URIs
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is the application interface module to the
Request class. It contains a lot of methods for
loading URIs and also for uploading URIs using PUT or
POST, for example. You can use the Request class directly but
this module makes it easier to use by providing a lot of small request functions
using the Request class in different ways. It contains help functions for
accessing documents and for uploading documents to a remote server.

This module contains functions for handling all HTTP/1.1 methods:

  
    GET Requests
  
    	 
	       o 
	 	Various GET requests including specialized functions like
	loading a rule file, etc.
      o 
	 	Search requests based on the GET method
      o 
	 	Formdata requests based on the GET method
    
	   
    PUT Requests
  
    	 
	       o 
	 	Save a document from memory ASIS using PUT
      o 
	 	Save a structured document from memory using PUT
      o 
	 	Save any URI (FTP, HTTP, local disk) using PUT
    
	   
    POST Requests
  
    	 
	       o 
	 	Post Formdata to a remote HTTP server
      o 
	 	Post a document from memory ASIS to a remote HTTP
	server
    
	   
    HEAD, DELETE, OPTIONS, and TRACE requests
  
    	 
	       o 
	 	Get metainformation about a document using HEAD requests
      o 
	 	Delete documents based on the DELETE method
      o 
	 	Get information about the features supoprted by a resource
	using OPTIONS
      o 
	 	Trace a request using the TRACE method
    
	 

Furthermore, it contains a few access methods for handling
incoming requests - in orther words acting as a server. Although libwww
is primarily for clients, it is in fact symmetric in that it can handle both
client requests and server requests.

This module is implemented by HTAccess.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTACCESS_H
#define HTACCESS_H

#include "HTReq.h"
#include "HTAnchor.h"

/*
.
  Load a Document (Method = GET)
.

URIs can be accesses using a character string, for example
"http://www.w3.org" or it can be accessed by using the libwww
representation of a URI called an Anchor object.
Note that we call all objects accessible through URIs for documents
- this is a notion we have inherited from the hypertext world.
(
  Load a Document from Absolute URI
)

Request a document referencd by an absolute URI. The output from the
request is passed to the Stream Pipe Manager
that figures out where to pump the data. This can for example be to the display
or to a local file depending on the set of
converters registered by the application.
*/
extern BOOL HTLoadAbsolute (const char * url, HTRequest * request);

/*
(
  Load a Document from Relative URI
)

Request a document referenced by a relative URI. The relative URI
is made absolute by resolving it relative to the address of the 'base'
anchor.
*/
extern BOOL HTLoadRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);

/*
(
  Load a Document into Memory
)

Request a document referred to by the URI and load it into a
HTChunk object. A chunk
object is a dynamic string so in the end you will have a single memory
buffer containing the document. The chunk must be freed by the caller.
*/
extern HTChunk * HTLoadToChunk (const char * url, HTRequest * request);

/*
(
  Load a Document and Save as a Local File
)

This function loads a URI and saves the contents in the specifed file. The
file should not &nbsp;be open, as the load function both opens and closes
the file. If the file already exists then it asks the user whether the file
should be overwritten or not. the contents is saved ASIS - that is
- we do not touch the contents of the file!
*/

extern BOOL HTLoadToFile (const char * url, HTRequest * request,
			  const char * filename);

/*
(
  Load a Document and put the Contents into a Stream
)

Request a document referenced by an absolute URI and sending the data down
a stream. This stream can be anny stream you like, for eample one from the
Stream Interface.
*/

extern BOOL HTLoadToStream (const char * url, HTStream * output,
			    HTRequest * request);

/*
(
  Load a Document using an Anchor
)

Here the URI is represented by an Anchor object.
You can get an anchor object representing a URI by passing the URI to the
appropriate method in the Anchor class.
*/
extern BOOL HTLoadAnchor (HTAnchor * anchor, HTRequest * request);

/*
(
  Load a Document into Memory using an Anchor
)

This is the same as HTLoadToChunk but instead of passing a URI
string you pass an HTAnchor object. Internally,
all URIs are represented as anchors which contains all the information we
have about the resource. The chunk must be freed by the caller.
*/
extern HTChunk * HTLoadAnchorToChunk (HTAnchor * anchor, HTRequest * request);

/*
(
  Recursively Request a Document using Anchors
)

Same as HTLoadAnchor() but the information in the
error stack in the request
object is kept, so that any error messages in one. This function is almost
identical to HTLoadAnchor, but it doesn't clear the error stack
so that the information in there is kept.
*/
extern BOOL HTLoadAnchorRecursive (HTAnchor * anchor, HTRequest * request);

/*
.
  Load Special Documents
.

We also have a set of functions for loading special files like rules files
which also are referenced by a URI but which do have to be treated specially.
(
  Load a Rule File
)

Rule files can be loaded just like any other URI but you can also just use
these functions which do all the work for you: they load a rule find with
the URI specified and add the set of rules to the existing set.

They come in two flavours - one that asks the user whether it is OK to add
the rules and one that does it automatically without asking. As the app would
have to call this method explicitly, it may have other ways of protecting
the user.

Both functions use preemptive requests
so that everything else stops in the meantime.
*/

extern BOOL HTLoadRules (const char * url);
extern BOOL HTLoadRulesAutomatically (const char * url);

/*
.
  Search a Document (Method = GET)
.

The search methods all use GET as the method in the
HTTP request. The functions take
the keywords and encode them according to
RFC
1866 (Hypertext Markup language). That is, the query part is separated
from the rest of the URI by a "?".

The keywords are passed to the function as a Chunk
Object and each keyword must be separated by a space ' '. This
will then be converted into a '+' before added to the URI.
(
  Search a Document from Absolute URI
)
*/

extern BOOL HTSearchAbsolute (HTChunk *		keywords,
			      const char *	base,
			      HTRequest *	request);

/*
(
  Search a Document from Relative URI
)

Search a document referenced by a relative URI. The relative URI is
made absolute by resolving it relative to the address of the 'base'
anchor.
*/

extern BOOL HTSearchRelative (HTChunk *		keywords,
			      const char * 	relative,
			      HTParentAnchor *	base,
			      HTRequest *	request);

/*
(
  Search a Document using an Anchor
)
*/

extern BOOL HTSearchAnchor (HTChunk *		keywords,
			    HTAnchor *		anchor,
			    HTRequest * 	request);

/*
(
  Search a Document using an Anchor Using a String
)

This works exactly as the HTSearchAnchor() function but takes
a C string instead of a chunk object.
*/

extern BOOL HTSearchString (const char *	keywords,
			    HTAnchor *		anchor,
			    HTRequest * 	request);

/*
.
  Submit Forms Using GET Method
.

Formdata can be sent to an HTTP server in two ways - it can either use a
GET method or it can use a POST method. The difference
is whether the request "has side effects" or not. For example, if you are
ordering a pizza then the (hopefully positive) sideeffect is that you actually
get one delivered. However, if you are issuing search data - for example
to Alta Vista, then there is no sideeffect. In the former example you would
use the GET form and in the latter you would use the
POST form.
(
  Submit Form from Absolute URI using GET
)

Submit formdata using GET to the address indicated as the "base" which must
be an absolute URI. The list of form data must be given as an
association list where the name is the field name
and the value is the value of the field.
*/

extern BOOL HTGetFormAbsolute (HTAssocList *	formdata,
			       const char *	base,
			       HTRequest *	request);

/*
(
  Submit Form from Relative URI using GET
)

Submit formdata using GET to the address indicated relative to the address
of the base anchor. The list of form data must be given as an
association list where the name is the field name
and the value is the value of the field.
*/

extern BOOL HTGetFormRelative (HTAssocList * 	formdata,
			       const char * 	relative,
			       HTParentAnchor *	base,
			       HTRequest *	request);

/*
(
  Send a Form using an Anchor and the GET Method
)

Submit formdata using GET to the address indicated of the anchor. The list
of form data must be given as an association list
where the name is the field name and the value is the value of the field.
*/

extern BOOL HTGetFormAnchor (HTAssocList *	formdata,
			     HTAnchor *		anchor,
			     HTRequest * 	request);

/*
.
  Submit Forms Using POST Method
.

The data in a POST form is sent as the body part of the
HTTP message whereas a
GET form wraps it all up into the URI. In order to be able to
use the POST data object at a later point in time, we create
a new anchor on the fly. This anchor has a URI file location which points
into the temporary area given by the User Profile
Object. That is - you can actually save the anchor using a
PUT request and then be able to retrive the form data at a later
point in time. Even though this may seem "ambitious" for posting form data,
it is really just a special example of sending any kind of data to a remote
server. All POST form functions return the new anchor or
NULL if they fail.
(
  Submit Form from Absolute URI using POST
)

Submit formdata using POST to the address indicated as the "base" which must
be an absolute URI. The list of form data must be given as an
association list where the name is the field name
and the value is the value of the field.
*/

extern HTParentAnchor * HTPostFormAbsolute (HTAssocList *	formdata,
					    const char *	base,
					    HTRequest *	request);

/*
(
  Submit Form from a Relative URI using GET
)

Submit formdata using POST to the address indicated relative to the address
of the base anchor. The list of form data must be given as an association
list where the name is the field name and the value is the value of the field.
*/

extern HTParentAnchor * HTPostFormRelative (HTAssocList * 	formdata,
					    const char * 	relative,
					    HTParentAnchor *	base,
					    HTRequest *		request);

/*
(
  Submit Form using an Anchor and the POST Method
)

Submit formdata using POST to the address indicated of the anchor. The list
of form data must be given as an association list
where the name is the field name and the value is the value of the field.
*/

extern HTParentAnchor * HTPostFormAnchor (HTAssocList *	formdata,
					  HTAnchor *	anchor,
					  HTRequest * 	request);

/*
(
  Submit Form and Save the Result in a Memory Buffer
)

Submit formdata to the address referred to by the
HTAnchor object and load the result of the POST
into a HTChunk object. A
chunk object is a dynamic memory buffer so in
the end you will have a single memory buffer containing the document. The
chunk must be freed by the caller.
*/

extern HTChunk * HTPostFormAnchorToChunk (HTAssocList * formdata,
                                          HTAnchor *    anchor,
                                          HTRequest *   request);

/*
.
  Get Metainformation about a Document (Method = HEAD)
.

If you are not interested in the document itself but only in the
metainformation that describes the document then you should
use the HEAD method in your request.
(
  Get Metainformation about a Document from Absolute URI
)

Request metainfomration about a document referencd by an absolute
URI.
*/
extern BOOL HTHeadAbsolute (const char * url, HTRequest * request);

/*
(
  Get Metainformation about a Document from Relative URI
)

Request metainformation about a document referenced by a relative
URI.
*/
extern BOOL HTHeadRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);

/*
(
  Get Metainformation about a Document using an Anchor
)

Here the URI is represented by an Anchor object.
You can get an anchor object representing a URI by passing the URI to the
approproiate method in the Anchor class.
*/
extern BOOL HTHeadAnchor (HTAnchor * anchor, HTRequest * request);

/*
.
  Delete a Document (Method = DELETE)
.

If you want to delete a document (or make the document inaccessible for future
references) then you can use the DELETE method in your request.
(
  Delete a Document from Absolute URI
)

Request metainfomration about a document referencd by an absolute
URI.
*/
extern BOOL HTDeleteAbsolute (const char * url, HTRequest * request);

/*
(
  Delete a Document from Relative URI
)

Request metainformation about a document referenced by a relative
URI.
*/
extern BOOL HTDeleteRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);

/*
(
  Delete a Document using an Anchor
)

Here the URI is represented by an Anchor object.
You can get an anchor object representing a URI by passing the URI to the
approproiate method in the Anchor class.
*/
extern BOOL HTDeleteAnchor (HTAnchor * anchor, HTRequest * request);

/*
.
  Save a Document ASIS From Memory (Method = PUT)
.

If you already have a document in memory and it is associated with an
Anchor object then you can PUT this document
to a remote server using the following methods. Other information that you
can set in the anchor is metadata like the media type, the document length,
the language, or any other information that you want to associate with the
document to be uploaded.

This set of functions takes the document ASIS - that it the
exact content of the document associated with this anchor will be
sent to the remote server. If your anchor represents a structured content
and the document itself is a parse tree, for example, then you can use the
structured PUT functions.

If your application is an editor, then you may want to create a new anchor
on the fly for temporary backups on local disk before you save it to a remote
server. An easy way to get a new anchor with a local file URI is to use the
HTTmpAnchor function which is part of the
WWWApp interface.
(
  Save a Document ASIS from Memory Using Absolute URI (PUT)
)

The source is an anchor with the contents already in memory and the destination
is an absolute URI.
*/

extern BOOL HTPutAbsolute (HTParentAnchor *	source,
			   const char *		destination,
			   HTRequest *		request);

/*
(
  Save a Document ASIS from Memory Using Relative URI (PUT)
)

The source is an anchor with the contents already in memory and the destination
is a relative URI relative to the destination anchor
*/

extern BOOL HTPutRelative (HTParentAnchor *	source,
			   const char * 	relative,
			   HTParentAnchor *	destination_base,
			   HTRequest *		request);

/*
(
  Save a Document ASIS from Memory Using an Anchor (PUT)
)

Both the source and the anchor are anchor objects. The source anchor already
has the contents in memory
*/

extern BOOL HTPutAnchor (HTParentAnchor *	source,
			 HTAnchor *		dest,
			 HTRequest *	 	request);

/*
.
  Save a Structured Document (Using PUT)
.

If you want to save a document from memory but it contains structured information
(for example, it is in the form of a parse tree) then you can use this interface.
The only difference from above is that the caller must provide the function
that provides data while sending it accross the network - we can't just take
it as a block. You can for example have a look at the
HTEntity_callback function which is used in the
ASIS interface if you want to write your own
data feeding method.
(
  Save a Structured Document from Memory to Absolute URI (PUT)
)

Upload a document referenced by an absolute URI.
*/

extern BOOL HTPutStructuredAbsolute (HTParentAnchor *	source,
				     const char *	destination,
				     HTRequest *	request,
				     HTPostCallback *	input);

/*
(
  Save a Structured Document from Memory to Relative URI (PUT)
)

The source is an anchor with the contents already in memory and the destination
is a relative URI relative to the destination anchor
*/

extern BOOL HTPutStructuredRelative (HTParentAnchor *	source,
				     const char * 	relative,
				     HTParentAnchor *	destination_base,
				     HTRequest *	request,
				     HTPostCallback *	input);

/*
(
  Save a Structured Document Using an Anchor and the PUT Method
)

The source is an anchor with the contents already in memory and the destination
is a relative URI. The HTPostCallback function type is declared in the HTRequest
object.
*/

extern BOOL HTPutStructuredAnchor (HTParentAnchor *	source,
				   HTAnchor *		destination,
				   HTRequest *	 	request,
				   HTPostCallback *	input);

/*
.
  Save a Remote Document (Using PUT)
.

If the content of the document associated with the anchor is NOT in
memory then you can use this interface. These methods make two requests:
first they go out and get the source which can be on an FTP server, on local
disk, on another HTTP server etc. and then they PUT this document ASIS to
the destination HTTP server.
(
  Save a Document from Absolute URI using PUT
)

Get the source and PUT it to the destination which is an absolute URI
*/

extern BOOL HTPutDocumentAbsolute (HTParentAnchor *	source,
				   const char *	        destination,
				   HTRequest *	        request);

/*
(
  Save a Document from Relative URI using PUT
)

Get the source and PUT it to the destination which is a relative URI
*/

extern BOOL HTPutDocumentRelative (HTParentAnchor *	source,
				   const char * 	relative,
				   HTParentAnchor *	destination_base,
				   HTRequest *          request);

/*
(
  Save a Document Using an Anchor and the PUT Method
)

Get the source and PUT it to the destination which is an anchor object.
*/

extern BOOL HTPutDocumentAnchor (HTParentAnchor *	source,
				 HTAnchor *		destination,
				 HTRequest *	 	request);

/*
.
  Post a Document from Memory ASIS (Method = POST)
.

If you already have a document in memory and it is associated with an
Anchor object then you can POST this document
to a remote server using the following methods. Other information that you
can set in the anchor is metadata like the media type, the document length,
the language, or any other information that you want to associate with the
document to be uploaded.

This set of functions takes the document ASIS - that it the
exact content of the document associated with this anchor will be
sent to the remote server.

If your application is an editor, then you may want to create a new anchor
on the fly for temporary backups on local disk before you save it to a remote
server. An easy way to get a new anchor with a local file URI is to use the
HTTmpAnchor function which is part of the
WWWApp interface.
(
  Post a Document from Memory ASIS using Absolute URI (POST)
)

Upload a document using POST referenced by an absolute URI.
*/

extern BOOL HTPostAbsolute (HTParentAnchor *	source,
			   const char *		destination,
			   HTRequest *		request);

/*
(
  Post a Document from Memory ASIS using Relative URI (POST)
)

Upload a document using POST referenced by a relative URI.
*/

extern BOOL HTPostRelative (HTParentAnchor *	source,
			   const char * 	relative,
			   HTParentAnchor *	destination_base,
			   HTRequest *		request);

/*
(
  Post a Document from Memory ASIS using an Anchor (POST)
)

POST an anchor - here both the source and the anchor are anchor objects.
The source anchor already has the contents in memory.
*/

extern BOOL HTPostAnchor (HTParentAnchor *	source,
			 HTAnchor *		dest,
			 HTRequest *	 	request);

/*
.
  Get Available Options for a Document (Method = OPTIONS)
.

If you want to get information about a document then you can use the the
OPTIONS method in your request. The OPTIONS method
represents a request for information about the communication options available
on the request/response chain identified by the Request-URI.
This method allows the client to determine the options and/or requirements
associated with a resource, or the capabilities of a server, without implying
a resource action or initiating a resource retrieval.

A speciality about the OPTIONS method is that the client can
issue a request with no pathinfo at all but only with a "*".
That is, the request line can look like this "OPTIONS * HTTP/1.1".
This means that we request information about the server as a whole and not
only about a single URI. You can get this effect by using a URI containing
the hostname alone with NO extra slash at the end, for example
http://www.w3.org, http://www.cern.ch.
(
  Options Available for Document from Absolute URI
)

Request options about a document referencd by an absolute URI.
*/
extern BOOL HTOptionsAbsolute (const char * url, HTRequest * request);

/*
(
  Options Available for Document from Relative URI
)

Request options about a document referenced by a relative URI.
*/
extern BOOL HTOptionsRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);

/*
(
  Options Available for Document using an Anchor
)

Here the URI is represented by an Anchor object.
You can get an anchor object representing a URI by passing the URI to the
appropriate method in the Anchor class.
*/
extern BOOL HTOptionsAnchor (HTAnchor * anchor, HTRequest * request);

/*
.
  Get Trace Loop back Information for a Document (Method =
  TRACE)
.

The TRACE method is used to invoke a remote, application-layer loop-back
of the request message. The final recipient of the request SHOULD reflect
the message received back to the client as the entity-body of a 200 (OK)
response. The final recipient is either the origin server or the first proxy
or gateway to receive a Max-Forwards value of zero (0) in the request (see
section 14.31). A TRACE request MUST NOT include an entity.

TRACE allows the client to see what is being received at the other end of
the request chain and use that data for testing or diagnostic information.
The value of the Via header field (section 14.44) is of particular interest,
since it acts as a trace of the request chain. Use of the Max-Forwards header
field allows the client to limit the length of the request chain, which is
useful for testing a chain of proxies forwarding messages in an infinite
loop.

If successful, the response SHOULD contain the entire request message in
the entity-body, with a Content-Type of "message/http". Responses
to this method MUST NOT be cached.
(
  Traces Available for Document from Absolute URI
)

Request traces about a document referencd by an absolute URI.
*/
extern BOOL HTTraceAbsolute (const char * url, HTRequest * request);

/*
(
  Traces Available for Document from Relative URI
)

Request traces about a document referenced by a relative URI.
*/
extern BOOL HTTraceRelative (const char * 	relative,
			     HTParentAnchor *	base,
			     HTRequest *	request);

/*
(
  Traces Available for Document using an Anchor
)

Here the URI is represented by an Anchor object.
You can get an anchor object representing a URI by passing the URI to the
appropriate method in the Anchor class.
*/
extern BOOL HTTraceAnchor (HTAnchor * anchor, HTRequest * request);

/*
.
  Serve a Request
.

Although libwww is primarily for clients, it is in fact symmetric in that
it can handle both client requests and server requests. The way this is handled
is that each protocol is registered with both a
client handler and a server handler - depending on which type of request
you use, one of them is called. Note that in order to be able to serve any
document, there actually have to be a server handler. However, libwww only
comes with a raw socket loader which isn't much
of a server. There is an attempt of an HTTP server
but it is not complete

The protocol handler used to serve the request is determined by the URI -
just as for client side requests. That is, libwww can in fact simultaneously
be the server for multiple protocols if you really want to. Examples of URIs
that you can use are noop://localhost:8888 which means that libwww
starts listening on port 8888 (see the listen
example for details). Other examples are http://localhost:7777
which means that it listens for HTTP on port 7777. Again, there is no HTTP
server in libwww - this is just an example.
*/

extern BOOL HTServeAbsolute (const char * address, HTRequest * request);

/*
.
  Save a URI To Multiple Destinations - Not supported!!!
.

Note: This is no longer supported

These are the generic versions of the PUT and POST
functions. They can be used to send documents to multiple destinations
simultanously using the PostWeb model.
(
  Copy an anchor - not supported
)

Fetch the URI from either local file store or from a remote HTTP server
and send it using either PUT or POST to the remote destination using HTTP.
The caller can decide the exact method used and which HTTP header fields
to transmit by setting the user fields in the request structure. If posting
to NNTP then we can't dispatch at this level but must pass the source anchor
to the news module that then takes all the refs to NNTP and puts into the
"newsgroups" header Returns YES if request accepted, else NO
*/
extern BOOL HTCopyAnchor (HTAnchor * src_anchor, HTRequest * main_req);

/*
(
  Upload an Anchor - not supported
)

This function can be used to send data along with a request to a remote server.
It can for example be used to POST form data to a remote HTTP server - or
it can be used to post a newsletter to a NNTP server. In either case, you
pass a callback function which the request calls when the remote destination
is ready to accept data. In this callback you get the current request object
and a stream into where you can write data. It is very important that you
return the value returned by this stream to the Library so that it knows
what to do next. The reason is that the outgoing stream might block or an
error may occur and in that case the Library must know about it. If you do
not want to handle the stream interface yourself then you can use the
HTUpload_callback which is declared below. The source anchor
represents the data object in memory and it points to the destination anchor
by using the POSTWeb method.
The source anchor contains metainformation about the data object in memory
and the destination anchor represents the reponse from the remote server.
Returns YES if request accepted, else NO
*/
extern BOOL HTUploadAnchor (HTAnchor *		source_anchor,
			    HTRequest * 	request,
			    HTPostCallback *	callback);

/*
(
  POST Callback Handler - not supported
)

Is you do not want to handle the stream interface on your own, you can use
this "middleman" function which does the actual writing to the target stream
for the anchor upload and also handles the return value from the stream.
Now, your application is called via the callback function that you may associate
with a request object. You indicate when you have sent all the data you want
by returning HT_LOADED from the callback.
*/

extern int HTUpload_callback (HTRequest * request, HTStream * target);

/*
*/

#endif /* HTACCESS_H */

/*

  

  @(#) $Id: HTAccess.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTAlert.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Library Alert Class


!
  The Alert Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Alert class defines a set of methods to be used by libwww for passing
prompts and message to the application. In order to maintain libwww application
independent and natural language independent, it does not know how to communicate
with a user. Note here that a user is a somewhat abstract notion
for &nbsp;something that can receive a message or prompt from libwww. A
user can for example be a person, but is may also be handled
automatically by a robot or a client receiving a response from a HTTP server.

Libwww has a set of opcodes that classifies the nature of the message,
for example that it is a question that must be confirmed in order to continue
a request or simply a progress notification. The application can register
a callback for any number of the defined opcodes - in case libwww has a message
for an opcode that does not have a method associated, the message is ignored.
You can also globally disable any message send from libwww.

Note: The library core does not define any message or dialog
methods - they are all considered part of the application. However, it comes
with a default set of methods which can be initiated
using the function HTAlertInit() in HTInit
module

This module is implemented by HTAlert.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTALERT_H
#define HTALERT_H

#include "HTReq.h"

/*
.
  Message Opcodes and Messages
.

The callback functions are defined as a generic callback where the caller
can pass a set of input parameters and the callee can return a set of outptu
parameters. Also note that all the *_PROG_* opcodes are a subset
of HT_A_PROGRESS. This means that you easily can register a
callback for all progress reports. 

The callback handler for progress notifications SHOULD NOT be used
to interrupt the ongoing message as it is not guaranteed to be in a state
to do so. Instead you should use the event handlers
or the timers for this.
*/

typedef enum _HTAlertOpcode {
    HT_PROG_DNS		= 0x1,		/* Doing DNS resolution */
    HT_PROG_CONNECT	= 0x2,		/* Connecting Active */
    HT_PROG_ACCEPT	= 0x4,		/* Connecting Passive */
    HT_PROG_READ	= 0x8,		/* Read data */
    HT_PROG_WRITE	= 0x10,		/* Write data */
    HT_PROG_DONE	= 0x20,		/* Request finished */
    HT_PROG_INTERRUPT   = 0x40,         /* Request interrupted */
    HT_PROG_OTHER       = 0x80,         /* Other progress notes */
    HT_PROG_TIMEOUT     = 0x100,        /* Request timed out */
    HT_PROG_LOGIN	= 0x200,	/* Automatic login notifications */
    HT_A_PROGRESS	= 0xFFFF,	/* Get all progress reports - no reply */

    /* First word are reserved for progresss notifications */

    HT_A_MESSAGE	= 0x1<<16, /* Send a message - no reply */
    HT_A_CONFIRM	= 0x2<<16, /* Want YES or NO back */
    HT_A_PROMPT		= 0x4<<16, /* Want full dialog */
    HT_A_SECRET		= 0x8<<16, /* Secret dialog (e.g. password) */
    HT_A_USER_PW	= 0x10<<16 /* Atomic userid and password */
} HTAlertOpcode;

typedef struct _HTAlertPar HTAlertPar;

typedef BOOL HTAlertCallback   (HTRequest * request, HTAlertOpcode op,
				int msgnum, const char * dfault, void * input,
				HTAlertPar * reply);

/*

If you don't expect any return values then reply can be NULL.
The return value of the callback function can be used to indicate confirmation
on a prompt (Yes or No).
.
  User Prompts and Questions
.

This is an enumerated list of messages that can be converted into a string
table etc. See the HTDialog module for
default initialization of these strings.
*/

typedef enum _HTAlertMsg {
    HT_MSG_NULL = -1,
    HT_MSG_UID = 0,
    HT_MSG_PROXY_UID,
    HT_MSG_FTP_UID,
    HT_MSG_PW,
    HT_MSG_FILENAME,
    HT_MSG_ACCOUNT,
    HT_MSG_METHOD,
    HT_MSG_MOVED,
    HT_MSG_RULES,
    HT_MSG_FILE_REPLACE,
    HT_MSG_RETRY_AUTHENTICATION,
    HT_MSG_RETRY_PROXY_AUTH,
    HT_MSG_REDO,
    HT_MSG_BIG_PUT,
    HT_MSG_SOURCE_MOVED,
    HT_MSG_DESTINATION_MOVED,
    HT_MSG_REDIRECTION,
    HT_MSG_PROXY,
    HT_MSG_CACHE_LOCK,
    HT_MSG_ACCEPT_COOKIE,
    HT_MSG_ELEMENTS		            /* This MUST be the last element */
} HTAlertMsg;

/*
.
  Enable or Disable Messages
.

If you really don't want the library to prompt for anything at all then enable
this constant. The default value is Interactive.
*/

extern void HTAlert_setInteractive	(BOOL interative);
extern BOOL HTAlert_interactive		(void);

/*
.
  Creation and Deletion Methods
.

Message methods are registered in lists. By default a list is not enabled
before you assign it as being active. This allows
the application to maintain multiple lists of message handlers which can
be swapped in and out as neeeded.
(
  Add a Callback Function
)

Register a call back function that is to be called when generating messages,
dialog, prompts, progress reports etc. The opcode signifies which call back
function to call depending of the type of the message. Opcode can be any
combination of the bitflags defined by HTAlertOpcode. If you
register one callback for HT_A_PROGRESS then this will get called
on all progress notifications.
*/

extern BOOL HTAlertCall_add (HTList * list, HTAlertCallback * cbf,
			     HTAlertOpcode opcode);

/*
(
  Delete a Callback function
)

Unregister a call back function from a list
*/

extern BOOL HTAlertCall_delete (HTList * list, HTAlertCallback * cbf);

/*
(
  Delete all Callbacks With this Opcode
)

Unregister all handlers registered for a given opcode.
*/

extern BOOL HTAlertCall_deleteOpcode (HTList * list, HTAlertOpcode opcode);

/*
(
  Delete a list of Callback Functions
)

Unregisters all call back functions
*/

extern BOOL HTAlertCall_deleteAll (HTList * list);

/*
(
  Find a Callback Function
)

Finds a callback function corresponding to the opcode. If none has been
registered then NULL is returned.
*/

extern HTAlertCallback * HTAlertCall_find(HTList * list, HTAlertOpcode opcode);

/*
.
  The Reply Object
.

The reply object is used for communicating input from the user back
to the Library. This is only required to use when for example the user is
prompted for a file name etc. You can find several examples on how to use
this in the default message and dialog module
provided together with the Library.
*/
extern HTAlertPar * HTAlert_newReply	(void);
extern void HTAlert_deleteReply		(HTAlertPar * old);

/*
(
  Handle the Reply Message
)

These methods provide the API for handling the reply message. There are two
ways of assigning a message to the reply message - either by copying the
buffer or by reusing the same buffer. In the latter case, the caller must
make sure not to free the reply message before it has been used.
*/

extern BOOL HTAlert_setReplyMessage	(HTAlertPar * me, const char *message);
extern BOOL HTAlert_assignReplyMessage	(HTAlertPar * me, char * message);

/*

You can get the data back again by using this method:
*/

extern char * HTAlert_replyMessage	(HTAlertPar * me);

/*
*/

extern char * HTAlert_replySecret	(HTAlertPar * me);
extern BOOL HTAlert_setReplySecret	(HTAlertPar * me, const char * secret);

extern void * HTAlert_replyOutput	(HTAlertPar * me);
extern BOOL HTAlert_setReplyOutput	(HTAlertPar * me, void * output);

/*
.
  Active set of Callback Functions
.

A list can be assigned as being active in which case it is visible
for libwww by assigning the list as the global alert list. Libwww
does not know about inactive lists of alert handlers.
*/

extern void HTAlert_setGlobal	(HTList * list);
extern HTList * HTAlert_global	(void);

/*
(
  Global Alert List Methods
)

You can assign a callback directly to the global list in which case it becomes
immediately available to libwww. In this case you do not need to worry about
creating the list - it will be created as well as deleted automatically.

  Add an Alert Handler

*/

extern BOOL HTAlert_add	(HTAlertCallback * cbf, HTAlertOpcode opcode);

/*

  Delete an Alert Handler


You can either delete a handler by referring to its address or to the opcode
that it has been registered for.
*/

extern BOOL HTAlert_delete (HTAlertCallback * cbf);
extern BOOL HTAlert_deleteOpcode (HTAlertOpcode opcode);

/*

  Delete all Alert Handlers

*/

extern BOOL HTAlert_deleteAll (void);

/*

  Find an Alert Handler

*/

extern HTAlertCallback * HTAlert_find (HTAlertOpcode opcode);

/*
*/

#endif

/*

  

  @(#) $Id: HTAlert.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTAnchor.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Anchor Class


!
  The Anchor Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

An anchor represents a region of a hypertext document which is linked to
another anchor in the same or a different document. Another name for anchors
would be URLs as an anchor represents all we know about a URL - including
where it points to and who points to it.&nbsp;Because the anchor objects
represent the part of the Web, the application has been in touch, it is often
useful to maintain the anchors throughout the lifetime of the application.
It would actually be most useful if we had persistent anchors so that an
application could build up a higher knowledge about the Web topology.

.When to Escape and Unescape Addresses.


The URI escape policy in libwww is that all URIs created as
anchors must already have been escaped. The reason for this is that if
URIs are not escaped then the URI parser is not guaranteed to work as
expected. Imagine, for example, that you have a ":" in a
host name, then you could get something like this:
http://my:host:8000/ instead of http://my%3Ahost:8000/.


Libwww provides support for escaping and unescaping
URIs using this set of APIs.


This module is implemented by HTAnchor.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTANCHOR_H
#define HTANCHOR_H


/*
.
  Types defined and used by the Anchor Object
.

This is a set of videly used type definitions used through out the Library:
*/

#include "WWWUtil.h"

typedef HTAtom * HTFormat;
typedef HTAtom * HTLevel;		       /* Used to specify HTML level */
typedef HTAtom * HTEncoding;				    /* C-E and C-T-E */
typedef HTAtom * HTCharset;
typedef HTAtom * HTLanguage;

typedef struct _HTAnchor	HTAnchor;
typedef struct _HTParentAnchor	HTParentAnchor;
typedef struct _HTChildAnchor	HTChildAnchor;

#include "HTLink.h"
#include "HTMethod.h"
#include "HTResponse.h"

/*
.
  The Anchor Class
.

We have three variants of the Anchor object - I guess some would call them
superclass and subclasses ;-) 
(
  Anchor Base Class
)

This is the super class of anchors. We often use this as an argument to the
functions that both accept parent anchors and child anchors. We separate
the first link from the others to avoid too many small mallocs involved by
a list creation. Most anchors only point to one place. 
(
  Anchor for a Parent Object
)

These anchors points to the whole contents of any resource accesible by a
URI. The parent anchor now contains all known metainformation about that
object and in some cases the parent anchor also contains the document itself.
Often we get the metainformation about a document via the entity headers
in the HTTP specification.
(
  Anchor for a Child Object
)

A child anchor is a anchor object that points to a subpart of a hypertext
document. In HTML this is represented by the NAME tag of the
Anchor element.

After we have defined the data structures we must define the methods that
can be used on them. All anchors are kept in an internal hash table so that
they are easier to find again.
(
  Find/Create a Parent Anchor
)

This one is for a reference (link) which is found in a document, and might
not be already loaded. The parent anchor returned can either be created on
the spot or is already in the hash table.
*/

extern HTAnchor * HTAnchor_findAddress		(const char * address);

/*
(
  Find/Create a Child Anchor
)

This one is for a new child anchor being edited into an existing document.
The parent anchor must already exist but the child returned can either be
created on the spot or is already in the hash table. The tag is
the part that's after the '#' sign in a URI.
*/

extern HTChildAnchor * HTAnchor_findChild	(HTParentAnchor *parent,
						 const char *	tag);

/*
(
  Find/Create a Child Anchor and Link to Another Parent
)

Find a child anchor anchor with a given parent and possibly a tag,
and (if passed) link this child to the URI given in the href. As
we really want typed links to the caller should also indicate what the type
of the link is (see HTTP spec for more information). The link is
relative to the address of the parent anchor.
*/

extern HTChildAnchor * HTAnchor_findChildAndLink (
		HTParentAnchor * parent,		/* May not be 0 */
		const char * tag,			/* May be "" or 0 */
		const char * href,			/* May be "" or 0 */
		HTLinkType ltype);			/* May be 0 */

/*
(
  Delete an Anchor
)

All outgoing links from parent and children are deleted, and this anchor
is removed from the sources list of all its targets. We also delete the targets.
If this anchor's source list is empty, we delete it and its children.
*/

extern BOOL HTAnchor_delete	(HTParentAnchor *me);

/*
(
  Clear all Anchors
)

Deletes all the metadata associated with anchors but doesn't delete
the anchor link structure itself. This is much safer than deleting the
complete anchor structure as this represents the complete Web the
application has been in touch with. It also returns a list of all the
objects (hyperdoc) hanging of the parent anchors found while doing
it. These are not deleted by libwww.
*/

extern BOOL HTAnchor_clearAll (HTList * documents);

/*
(
  Delete all Anchors
)

Deletes all anchors and return a list of all the objects (hyperdoc)
hanging of the parent anchors found while doing it. The application may keep
its own list of HyperDocs, but this function returns it anyway.
It is always for the application to delete any
HyperDocs. If NULL then no hyperdocs are returned. Return YES
if OK, else NO.

Note: This function is different from cleaning up the history list!
*/

extern BOOL HTAnchor_deleteAll	(HTList * objects);

/*
(
  Flatten all anchors into Array
)

Flattens the anchor web structure into an array.  This is useful for
calculating statistics, sorting the parent anchors etc.

The caller can indicate the size of the array (total number of anchors
if known - otherwise 0).

Return an array that must be freed by the caller or NULL if no
anchors.

*/

extern HTArray * HTAnchor_getArray (int growby);

/*

.
  Links and Anchors
.

Anchor objects are bound together by Link objects
that carry information about what type of link and whetther we have followed
the link etc. Any anchor object can have zero, one, or many links but the
normal case is one. Therefore we treat this is a special way.
(
  Handling the Main Link
)

Any outgoing link can at any time be the main destination.
*/

extern BOOL HTAnchor_setMainLink	(HTAnchor * anchor, HTLink * link);
extern HTLink * HTAnchor_mainLink	(HTAnchor * anchor);

extern HTAnchor * HTAnchor_followMainLink (HTAnchor * anchor);

/*
(
  Handling the Sub Links
)
*/

extern BOOL HTAnchor_setSubLinks	(HTAnchor * anchor, HTList * list);
extern HTList * HTAnchor_subLinks	(HTAnchor * anchor);

/*

(
  Search for a Link Type
)

Links can have relations (indicated by the "rel" or "rev" HTML link
attributes).  This function can search an anchor looking for a
specific type, for example "stylesheet".

*/

extern HTLink * HTAnchor_findLinkType (HTAnchor * me, HTLinkType type);

/*

.
  Relations Between Children and Parents
.

As always, children and parents have a compliated relationship and the libwww
Anchor class is no exception.
(
  Who is Parent?
)

For parent anchors this returns the anchor itself
*/
extern HTParentAnchor * HTAnchor_parent	(HTAnchor *me);

/*
(
  Does it have any Anchors within it?
)

Does this parent anchor have any children
*/
extern BOOL HTAnchor_hasChildren	(HTParentAnchor *me);

/*
(
  Is this anchor a Child?
)
*/

extern BOOL HTAnchor_isChild (HTAnchor * me);

/*

(
  Get the Tag/Fragment/View of this anchor
)

If this is a child anchor then it has a tag (often also called a "fragment"), which
is essentially a specific view of a document. This is why I like to call it
a view instead of a fragment. The string returned (if non-NULL) must be freed by the
caller.

*/

extern char * HTAnchor_view (HTAnchor * me);

/*

.
  Anchor Addresses
.

There are two addresses of an anchor. The URI that was passed when the anchor
was crated and the physical address that's used when the URI is going to
be requested. The two addresses may be different if the request is going
through a proxy or a gateway or it may have been mapped through a rule file.
(
  Logical Address
)

Returns the full URI of the anchor, child or parent as a malloc'd string
to be freed by the caller as when the anchor was created.
*/
extern char * HTAnchor_address		(HTAnchor * me);

/*
(
  Expanded Logical Address
)

When expanding URLs within a hypertext document, the base address is taken
as the following value if present (in that order):
	 
	   o 
	     Content-Base header
  o 
	     Content-Location header
  o 
	     Logical address
	 
	 */
extern char * HTAnchor_expandedAddress  (HTAnchor * me);

/*
(
  Physical address
)

Contains the physical address after we haved looked for proxies etc.
*/
extern char * HTAnchor_physical		(HTParentAnchor * me);
extern void HTAnchor_setPhysical	(HTParentAnchor * me, char * protocol);
extern void HTAnchor_clearPhysical	(HTParentAnchor * me);

/*
.
  Entity Body Information
.

A parent anchor can have a data object bound to it. This data object does
can for example be a parsed version of a HTML that knows how to present itself
to the user, or it can be an unparsed data object. It's completely free for
the application to use this possibility, but a typical usage would to manage
the data object as part of a memory cache.
*/

extern void HTAnchor_setDocument	(HTParentAnchor *me, void * doc);
extern void * HTAnchor_document		(HTParentAnchor *me);

/*
.
  Entity Header Information
.

The anchor object also contains all the metainformation that we know about
the object.
(
  Clear All header Information
)
*/

extern void HTAnchor_clearHeader	(HTParentAnchor *me);

/*
(
  Inherit Metainformation from the Response object
)

Once we have decided to cache the object we transfer already parsed
metainformation from the HTResponse object to
the anchor object and also the unparsed headers as we may wanna use that
information later.
*/

extern BOOL HTAnchor_update (HTParentAnchor * me, HTResponse * response);

/*
(
  Is the Anchor searchable?
)
*/
extern void HTAnchor_clearIndex		(HTParentAnchor * me);
extern void HTAnchor_setIndex		(HTParentAnchor * me);
extern BOOL HTAnchor_isIndex		(HTParentAnchor * me);

/*
(
  Anchor Title
)

We keep the title in the anchor as we then can refer to it later in the history
list etc. We can also obtain the title element if it is passed as a HTTP
header in the response. Any title element found in an HTML document will
overwrite a title given in a HTTP header.
*/
extern const char * HTAnchor_title	(HTParentAnchor *me);
extern void HTAnchor_setTitle		(HTParentAnchor *me,
					 const char *	title);
extern void HTAnchor_appendTitle	(HTParentAnchor *me,
					 const char *	title);

/*
(
  Meta Tags within the Document
)

*/

extern HTAssocList * HTAnchor_meta (HTParentAnchor * me);
extern BOOL HTAnchor_addMeta (HTParentAnchor * me,
			      const char * name, const char * value);

/*


  The Robots Meta tag


A special case function that looks for any robots meta tag. This tag
contains information about which links a robot can traverse and which
it shouldn't.

*/

extern char * HTAnchor_robots (HTParentAnchor * me);

/*

(
  Content Base
)

The Content-Base header may be used for resolving
relative URLs within the entity. If it there is no
Content-Base header then we use the Content-Location if
present and absolute.
*/

extern char * HTAnchor_base	(HTParentAnchor * me);
extern BOOL HTAnchor_setBase 	(HTParentAnchor * me, char * base);

/*
(
  Content Location
)

Content location can either be an absolute or a relative URL. The URL may
be either absolute or relative. If it is relative then we parse it relative
to the Content-Base header of the request URI if any, otherwise
we use the Request URI.
*/

extern char * HTAnchor_location		(HTParentAnchor * me);
extern BOOL HTAnchor_setLocation	(HTParentAnchor * me, char * location);

/*
(
  Media Types (Content-Type)
)
*/

extern HTFormat HTAnchor_format		(HTParentAnchor *me);
extern void HTAnchor_setFormat		(HTParentAnchor *me,
					 HTFormat	form);

/*
(
  Content Type Parameters
)

The Anchor obejct stores all content parameters in an Association list so
here you will always be able to find them. We also have a few methods for
the special cases: charset and level as they are
often needed.
*/

extern HTAssocList * HTAnchor_formatParam (HTParentAnchor * me);

extern BOOL HTAnchor_addFormatParam 	(HTParentAnchor * me,
					const char * name, const char * value);

/*

  Charset parameter to Content-Type

*/

extern HTCharset HTAnchor_charset	(HTParentAnchor *me);
extern BOOL HTAnchor_setCharset		(HTParentAnchor *me,
					 HTCharset	charset);

/*

  Level parameter to Content-Type

*/

extern HTLevel HTAnchor_level		(HTParentAnchor * me);
extern BOOL HTAnchor_setLevel		(HTParentAnchor * me,
					 HTLevel	level);

/*
(
  Content Language
)
*/

extern HTList * HTAnchor_language	(HTParentAnchor * me);
extern BOOL HTAnchor_addLanguage	(HTParentAnchor *me, HTLanguage lang);
extern BOOL HTAnchor_deleteLanguageAll  (HTParentAnchor * me);

/*
(
  Content Encoding
)
*/

extern HTList * HTAnchor_encoding	(HTParentAnchor * me);
extern BOOL HTAnchor_addEncoding	(HTParentAnchor * me, HTEncoding enc);
extern BOOL HTAnchor_deleteEncoding     (HTParentAnchor * me, HTEncoding enc);
extern BOOL HTAnchor_deleteEncodingAll  (HTParentAnchor * me);

#define HTAnchor_removeEncoding(a, e)   HTAnchor_deleteEncoding((a), (e))

/*
(
  Content Transfer Encoding
)
*/

extern HTEncoding HTAnchor_contentTransferEncoding	(HTParentAnchor *me);
extern void HTAnchor_setContentTransferEncoding	        (HTParentAnchor *me,
				 	                 HTEncoding	cte);

/*
(
  Content Length
)
*/

extern long int HTAnchor_length	(HTParentAnchor * me);
extern void HTAnchor_setLength	(HTParentAnchor * me, long int length);
extern void HTAnchor_addLength	(HTParentAnchor * me, long int deltalength);

/*
(
  Content MD5
)
*/

extern char * HTAnchor_md5	(HTParentAnchor * me);
extern BOOL HTAnchor_setMd5	(HTParentAnchor * me, const char * hash);

/*
(
  Allowed methods (Allow)
)
*/

extern HTMethod HTAnchor_allow   (HTParentAnchor * me);
extern void HTAnchor_setAllow    (HTParentAnchor * me, HTMethod methodset);
extern void HTAnchor_appendAllow (HTParentAnchor * me, HTMethod methodset);

/*
(
  Version
)
*/

extern char * HTAnchor_version	(HTParentAnchor * me);
extern void HTAnchor_setVersion	(HTParentAnchor * me, const char * version);

/*
(
  Date
)

Returns the date that was registered in the RFC822 header "Date"
*/

extern time_t HTAnchor_date		(HTParentAnchor * me);
extern void HTAnchor_setDate		(HTParentAnchor	* me, const time_t date);

/*
(
  Last Modified Date
)

Returns the date that was registered in the RFC822 header "Last-Modified"
*/

extern time_t HTAnchor_lastModified	(HTParentAnchor * me);
extern void HTAnchor_setLastModified	(HTParentAnchor	* me, const time_t lm);

/*
(
  Entity Tag
)

Entity tags are used for comparing two or more entities from the same requested
resource. It is a cache validator much in the same way Date can be.
The difference is that we can't always trust the date and time stamp and
hence we must have something stronger.
*/
extern char * HTAnchor_etag 	(HTParentAnchor * me);
extern void HTAnchor_setEtag	(HTParentAnchor * me, const char * etag);
extern BOOL HTAnchor_isEtagWeak	(HTParentAnchor * me);

/*
(
  Age Header
)

The Age response-header field conveys the sender's estimate
of the amount of time since the response (or its revalidation) was generated
at the origin server. A cached response is "fresh" if its age does not exceed
its freshness lifetime.
*/

extern time_t HTAnchor_age    (HTParentAnchor * me);
extern void HTAnchor_setAge   (HTParentAnchor * me, const time_t age);

/*
(
  Expires Date
)
*/

extern time_t HTAnchor_expires		(HTParentAnchor * me);
extern void HTAnchor_setExpires		(HTParentAnchor	* me, const time_t exp);

/*
(
  Derived from
)
*/

extern char * HTAnchor_derived	(HTParentAnchor *me);
extern void HTAnchor_setDerived	(HTParentAnchor *me, const char *derived_from);

/*
.
  Status of Header Parsing
.

This is primarily for internal use. It is so that we can check whether the
header has been parsed or not.
*/

extern BOOL HTAnchor_headerParsed	(HTParentAnchor *me);
extern void HTAnchor_setHeaderParsed	(HTParentAnchor *me);

/*
(
  Original Response Headers
)

The MIME parser may add the original response headers
as (name,value) pairs.
*/

extern BOOL HTAnchor_setHeader       (HTParentAnchor * me, HTAssocList * list);
extern HTAssocList * HTAnchor_header (HTParentAnchor * me);

/*
*/

#endif /* HTANCHOR_H */

/*

  

  @(#) $Id: HTAnchor.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTAncMan.h
::::::::::::::
/*

					W3C Sample Code Library libwww Anchor Object




!The Anchor Class Definition!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is the private part of the anchor object. It has the
functions declarations that are private to the Library and that
shouldn't be used by applications. See also the public part of the
declarition in the HTAnchorModule.

*/

#ifndef HTANCMAN_H
#define HTANCMAN_H

#include "HTAnchor.h"
#include "HTList.h"
#include "HTAtom.h"
#include "HTMethod.h"

/*

We have a set of Anchor objects which of course should be sub classes
- but - hey - this is C - what do you expect!

(Generic Anchor type)

This is the super class of anchors. We often use this as an argument
to the functions that both accept parent anchors and child anchors. We
separate the first link from the others to avoid too many small
mallocs involved by a list creation. Most anchors only point to one
place.

*/

struct _HTAnchor {
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;  	/* List of extra links from this, if any */
  HTParentAnchor * parent;	/* Parent of this anchor (self for adults) */
};

/*

(Anchor for a Parent Object)

These anchors points to the whole contents of a graphic object
(document). The parent anchor of a parent anchor is itself. The parent
anchor now contains all meta information about the object. This is
largely the entity headers in the HTTP specification.

*/

struct _HTParentAnchor {
  /* Common part from the generic anchor structure */
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;  	/* List of extra links from this, if any */
  HTParentAnchor * parent;	/* Parent of this anchor (self) */

  /* ParentAnchor-specific information */
  HTList **	children;	/* Hash of subanchors of this, if any */
  HTList *	sources;	/* List of anchors pointing to this, if any */
  void *	document;	/* The document within this is an anchor */
  char *	physical;	/* Physical address */
  char * 	address;	/* Absolute address of this node */
  BOOL		isIndex;	/* Acceptance of a keyword search */

  HTAssocList * headers;        /* Unparsed headers */
  BOOL		header_parsed;	/* Are we done parsing? */

  /* We keep a list of variants of this anchor, if any */
  HTList *	variants;

  /* Entity header fields */
  char *	title;
  HTMethod	allow;	        /* Allowed methods (bit-flag) */

  HTFormat	content_type;	/* Content type */
  HTAssocList *	type_parameters;/* Content type parameters (charset etc.) */

  HTAssocList * meta_tags;      /* Set of metatags found in the HTML text */

  char *	content_base;
  HTList *	content_encoding;
  HTList *	content_language;
  long int	content_length;
  char *	content_location;
  char *	content_md5;

  HTEncoding	cte;	        /* Content-Transfer-Encoding */

  time_t	date;		/* When was the request issued */  
  time_t	expires;	/* When does the copy expire */
  time_t	last_modified;	/* When was this last modified */
  time_t	age;	        /* Cache estimate of age */
  char * 	etag;		/* entity tag */

  char *	derived_from;	/* Opaque string */
  char *	version;	/* Opaque string */
};

/*

(Anchor for a Child Object)

A child anchor is a anchor object that points to a subpart of a
graphic object (document)

*/

struct _HTChildAnchor {
  /* Common part from the generic anchor structure */
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;  	/* List of extra links from this, if any */
  HTParentAnchor * parent;	/* Parent of this anchor */

  /* ChildAnchor-specific information */
  char * 	tag;		/* Address of this anchor relative to parent */
};

/*

*/

#endif /* HTANCMAN_H */

/*



@(#) $Id: HTAncMan.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/



::::::::::::::
HTANSI.h
::::::::::::::
/*


  
  					W3C Sample Code Library ANSI Read and Write Streams


!
  ANSI Read and Write Streams
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The ANSI Reader Stream and the ANSI Writer Stream are
output streams&nbsp;which knows how to read
and write to an ANSI C type FILE descriptor. Both streams are part of the
Transport interface and may be registered as
part of a Transport Object. In the
default initialization interface, you can find the
HTTransportInit() function which sets up the streams for handling
local file access on some platforms.

This module is implemented by HTANSI.c, and it is
a part of the W3C Sample Code
Library.
*/

#ifndef HTANSI_H
#define HTANSI_H

#include "HTIOStream.h"

/*
.
  Input Buffering
.

In order to optimize reading a channel, we bind a buffer to each channel
object. The size of this buffer is a compromise between speed and memory.
*/

#define FILE_BUFFER_SIZE	65536

/*
.
  Read Stream
.
*/

extern HTInput_new HTANSIReader_new;

/*
.
  Write Stream
.
*/

extern HTOutput_new HTANSIWriter_new;

/*
*/

#endif

/*

End of declaration module
*/
::::::::::::::
HTArray.h
::::::::::::::
/*

					W3C Sample Code Library libwww Dynamic Array Pointer Class




!Dynamic Array Pointer Class!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module implements a flexible array of pointers. It is a general
utility module.  An array is a structure which may be extended.  These
routines create and append data to arrays, automatically reallocating
them as necessary.  It is garanteed that the last entry in an array is
NULL

This module is implemented by HTArray.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTARRAY_H
#define HTARRAY_H

/*

.Private Data Structure.

This structure should not be referenced outside this module. If I find
out I'll make it private ;-)

*/

typedef struct {
    int		size;		/* In numbers of elements	*/
    int		growby;		/* Allocation unit in elements	*/
    int		allocated;	/* Current size of *data	*/
    void **	data;		/* Pointer to malloced area or 0 */
} HTArray;

/*

.Create a new Array.

Create a new array and specify the number of bytes to allocate at a
time when the array is later extended. Arbitrary but normally a
trade-off time vs. memory

*/

extern HTArray * HTArray_new (int grow);

/*

.Delete an Array.

Delete an array created by HTArray_new

*/

extern BOOL HTArray_delete (HTArray * array);

/*

.Clear an Array.

Clears an array but keeps it around

*/

extern BOOL HTArray_clear (HTArray * array);

/*

.Append an element to the Array.

Add the element to the array.

*/

extern BOOL HTArray_addObject (HTArray * array, void * object);

/*

.Traverse an Array.

Fast macros to traverse a macro ending in a NULL element.

*/

#define HTArray_firstObject(me, dp) \
	((me) && ((dp)=(me)->data) ? *(dp)++ : NULL)
#define HTArray_nextObject(me, dp) \
	((me) && (dp) ? *(dp)++ : NULL)

/*

.Sort an Array.

An array can be sorted in any way you like, for example with
qsort(). This module provides an easy interface to the qsort()
function using where you can define you own comparison routine as a
function of the type:

*/

typedef int HTComparer (const void * a, const void * b);

/*

The sort function returns YES if sorting OK, else NO.

*/

extern BOOL HTArray_sort (HTArray * array, HTComparer * comp);

/*

.Returns Data Vector.

Returns a pointer to the actual data

*/

#define HTArray_data(me)	((me) ? (me)->data : NULL)

/*


.Return Current Size.

Returns the current size of the chunk

*/

#define HTArray_size(me)	((me) ? (me)->size : -1)

/*

*/

#endif

/*



@(#) $Id: HTArray.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $


*/
::::::::::::::
HTAssoc.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Association Pairs


!
  Association List For Storing Name-Value Pairs
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This Assoctiation List class is closely related to the
HTList Class as it simply is a list of a specific
list element containing a characters based name/value pair. Lookups from
association list can be case sensitive and or prefix based.

This module is implemented by HTAssoc.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTASSOC_H
#define HTASSOC_H

#include "HTList.h"

typedef HTList HTAssocList;

typedef struct {
    char * name;
    char * value;
} HTAssoc;

/*
.
  Creation and Deletetion Methods
.

These methods create and deletes and association list
*/

extern HTAssocList * HTAssocList_new (void);
extern BOOL 	     HTAssocList_delete (HTAssocList * alist);

/*
.
  Add an Element to a List
.

We have two methods for adding new elements - you can either add unconditionally
or replace any existing element with the same name but a new value.
In replacing an element, the search is case insensitive
prefix match! A new list element is added to the beginning of the
list so that it is the first element just after the head element.
*/

extern BOOL HTAssocList_addObject (
	HTAssocList *	alist,
	const char *	name,
	const char *	value);

extern BOOL HTAssocList_replaceObject (
	HTAssocList *	list,
	const char * 	name,
	const char *	value);

/*
.
  Remove an Element from a List
.

Remove the element with the given name from the list. Search is
case insensitive prefix match!
*/

extern BOOL HTAssocList_removeObject (
	HTAssocList * 	list,
	const char * 	name);

/*
.
  Search for Element in a list
.

We have a small set of methods for searching a specific element within a
list.
(
  Case Insensitive, Prefix Match
)

In many situations, the values of associations are case insensitive - use
this method to search the list using case insensitive comparison. Also, you
can search for matching prefixes and not the whole string, for example
"foo" matches "football"
*/

extern char * HTAssocList_findObject (
	HTAssocList *	alist,
	const char *	name);

/*
(
  Case Insensitive, Exact Match
)

In case you want case insensitive, exact match
*/

extern char * HTAssocList_findObjectExact (
	HTAssocList *	alist,
	const char *	name);

/*
(
  Case Sensitive, Prefix Match
)

In case you want case sensitive, prefix match
*/

extern char * HTAssocList_findObjectCaseSensitive (
	HTAssocList *	list,
	const char *	name);

/*
(
  Case Sensitive, Exact Match
)

And finally if you want case sensitive, exact match
*/

extern char * HTAssocList_findObjectCaseSensitiveExact (
	HTAssocList *	list,
	const char * 	name);

/*
.
  Get Name and Values
.

Use this to get the name and value of a assoc object
*/

#define HTAssoc_name(me)	((me) ? (me)->name : NULL)
#define HTAssoc_value(me)	((me) ? (me)->value : NULL)

/*
.
  Traverse list
.

Fast macro to traverse the list. Call it first with copy of list header:
it returns the first object and increments the passed list pointer. Call
it with the same variable until it returns NULL.
*/

#define	HTAssocList_nextObject(me) \
	((me) && ((me) = (me)->next) ? (me)->object : NULL)

/*
*/

#endif /* not HTASSOC_H */

/*

  

  @(#) $Id: HTAssoc.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTAtom.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Atom Class


!
  The Atom Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Atom Class defines strings which are given representative
pointer values so that they can be stored more efficiently, and comparisons
for equality done more efficiently. The list of atoms is stored
in a hash table, so when asking for a new atom you might in fact get back an
existing one.

Note: There are a whole bunch of
MIME-types defined as
atoms, so please use them!

This module is implemented by HTAtom.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTATOM_H
#define HTATOM_H

#include "HTList.h"

typedef struct _HTAtom HTAtom;
struct _HTAtom {
	HTAtom *	next;
	char *		name;
}; /* struct _HTAtom */

/*
(
  Get an Atom
)

This function returns a representative value (an atom) such
that it will always (within one run of the program) return the same value
for the same given string. The former is case sensitive, the latter is case
insensitive.
*/

extern HTAtom * HTAtom_for	(const char * string);
extern HTAtom * HTAtom_caseFor	(const char * string);

/*
(
  Get Content of an Atom
)
*/

#define HTAtom_name(a) ((a) ? (a)->name : NULL)

/*

This macro returns the string pointed to by the atom.
(
  Search For Atoms
)

Returns a list of atoms which matches the template given. It
is especially made for MIME-types so that for example a template like
text<slash><star> returns a list of all MIME-types
of type text.
*/

extern HTList * HTAtom_templateMatches (const char * templ);

/*
(
  Cleanup Memory
)

In order to cleanup memory, call this function. This is done automaticly
from the HTLibTerminate function.
*/

extern void HTAtom_deleteAll (void);

#endif

/*

  

  @(#) $Id: HTAtom.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTBind.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww File Suffix Binding


!
  File Suffix Binding Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The preferences that we described in section
Request Preferences did not mention
what libwww should do if it doesn't know the data format of a document. In
many protocols this information is provided by the remote server. Typical
examples are MIME like protocols where the metainformation such as the
Content-Type and the Content-Language is provided together
with the document. However, applications often have access to the local file
system using file URLs which in general do not keep any or at least
very little information of the file type. It is therefore required to have
some kind of binding between the file system and the preferences registered
in the Library which provides this mateinformation about the object.

Often files in a file system is classified by some sort of a suffix, for
example, GIF files are often ending in .gif, text files
in .txt etc. This binding is not static and it is therefore required
to have a dynamic binding just like the preferences themselves. An example
of the latter is HTML files which on most Unix systems end in .html
whereas they on many MS-DOS based systems end in .htm.

This module provides a generic binding mechanism between a file and its
representation internally in libwww. It is not limited to simple file suffix
classification but can also be used in more advanced environments using data
bases etc. However, at this point we are interested in how we can register
bindings between file suffixes and for example content types, content languages
etc. The Bind manager is born with a certain knowledge about the set of
delimiters but more can be added to provide the functionality desired.

All the binding management could of course be replaced by a database interface.

This module is implemented by HTBind.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTBIND_H
#define HTBIND_H

#include "HTFormat.h"
#include "HTAnchor.h"

/*
.
  Initialization of the Module
.

These functions must be called on startup and termination of the application.
This is done automatically by HTLibInit() and
HTLibTerminate().
*/

extern BOOL HTBind_init		(void);
extern BOOL HTBind_deleteAll	(void);

/*
.
  Case Sensitivity
.

Should the search for suffixes be case sensitive or not? The default value
is case sensitive.
*/

extern void HTBind_caseSensitive	(BOOL sensitive);

/*
.
  Suffix Delimiters
.

Change the set of suffix delimiters. The default is a platform dependent
set defined in the tcp module.
*/

extern const char *HTBind_delimiters	(void);
extern void HTBind_setDelimiters	(const char * new_suffixes);

/*
.
  Set up Bindings Associated with a File Suffix
.

There are four types of bindings:
	 
	   o 
	     Content Type (media type)
	   o 
	     Language
	   o 
	     Content Encoding
	   o 
	     Content Transfer Encoding
	 
	 
And the associated set of methods is defined as:
*/

extern BOOL HTBind_add		(const char *	suffix,
				 const char *	representation,
				 const char *	encoding,
				 const char *	transfer,
				 const char *	language,
				 double		value);

extern BOOL HTBind_addType	(const char *	suffix,
				 const char *	format,
				 double		value);

extern BOOL HTBind_addEncoding	(const char *	suffix,
				 const char *	encoding,
				 double		value);

extern BOOL HTBind_addTransfer	(const char *	suffix,
				 const char *	transfer,
				 double		value);

extern BOOL HTBind_addLanguage	(const char *	suffix,
				 const char *	language,
				 double		value);

/*

The first method is a "super" method for binding information to a file suffic.
Any of the string values can be NULL. If filename suffix is
already defined its previous definition is overridden or modified. For example,
a HTBind_setType and HTBind_setEncoding can be
called with the same suffix.

Calling this with suffix set to "*" will set the default representation.
Calling this with suffix set to "*.*" will set the default representation
for unknown suffix files which contain a "."

NOTE: The suffixes can contain characters that must be escaped
in a URL. However, they should not be encoded when parsed as the
suffix parameter.
.
  Determine a suitable suffix
.

Use the set of bindings to find a suitable suffix (or index) for a certain
combination of language, media type and encoding given in the anchor. Returns
a pointer to a suitable suffix string that must be freed by the caller. If
more than one suffix is found they are all concatenated. If no suffix is
found, NULL is returned.
*/

extern char * HTBind_getSuffix	(HTParentAnchor * anchor);

/*
.
  Determine the content of an Anchor
.

Use the set of bindings to find the combination of language, media type and
encoding of a given anchor. If more than one suffix is found they are all
searched. The last suffix has highest priority, the first one lowest. Returns
the HTAnchor object with the representations
found. See also HTBind_getFormat
*/

extern BOOL HTBind_getAnchorBindings	(HTParentAnchor * anchor);

/*
.
  Determine the content of a Response
.

Use the set of bindings to find the combination of language, media type and
encoding of a given anchor. If more than one suffix is found they are all
searched. The last suffix has highest priority, the first one lowest. Returns
the HTResponse object with the representations
found. See also HTBind_getFormat
*/

extern BOOL HTBind_getResponseBindings	(HTResponse * response,
                                         const char * url);

/*
.
  Determine the content of File
.

Use the set of bindings to find the combination of language, media type and
encoding of a given anchor. If more than one suffix is found they are all
searched. The last suffix has highest priority, the first one lowest. Returns
the format, encoding, and language found. See also
HTBind_getBindings.
*/

extern BOOL HTBind_getFormat (const char *	filename,
			      HTFormat *	format,
			      HTEncoding *	enc,
			      HTEncoding *	cte,
			      HTLanguage *	lang,
			      double *		quality);

/*

End of declaration module
*/

#endif /* HTBIND_H */

/*

  

  @(#) $Id: HTBind.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTBInit.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Media Type Initialization


!
  Default Media Type Initialization Module
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

As mentioned in the Library Architecture,
libwww consists of a small core and a large set of hooks for adding
functionality. By itself, the core it not capable of performing any Web related
tasks like accessing a HTTP server or parsing a HTML document. All this
functionality must be registered by the application. This way, the core of
libwww is kept application independent and can be used as the basic building
block for any kind of Web application. The Library comes with a large set
of default functions, for example for accessing HTTP and FTP servers, parsing
RFC
822 headers etc. This module helps the application programmer setting
up all this functionality, but it is important to note that none of it is
required in order to use the Library.

This module is implemented by HTBInit.c, and it is
a part of the W3C Sample Code
Library. You can also have a look at the other
Initialization modules.
*/

#ifndef HTBINIT_H
#define HTBINIT_H

/*
.
  Default File Suffix Binding
.

Register the default set of bindings between file suffixes and media types.
This is used for example to guess the media type of a FTP URL of a local
file URL.
*/

#include "WWWCore.h"

extern void HTFileInit (void);

/*
*/

#endif

/*

  

  @(#) $Id: HTBInit.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTBound.h
::::::::::::::
/*

					W3C Sample Code Library libwww MIME multipart parser stream





!MIME Multipart Parser Stream!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This stream parses a MIME multipart stream and builds a set of new
streams via the stream stack each time we encounter a boundary start.
We get the boundary from the normal MIME parser via the Request
object. As we keep a local copy this also work for nested
multiparts.

This module is implemented by HTBound.c, and it is
a part of the W3C
Sample Code Library.

*/

#ifndef HTBOUND_H
#define HTBOUND_H
#include "HTFormat.h"

extern HTConverter HTBoundary;

#endif

/*



@(#) $Id: HTBound.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTBTree.h
::::::::::::::
/*

					W3C Sample Code Library libwww Balanced Binary Tree




!Balanced Binary Tree!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Tree creation, traversal and freeing. User-supplied comparison
routine.

This module is implemented by HTBTree.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTBTTEE_H
#define HTBTREE_H

#include "HTArray.h"

/*

*/

typedef struct _HTBTree HTBTree;

typedef struct _HTBTree_element HTBTElement;

/*

.Create a Binary Tree.

This function creates a new binary tree and uses the comparison
function when building the tree.

*/

extern HTBTree * HTBTree_new (HTComparer * comp);

/*

.Free storage of the tree but not of the objects.

*/

extern void HTBTree_free (HTBTree * tree);

/*

.Free storage of the tree and of the objects.

*/

extern void HTBTreeAndObject_free (HTBTree * tree);

/*

.Add an object to a binary tree.

*/

extern void HTBTree_add (HTBTree* tree, void * object);

/*

.Return an Object.

*/

extern void * HTBTree_object (HTBTElement * element);

/*

.Find next element in depth-first order.

(On entry,)

If element is NULL then start with leftmost element. if
not NULL then give next object to the right. The function returns a
pointer to element or NULL if none left.

*/

extern HTBTElement * HTBTree_next (HTBTree * tree, HTBTElement * element);

/*

*/

#endif

/*



@(#) $Id: HTBTree.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTBufWrt.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library libwww Buffered Socket Writer Stream


!
  Buffered Socket Writer Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Buffered Socket Writer Stream is an output
stream &nbsp;which knows how to write to a BSD type socket. It is part
of the Transport interface and may be registered
as part of a Transport Object. The application
can&nbsp;initialize this stream together with the
HTReader stream, for example. In the
default initialization module, you can find the
HTTransportInit() function which sets up this stream as a default
transport for handling unbuffered socket write operations.

The difference from the unbuffered write stream
is that this stream lets you write characters without causing a
write system call every time. The data is first written into
a buffer. Data is written to the transport only when the buffer is full,
or when the stream is flushed.

This module is implemented by HTBufWrt.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTBUFWRT_H
#define HTBUFWRT_H

#include "HTIOStream.h"

/*
.
  Default Output Buffering
.

In order to optimize reading a channel, we bind a buffer to each channel
object. The size of this buffer is a compromise between speed and memory.
By default, we have chosen a value frequently used in TCP connections. In
the stream creation method you can pass any other buffer size. In the case
of 0, we take the default size.
*/

#define OUTPUT_BUFFER_SIZE 1024

/*
.
  Buffered Write Stream
.
*/

extern HTOutput_new HTBufferWriter_new;

/*
.
  Buffered Write Converter Stream
.
*/

extern HTOutputConverter_new HTBufferConverter_new;

/*
*/

#endif

/*

  

  @(#) $Id: HTBufWrt.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTCache.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Persistent Cache Manager


!
  Persistent Cache Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The cache contains details of persistent files which contain the contents
of remote documents. The existing cache manager is somewhat naive - especially
in its garbage collection but it is just an example of how it can be
done.However, it is a fully HTTP/1.1 compliant cache manager.&nbsp;More advanced
implementations are welcome!

This module is implemented by HTCache.c, and it is
a part of the W3C Sample Code Library.
*/

#ifndef HTCACHE_H
#define HTCACHE_H

#include "WWWLib.h"

/*
.
  Initialize and Terminate the Persistent Cache
.

The cache_root is the URI of the location of the persistent
cache. An example is "file:/tmp/w3c-lib". If
cache_root is NULL then determine a cache root
using the following algorithm:

  o 
	     Look for any environment variables (if supported) in the following order:
	     WWW_CACHE, TMP, and TEMP. If none
    are set then then fall back on "/tmp".
  o 
	     Append the folder name "w3c-cache" to the root identified above


The cache_root location does not have to exist, it will be created
automatically if not. An empty string will make '/' the cache root.

The size is the total size in MBytes - the default size is 20M. The cache
can not be less than 5M.

We can only enable the cache if we are in secure
mode where we can not access the local file system. This is for example
the case if using an application as a telnet shell.
*/

extern BOOL HTCacheInit (const char * cache_root, int size);

/*

After the cache has been terminated it can not be used anymore unless you
do another HTCacheInit() call.
*/

extern BOOL HTCacheTerminate (void);

/*
.
  Cache Mode Parameters
.

The persistent cache has a set of overall parameters that you can adjust
(
  Enable and Disable the Cache
)

The cache can be temporarily suspended by using the enable/disable flag.
This does not prevent the cache from being enabled/disable at a later point
in time.
*/

extern void HTCacheMode_setEnabled (BOOL mode);
extern BOOL HTCacheMode_enabled (void);

/*

The cache can be setup to whether cache password protected documents thru the
protected flag. By default this flag is turned off.
*/

extern void HTCacheMode_setProtected (BOOL mode);
extern BOOL HTCacheMode_protected (void);

/*
(
  What is the current Cache Root?
)

Return the value of the cache root. The cache root can only be set through
the HTCacheInit() function. The string returned MUST be freed
by the caller
*/

extern char * HTCacheMode_getRoot (void);

/*
(
  Total Cache Size
)

We set the default cache size to 20M. We set the minimum size to 5M in order
not to get into weird problems while writing the cache. The size is indicated
in Mega bytes. The size is given in MBytes and is also returned in MBytes.
We don't consider the metainformation as part of the total cache size which
is the the reason for why the min cache size should not be less than 5M.
*/

extern BOOL HTCacheMode_setMaxSize (int size);
extern int  HTCacheMode_maxSize    (void);

/*
(
  Max Size of a Single Cache Entry
)

It is also possible to control the max size of a single cache entry so that
the cache doesn't get filled with a very few, very large cached entries.
The default max size for a single cached entry is 3M. The value indicated
must be in Mbytes, for example, a vaue of 3 would mean 3 MBytes.
*/

extern BOOL HTCacheMode_setMaxCacheEntrySize (int size);
extern int HTCacheMode_maxCacheEntrySize (void);

/*
(
 Default expiration time of cache entries
)

If a response does not arrive with an expiration time and does not
explicitly forbid its being cached, use the default expiration time. The
time is given in seconds (e.g., 3,600 is one hour).
*/

extern void HTCacheMode_setDefaultExpiration (const int exp_time);
extern int HTCacheMode_DefaultExpiration (void);

/*
(
  How do we handle Expiration of Cached Objects?
)

There are various ways of handling Expires header when met in
a history list. Either it can be ignored all together, the user can
be notified with a warning, or the document can be reloaded automatically.
This flag decides what action to be taken. The default action is
HT_EXPIRES_IGNORE. In HT_EXPIRES_NOTIFY mode ,
we push a message on to the Error stack which is presented to the user.
*/

typedef enum _HTExpiresMode {
    HT_EXPIRES_IGNORE = 0,
    HT_EXPIRES_NOTIFY,
    HT_EXPIRES_AUTO
} HTExpiresMode;

extern void HTCacheMode_setExpires (HTExpiresMode mode);
extern HTExpiresMode HTCacheMode_expires (void);

/*
(
  Disconnected Operation
)

The cache can be set to handle disconnected operation where it does not use
the network to validate entries and do not attempt to load new documents.
All requests that can not be fulfilled by the cache will be returned with
a "504 Gateway Timeout" response. There are two modes of how
the cache can operate in disconnected mode:

  
    No network activity at all
  
    Here is uses its own persistent cache
  
    Forward all disconnected requests to a proxy cache
  
    Here it uses the HTTP/1.1 cache-control to indicate that the proxy should
    operate in disconnected mode. This mode only really makes sense when you
    are using a proxy, of course.

*/

typedef enum _HTDisconnectedMode {
    HT_DISCONNECT_NONE     = 0,
    HT_DISCONNECT_NORMAL   = 1,
    HT_DISCONNECT_EXTERNAL = 2
} HTDisconnectedMode;

extern void HTCacheMode_setDisconnected (HTDisconnectedMode mode);
extern HTDisconnectedMode HTCacheMode_disconnected (void);
extern BOOL HTCacheMode_isDisconnected (HTReload mode);

/*
.
  The Cache Index
.

The persistent cache keeps an index of its current entries so that garbage
collection and lookup becomes more efficient. This index is stored automatically
at regular intervals so that we don't get out of sync. Also, it is automatically
loaded at startup and saved at closedown of the cache.
(
  Reading the Cache Index
)

Read the saved set of cached entries from disk. we only allow the index ro
be read when there is no entries in memory. That way we can ensure consistancy.
*/

extern BOOL HTCacheIndex_read (const char * cache_root);

/*
(
  Write the Cache Index
)

Walk through the list of cached objects and save them to disk. We override
any existing version but that is normally OK as we have already read its
contents.
*/

extern BOOL HTCacheIndex_write (const char * cache_root);

/*
.
  The HTCache Object
.

The cache object is what we store about a cached objet in memory.
*/

typedef struct _HTCache HTCache;

/*
(
  Create and Update a Cache Object
)

Filling the cache is done as all other transportation of bulk data in libwww
using streams. The cache object creater is a
stream which in many cases sits on a T stream so
that we get the original feed and at the same time can parse the contents.

In some situations, we want to append data to an already exiting cache entry.
This is the case when a use has interrupted a download and we are stuck with
a subpart of the document. If the user later on whishes to download the object
again we can issue a range request and continue from where we were. This
will in many situations save a lot of bandwidth.
*/

extern HTConverter HTCacheWriter, HTCacheAppend;

/*

This function writes the metainformation along with the data object stored
by the HTCacheWriter stream above. If no headers are available then the meta
file is empty
*/

extern BOOL HTCache_writeMeta (HTCache * cache, HTRequest * request,
                               HTResponse * response);

/*

In case we received a "304 Not Modified" response then we do
not have to tough the body but must merge the metainformation with the previous
version. Therefore we need a special metainformation update function.
*/

extern BOOL HTCache_updateMeta (HTCache * cache, HTRequest * request,
                                HTResponse * response);

/*

Clear a cache entry
*/

extern BOOL HTCache_resetMeta (HTCache * cache, HTRequest * request,
                                HTResponse * response);

/*
(
  Check Cached Entry
)

After we get a response back, we should check whether we can still cache
an entry and/or we should add an entry for a resource that has just been
created so that we can remember the etag and other things. The latter allows
us to guarantee that we don't loose data due to the lost update problem.
*/

extern HTCache * HTCache_touch (HTRequest * request, HTResponse * response,
                                HTParentAnchor * anchor);

/*

(
  Load a Cached Object
)

Loading a cached object is also done as all other loads in libwww by using
a protocol load module. For the moment, this load
function handles the persistent cache as if it was on local file but in fact
&nbsp;it could be anywhere.
*/

extern HTProtCallback HTLoadCache;

/*
(
  Delete a Cache Object
)

Remove a HTCache object from memory and from disk. You must explicitly remove
a lock before this operation can succeed
*/

extern BOOL HTCache_remove (HTCache * cache);

/*
(
  Delete All Cache Objects in Memory
)

Destroys all cache entried in memory but does not write anything to disk.
Use the index methods above for doing that. We do not delete the disk contents.
*/

extern BOOL HTCache_deleteAll (void);

/*
(
  Delete all Cache Object and File Entries
)

Destroys all cache entried in memory and on disk. This call basically
resets the cache to the inital state but it does not terminate the cache.
That is, you don't have to reinitialize the cache before you can use it again.
*/

extern BOOL HTCache_flushAll (void);

/*
(
  Find a Cached Object
)

Verifies if a cache object exists for this URL and if so returns a URL for
the cached object. It does not verify whether the object is valid or not,
for example it might have expired. Use the cache validation methods for checking
this.
*/

extern HTCache * HTCache_find (HTParentAnchor * anchor, char * default_name);

/*
(
  Verify if an Object is Fresh
)

This function checks whether a document has expired or not. The check is
based on the metainformation passed in the anchor object The function returns
the level of validation needed for getting a fresh version. We also check
the cache control directives in the request to see if they change the freshness
discission.
*/

extern HTReload HTCache_isFresh (HTCache * me, HTRequest * request);

/*
(
  Register a Cache Hit
)

As a cache hit may occur several places, we have a public function where
we can declare a download to be a true cache hit. The number of hits a cache
object has affects its status when we are doing garbage collection.
*/

extern BOOL HTCache_addHit (HTCache * cache);

/*
(
  Find the Location of a Cached Object
)

Is we have a valid entry in the cache then we also need a location where
we can get it. Hopefully, we may be able to access it thourgh one of our
protocol modules, for example the local file module.
The name returned is in URL syntax and must be freed by the caller
*/

extern char * HTCache_name (HTCache * cache);

/*
(
  Locking a Cache Object
)

While we are creating a new cache object or while we are validating an existing
one, we must have a lock on the entry so that not other requests can get
to it in the mean while. A lock can be broken if the same request tries to
create the cache entry again. This means that we have tried to validate the
cache entry but we got a new shipment of bytes back from the origin server
or an intermediary proxy.
*/

extern BOOL HTCache_getLock     (HTCache * cache, HTRequest * request);
extern BOOL HTCache_breakLock   (HTCache * cache, HTRequest * request);
extern BOOL HTCache_hasLock     (HTCache * cache);
extern BOOL HTCache_releaseLock (HTCache * cache);

/*
*/

#endif

/*

  

  @(#) $Id: HTCache.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTChannl.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Channel Interface


!
  The Channel Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

A channel contains information about sockets and their input and output streams.
A channel represents the front end for receiving data towards
the underlying transport. The definition of a channel describes how we are
to read the data coming in on a socket, for example. In other words - a channel
represents the first part of how to get handle incoming data in the Library:

	 
	   o 
	     Reading data on a channel
	   o 
	     Defining a target for incoming data
	   o 
	     Defining a protocol state machine that can handle the data
	 
	 
This module is implemented by HTChannl.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTCHANNL_H
#define HTCHANNL_H

typedef struct _HTChannel HTChannel;

#include "HTHost.h"
#include "HTIOStream.h"

/*
.
  The Channel Object
.

The channel object contains an input and an output stream for a particular
connection.
(
  Creation and Deletion of Channel Objects
)

Either the socket can be invalid (INVSOC) or the file descriptor can
be NULL but not both.

*/

extern HTChannel * HTChannel_new (SOCKET sockfd, FILE * fp, BOOL active);

/*
(
  Deleting a Channel Object
)
*/

extern BOOL HTChannel_delete (HTChannel * channel, int status);
extern BOOL HTChannel_deleteAll (void);
extern BOOL HTChannel_safeDeleteAll (void);

/*
(
  Search for a Channel
)

Look for a channel object if we for some reason should have lost it
*/

extern HTChannel * HTChannel_find (SOCKET sockfd);

/*
(
  Get Transport Descriptor for Channel
)

A transport descriptor can be either a ANSI C file descriptor or a BSD socket.
As it is difficult for the channel to know which one is used by a specific
transport, we leave this to the caller to figure out. This is probably not
the best way of doing it.
*/

extern SOCKET HTChannel_socket	(HTChannel * channel);
extern BOOL HTChannel_setSocket	(HTChannel * channel, SOCKET socket);

extern FILE * HTChannel_file	(HTChannel * channel);
extern BOOL HTChannel_setFile   (HTChannel * channel, FILE * fp);

/*
(
  The Host Object
)

The Channel object also keeps a link to the host
object so that we have a link to the persistent connection repository.
*/
extern BOOL HTChannel_setHost (HTChannel * ch, HTHost * host);
extern HTHost * HTChannel_host (HTChannel * ch);

/*
(
  Semaphores
)

Adjust the semaphore on a channel. As many Net objects
can point to the same channel we need to keep count of them so that we
know if we can delete a channel or if it is still in use. We do this by having
a simple semaphore associated with each channel object
*/

extern void HTChannel_upSemaphore   (HTChannel * channel);
extern void HTChannel_downSemaphore (HTChannel * channel);
extern void HTChannel_setSemaphore  (HTChannel * channel, int semaphore);

/*
(
  Create Input and Output Streams
)

You create the input stream and bind it to the channel using the following
methods. Please read the description in the
HTIOStream module on the parameters
target, param, and mode. The input and output
stream are instances created by the Transport
object. The Transport Object defines the creation methods for the inout
and output streams and the Channel object contains the actualy stream objects.
*/

extern BOOL HTChannel_setInput (HTChannel * ch, HTInputStream * input);
extern HTInputStream * HTChannel_input (HTChannel * ch);
extern BOOL HTChannel_deleteInput (HTChannel * channel, int status);

extern BOOL HTChannel_setOutput (HTChannel * ch, HTOutputStream * output);
extern HTOutputStream * HTChannel_output (HTChannel * ch);
extern BOOL HTChannel_deleteOutput (HTChannel * channel, int status);

extern HTInputStream * HTChannel_getChannelIStream (HTChannel * ch);
extern HTOutputStream * HTChannel_getChannelOStream (HTChannel * ch);

/*
*/

#endif /* HTCHANNL */

/*

  

  @(#) $Id: HTChannl.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTChunk.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Chunk Class


!
  The Chunk Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Chunk Class defines a way to automatically handle dynamic strings and
other data types. You create a chunk with an initial size and it will then
automatically grow to accommodate added data to the chunk. It is a general
utility module. It is guaranteed that the array is '\0' terminated
at all times (and hence is a valid C type string). The method
HTChunkTerminate can be used to explicitly
add a terminating '\0' and then to include this character in
the chunk size. If left out, the terminating character is not considered
part of the chunk.

Note: The names without a "_" (made as a #define's) are
only provided for backwards compatibility and should not be used.

This module is implemented by HTChunk.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTCHUNK_H
#define HTCHUNK_H

/*
.
  Create new chunk
.

Create a new chunk and specify the number of bytes to allocate at a time
when the chunk is later extended. Arbitrary but normally a trade-off time
vs. memory
*/

typedef struct _HTChunk HTChunk;

extern HTChunk * HTChunk_new (int growby);

/*
.
  Free a chunk
.

Free a chunk created by HTChunk_newfrom memory
*/

extern void HTChunk_delete (HTChunk * ch);

/*
.
  Clear a chunk
.

Keep the chunk in memory but clear all data kept inside. This can be used
if you know that you can reuse the allocated memory instead of allocating
new memory.  This zeros out all the allocated data (even data past the
indicated size) and sets the size of the chunk to 0.  If you have not used
any bytes past the indicated size, it is more efficient to truncate the
chunk to 0 instead.
*/

extern void HTChunk_clear (HTChunk * ch);

/*
.
  Ensure a Chunk has a Certain Amount of Free Space
.

Make sure that a chunk has enough memory allocated to grow by the
indicated extra size. If this is not the case, then the chunk is expanded
(in multiples of the chunk's "growby" size).  Nothing is done if the
current size plus the requested extra space fits within the chunk's
currently allocated memory.
*/

extern void HTChunk_ensure (HTChunk * ch, int extra_size);

/*
.
  Append a character to a chunk
.

Add the character and increment the size of the chunk by one character
*/

extern void HTChunk_putc (HTChunk * ch, char c);

/*
.
  Append a string to a chunk
.

Add the string and increment the size of the chunk by the length of the string
(without the trailing zero)
*/

extern void HTChunk_puts (HTChunk * ch, const char *str);

/*
.
  Append a block to a chunk
.

Add the block and increment the size of the chunk by the len
*/

extern void HTChunk_putb (HTChunk * ch, const char *block, int len);


/*
.
  Return Pointer to Data
.

This define converts a chunk to a normal char pointer so that it can be parsed
to any ANSI C string function.
*/

extern char * HTChunk_data (HTChunk * ch);

/*
.
  Return Current Size
.

Returns the current size of the chunk
*/

extern int HTChunk_size (HTChunk * ch);

/*
.
  Setting the Size of a Chunk
.

If you want to cut off a piece of a chunk or extend it to make room
for some direct buffer manipulation, then you can use one of these
functions.  Both of these calls set the size of the chunk to be
size, but the truncate call only allows you to make the
string shorter. If the string is made shorter, the formerly-used bytes
are cleared, so truncating a chunk to 0 is analogous to clearing it,
but slightly more efficient.
*/

extern BOOL HTChunk_truncate (HTChunk * ch, int size);
extern BOOL HTChunk_setSize (HTChunk * ch, int size);

/*
.
  Zero Terminate a chunk
.

As a chunk often is a dynamic string, it needs to be terminated by a zero
in order to be used in C. However, by default any chunk is
always zero terminated, so the only purpose of this function is to
increment the size counter with one corresponding to the zero.
*/

extern void HTChunk_terminate (HTChunk * ch);

/*
.
  CString Conversions
.

A Chunk may be built from an allocated string. The chunk assumes control
of the passed string, eliminating the need for additional allocations and
string copies.
When you take control of the CString from a chunk, the chunk is destroyed.
*/

extern HTChunk * HTChunk_fromCString	(char * str, int grow);
extern char * HTChunk_toCString		(HTChunk * ch);

/*
.
 Creating a Chunk from an allocated buffer
.

A Chunk may be built from an allocted buffer.  You must specify how much
memory is allocated in the buffer (buflen) and what the size the new
Chunk should be (size).  All memory between size and buflen is zeroed.
Note that is is legal to specify a size equal to the buflen if you don't
expect the Chunk to be null terminated.  The chunk takes control of the
memory, and will free it when the Chunk is destroyed. Note that in order
to avoid conflicts, the buffer's memory should be allocated using
libwww's dedicated functions.
*/

extern HTChunk * HTChunk_fromBuffer (char * buf, int buflen, int size, int grow);

/*
.
  Old Interface Names
.

Don't use these in new applications
*/

#define HTChunkCreate(growby) HTChunk_new(growby)
#define HTChunkFree(ch)       HTChunk_delete(ch)
#define HTChunkClear(ch)      HTChunk_clear(ch)
#define HTChunkEnsure(ch, s)  HTChunk_ensure((ch), (s))
#define HTChunkPutc(ch, c)    HTChunk_putc((ch), (c))
#define HTChunkPuts(ch, str)  HTChunk_puts((ch), (str))
#define HTChunkTerminate(ch)  HTChunk_terminate(ch)
#define HTChunkData(ch)       HTChunk_data(ch)
#define HTChunkSize(ch)       HTChunk_size(ch)

/*
*/

#endif

/*

  

  @(#) $Id: HTChunk.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTConLen.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Content Length Counter and Other Buffer
  Streams


!
  Content Length Counter and Other Buffer Streams
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module provides various forms of buffering streams. You can also check
out the chunk buffer stream which converts a
stream to a memory buffer. These streams preseerve the streaming model.

The content length counter &nbsp;stream buffers the result&nbsp;to find out
the content length&nbsp;before the data is forwarded to the target stream.
You can use this stream when generating a HTTP response in order to find
the content length before writing the object to the socket, for example.

This module is implemented by HTConLen.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTCONLEN_H
#define HTCONLEN_H

/*
.
  Buffer Stream
.

This stream does almost the same as the content length counter stream except
that it doesn't count the length! In other words - it's a completely normal
memory buffer for the stream. If the buffer fills up, this stream flushes
the buffer and goes transparent so that all new data will be pumped through
without any buffering.
*/

extern HTStream * HTBuffer_new		(HTStream *	target,
					 HTRequest *	request,
					int		max_size);

/*
.
  Content Length Counter Stream
.

This stream can be inserted anywhere to count the content length of the body.
The result is passed to the Anchor object of
this request so that future requests for the content length will get the
right size.
*/

extern HTStream * HTContentCounter	(HTStream *	target,
					 HTRequest *	request,
					 int		max_size);

/*
.
  Delay Buffer Stream
.

This stream is much like the buffer stream above but instead of goin transparent
when the buffer fills up, it returns HT_PAUSE which indicates
that the stream doesn't accept more data and so the caller should not put
any more data into it. When the buffer is flushed (the flush method invoked)
then the stream goes into transparent mode, just like the buffer stream.
*/

extern HTStream * HTDelayBuffer    	(HTStream *	target,
					 int		max_size);

/*
.
  Pipe Buffer Stream
.

This stream is much like the buffer stream above but instead of goin transparent
when the buffer fills up, it returns HT_PAUSE which indicates
that the stream doesn't accept more data and so the caller should not put
any more data into it.
*/

extern HTStream * HTPipeBuffer    	(HTStream *	target,
					 int		max_size);

/*

End of definition module
*/

#endif /* HTCONLEN_H */

/*

  

  @(#) $Id: HTConLen.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTCookie.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Simple Cookie Handler


!
  Simple Cookie Handler
!
*/

/*
**	(c) COPYRIGHT MIT 1999.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module provides a simple
HTTP Cookie
handling mechanism. It really also is an excersize in showing how libwww
can be extended with something like cookies in a modular manner. An important
thing to note about this implementation is that it does not provide
storage for cookies - this is left to the application as normally cookies
have to be kept under lock.

This module is implemented by HTCookie.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTCOOKIE_H
#define HTCOOKIE_H
#include "WWWLib.h"

/*
.
  Initiate and Terminate Cookie Handling
.

In order to start handling cookies, you need to initiate the module. Likewise,
when you are done, you must terminate the module in order to clean up memory
etc. Note that this cookie handler doesn't provide storage room for cookies
- the application MUST do that by registering cookie
callbacks. Initiation does three things:

  o 
	     Register a MIME header parser to parse the Set-Cookie
    header field
  o 
	     Register a BEFORE filter to see if a cookie should
    be added to the request (uses the "set" callback)
  o 
	     Register an AFTER filter to handle new cookies (uses
    the "find" callback)

*/

extern BOOL HTCookie_init (void);
extern BOOL HTCookie_terminate (void);

/*
.
  The Cookie Class
.

The cookie class is used to handle cookies in libwww and to hand them off
to the application. The creation and deletion of cookie object is handled
by this cookie module - the application is handed a cookie and can access
the elements using the following methods:
*/

typedef struct _HTCookie HTCookie;

/*
(
  Cookie Name
)
*/

extern BOOL HTCookie_setName (HTCookie * me, const char * name);
extern char * HTCookie_name (HTCookie * me);

/*
(
  Cookie Value
)
*/

extern BOOL HTCookie_setValue (HTCookie * me, const char * value);
extern char * HTCookie_value (HTCookie * me);

/*
(
  Cookie Domain
)
*/

extern BOOL HTCookie_setDomain (HTCookie * me, const char * domain);
extern char * HTCookie_domain (HTCookie * me);

/*
(
  Cookie Path
)
*/

extern BOOL HTCookie_setPath (HTCookie * me, const char * path);
extern char * HTCookie_path (HTCookie * me);

/*
(
  Cookie Expiration
)
*/

extern time_t HTCookie_setExpiration (HTCookie * me, time_t expiration);
extern time_t HTCookie_expiration (HTCookie * me);

/*
(
  Is Cookie Secure?
)
*/

extern time_t HTCookie_setSecure (HTCookie * me, BOOL secure);
extern BOOL HTCookie_isSecure (HTCookie * me);

/*
.
  Cookie Callbacks
.

The cookie callbacks are called before the request is shipped over the wire
to see if any cookies should be included and after the response has been
recieved if a new cookie is found in a response and before. Cookie callbacks
can be registered with a context that is sent along with the callback when
called.
*/

typedef BOOL HTCookieSetCallback (HTRequest * request, HTCookie * cookie, void * param);
typedef HTAssocList * HTCookieFindCallback (HTRequest * request, void * param);

extern BOOL HTCookie_setCallbacks (HTCookieSetCallback *	setCookie,
				   void * 			setCookieContext,
				   HTCookieFindCallback *	findCookie,
				   void * 			findCookieContext);
extern BOOL HTCookie_deleteCallbacks (void);

/*
.
  Cookie Handling Mode
.

The application can decide how cookies are to be handled - should they be
ignored, should the user be asked, etc.
*/

typedef enum _HTCookieMode {
    HT_COOKIE_ACCEPT          = 0x1,  /* Accept cookies */
    HT_COOKIE_SEND            = 0x2,  /* Send cookies when fit */
    HT_COOKIE_SAME_HOST       = 0x4,  /* Don't accept cookies for other hosts */
    HT_COOKIE_SAME_DOMAIN     = 0x8,  /* Don't accept cookies for other domains */
    HT_COOKIE_PROMPT          = 0x10  /* Prompt before accepting cookies */
} HTCookieMode;

extern BOOL HTCookie_setCookieMode (HTCookieMode mode);
extern HTCookieMode HTCookie_cookieMode (void);

/*
*/

#endif /* HTCOOKIE_H */

/*

  

  @(#) $Id: HTCookie.html,v 1.1.1.1 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTDAV.h
::::::::::::::
/*

  					W3C Sample Code Library libwww WebDAV Access Methods



!
W3C Sample Code Library libwww WebDAV Access Methods
!
*/

/*
**      (c) COPYRIGHT MIT 1995.
**      Please first read the full copyright statement in the file COPYRIGH.
*/

/*


This module contains methods for accessing URIs using WebDAV methods. It
also contains functions for headers definition.


This module is implemented by HTDAV.c and it is a
part of the W3C Sample
CodeLibrary.
*/

#ifndef HTDAV_H
#define HTDAV_H

#ifdef HT_DAV

/*

.
WebDAV HEADERS
.


WebDAV extension protocol defines new headers to be used in its requests.
See RFC2518 for details.
*/

typedef struct _HTDAVHeaders HTDAVHeaders;

extern HTDAVHeaders * HTDAVHeaders_new (void);
extern BOOL HTDAVHeaders_delete (HTDAVHeaders *me);

/*

(
If Header
)


Manipulates the "If" header, which describes a series of state lists. The
caller must assure that the parameter "If" is well-formed. Below, you can see
a small description of If header format. See section 9.4 of RFC2518 for details.


If = "If" ":" ( 1*NOTAGGED | 1*TAGGED )


NOTAGGED = LIST


TAGGED = CODED-URL 1*LIST


LIST = "(" 1*( ["Not"] (STATE-TOKEN | "[" ENTITY-TAG "]" ) ) ")"


STATE-TOKEN = CODED-URL


CODED-URL = "<" AbsoluteURI ">


Note: The caller should free the strings returned by
HTDAV_ifHeader  method.
*/

extern BOOL HTDAV_setIfHeader (HTDAVHeaders *me, const char *If);
extern BOOL HTDAV_deleteIfHeader (HTDAVHeaders * me);
extern char * HTDAV_ifHeader (HTDAVHeaders *me);

/*

(
Depth Header
)


Manipulates the "Depth" header. Depth header is used with methods executed
on resource which could have internal members (Collections) to indicate
whether the method should be applied to the resource children.


The caller must assure that the parameter "Depth" is "0", "1" or
"infinity", and that its value can be applied in the used resquest method
(for example, LOCK method does not support Depth value 1).


Note: The caller should free the string returned by
HTDAV_DepthHeader method.
*/

extern BOOL HTDAV_setDepthHeader (HTDAVHeaders *me, const char *Depth);
extern BOOL HTDAV_deleteDepthHeader (HTDAVHeaders * me);
extern char * HTDAV_DepthHeader (HTDAVHeaders *me);

/*

(
Lock-Tocken header
)


Manipulates the "LockToken" header. It is used in UNLOCK method to
identify the lock to be removed. The caller must assure that the parameter is
a state token well-formed (
RFC2518 section 9.5).


Note: The caller should free the string returned by
HTDAV_LockTokenHeader method.
*/

extern BOOL HTDAV_setLockTokenHeader (HTDAVHeaders *me, const char *LockToken);
extern BOOL HTDAV_deleteLockTokenHeader (HTDAVHeaders * me);
extern char * HTDAV_LockTokenHeader (HTDAVHeaders *me);

/*

(
Destination Header
)


Manipulates the "Destination" header. It is used in COPY and MOVE methods
to identify a destination resource. The caller must assure that the parameter
is an absolute URI.


Note: The caller should free the string returned by
HTDAV_DestinationHeader method.
*/

extern BOOL HTDAV_setDestinationHeader (HTDAVHeaders *me, const char *Destination);
extern BOOL HTDAV_deleteDestinationHeader (HTDAVHeaders * me);
extern char * HTDAV_DestinationHeader (HTDAVHeaders *me);

/*

(
Timeout Header
)


Manipulates the "Timeout" header. It is used in LOCK requests to indicate
the desired timeout value for the requested lock. However, according to the
RFC2518, the server is not
required to honor this value.


The caller must assure that the parameter follows the specification in the
section 9.8 of RFC 2518:


Timeout = "Timeout" ":" 1#TIMETYPE


TIMETYPE = ( "Second-" VAL | "Infinite" | OTHER )


VAL = 1*digit


OTHER = "Extend" Field ; 
RFC2068 - section 4.2


Note: The caller should free the string returned by
HTDAV_TimeoutHeader  method.
*/

extern BOOL HTDAV_setTimeoutHeader (HTDAVHeaders *me, const char *Timeout);
extern BOOL HTDAV_deleteTimeoutHeader (HTDAVHeaders * me);
extern char * HTDAV_TimeoutHeader (HTDAVHeaders *me);

/*

(
Overwrite Header
)


Manipulates the "Overwrite" header. It is used in COPY and MOVE methods to
specify whether the server should overwrite a destination resource.
*/

extern BOOL HTDAV_setOverwriteHeader (HTDAVHeaders *me, BOOL Overwrite);
extern BOOL HTDAV_deleteOverwriteHeader (HTDAVHeaders * me); 
extern BOOL HTDAV_OverwriteHeader (HTDAVHeaders * me); 

/*

.
WebDAV REQUESTS
.


WebDAV extension protocol defines new methods: LOCK, UNLOCK, MOVE, COPY,
MKCOL, PROPFIND, PROPPATCH (See 
RFC2518 for details).

(
LOCK Requests
)


A LOCK request create or refresh a lock over the destiny URI. If it wants
to create a new lock, the request should have a XML body (parameter
"xmlbody"), but if it is a refresh request, this body may be NULL and the
header "If" should be set in HTDAVHeaders object.
*/

extern BOOL HTLOCKDocumentAnchor(HTRequest * request, HTAnchor * dst,
                                 HTParentAnchor *xmlbody, HTDAVHeaders *headers);
extern BOOL HTLOCKAnchor (HTRequest * request,HTAnchor * dst,
                                 char * xmlbody, HTDAVHeaders * headers); 
extern BOOL HTLOCKAbsolute (HTRequest * request, const char * uri,
                                 char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTLOCKRelative (HTRequest * request, const char * relative,
                                 HTParentAnchor * base, char * xmlbody,
                                 HTDAVHeaders * headers);

/*

(
UNLOCK Requests
)


An UNLOCK request removes a lock from the destiny URI. The request must
contain the Lock-Token header set in HTDAVHeaders object (so, the
HTDAVHeaders * headers parameter can't be NULL).
*/

extern BOOL HTUNLOCKAnchor (HTRequest * request, HTAnchor * dst,
                            HTDAVHeaders * headers);
extern BOOL HTUNLOCKAbsolute (HTRequest * request, const char * uri,
                            HTDAVHeaders * headers);
extern BOOL HTUNLOCKRelative (HTRequest * request, const char * relative,
                            HTParentAnchor * base, HTDAVHeaders * headers);

/*

(
PROPFIND Requests
)


PROPFIND requests returns properties defined for the resource. The request
may contain xml entity body with a "propfind" element, which may include an
"allprop" element (to get all properties), a "propname" element (the name of
all properties defined), and a "prop" element containing the desired
properties.
*/

extern BOOL HTPROPFINDAnchor (HTRequest * request, HTAnchor * dst,
                          const char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTPROPFINDDocumentAnchor (HTRequest * request, HTAnchor * dst,
                          HTParentAnchor * xmlbody, HTDAVHeaders * headers);
extern BOOL HTPROPFINDAbsolute (HTRequest * request, const char * uri,
                          const char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTPROPFINDRelative (HTRequest * request, const char * relative,
                          HTParentAnchor * base, const char * xmlbody,
                          HTDAVHeaders * headers);

/*

(
PROPPATCH Requests
)


PROPPATCH requests sets or removes properties defined for the resource.
The request MUST contain xml message body (parameter xmlbody) with a
"propertyupdate" element, which may include a "set" element (to set the
properties) or a "remove" element (to remove the properties).
*/

extern BOOL HTPROPPATCHAnchor (HTRequest * request, HTAnchor * dst,
                         const char * xmlbody,HTDAVHeaders * headers);
extern BOOL HTPROPPATCHDocumentAnchor (HTRequest * request,HTAnchor * dst,
                         HTParentAnchor * xmlbody,HTDAVHeaders * headers);
extern BOOL HTPROPPATCHAbsolute (HTRequest * request, const char * uri,
                         const char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTPROPPATCHRelative (HTRequest * request, const char * relative,
                         HTParentAnchor * base, const char * xmlbody,
                         HTDAVHeaders * headers);

/*

(
MKCOL Requests
)


MKCOL requests are used to create Collections. The resource indicated by
the Request-URI (parameters HTAnchor *dst or char *absolute/relative) MUST
not exist, but all the resource's ancestros MUST exist.
*/

extern BOOL HTMKCOLAnchor (HTRequest * request, HTAnchor * dst,
                         HTDAVHeaders * headers);
extern BOOL HTMKCOLAbsolute (HTRequest * request, const char * uri,
                         HTDAVHeaders * headers);
extern BOOL HTMKCOLRelative (HTRequest * request, const char * relative,
                         HTParentAnchor * base, HTDAVHeaders * headers);

/*

(
COPY Requests
)


COPY requests copies the Request-URI (parameters HTAnchor *src or char
*absolute/relative) to the resource indicated in Destinarion header. The
HTDAVHeaders *headers parameter MUST be a non-null object and it MUST have
the Destination header set. Other headers may also be used, like Depth (0 or
infinity), If and Overwrite headers.
*/

extern BOOL HTCOPYAnchor (HTRequest * request, HTAnchor * src,
                        const char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTCOPYDocumentAnchor (HTRequest * request, HTAnchor * src,
                        HTParentAnchor * xmlbody, HTDAVHeaders * headers);
extern BOOL HTCOPYAbsolute (HTRequest * request, const char * uri,
                        const char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTCOPYRelative (HTRequest * request, const char * relative,
                        HTParentAnchor * base, const char * xmlbody,
                        HTDAVHeaders * headers);

/*

(
MOVE Requests
)


MOVE requests moves the Request-URI (parameters HTAnchor *src or char
*absolute/relative) to the resource indicated in Destinarion header. The
HTDAVHeaders *headers parameter MUST be a non-null object and it MUST have
the Destination header set. Other headers may also be used, like Depth ("0"
or "infinity" - if the resource is a Collection, Depth must only be
"infinity"), If and Overwrite headers.
*/

extern BOOL HTMOVEAnchor (HTRequest * request, HTAnchor * src,
                        const char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTMOVEDocumentAnchor (HTRequest * request, HTAnchor * src,
                        HTParentAnchor * xmlbody, HTDAVHeaders * headers);
extern BOOL HTMOVEAbsolute (HTRequest * request, const char * uri,
                        const char * xmlbody, HTDAVHeaders * headers);
extern BOOL HTMOVERelative (HTRequest * request, const char * relative,
                        HTParentAnchor * base, const char * xmlbody,
                        HTDAVHeaders * headers);

#endif /* HT_DAV */
#endif /* HTDAV_H */

/*




  $Id: HTDAV.html,v 1.1.1.1 2005/07/06 09:34:01 gully Exp $




*/
::::::::::::::
HTDemux.h
::::::::::::::
/*

  					W3C Sample Code Library Socket Reader Stream


!
  Demultiplexing Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The MUX Reader Stream is an input stream
&nbsp;which knows how to demultiplex a MUX channel. It is part of the
Transport interface and may be registered as
part of a Transport Object. The application
can&nbsp;initialize this stream together with the
HTMuxTx stream, for example. In the
default initialization module, you can find the
HTTransportInit() function which sets up this stream as a default
transport for handling socket read operations.

This module is implemented by HTMuxRx.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTMUXRX_H
#define HTMUXRX_H
#include "HTStream.h"
#include "HTMuxCh.h"

/*

*/

extern HTStream * HTDemux_new (HTHost * host, HTMuxChannel * muxch);

/*
*/

#endif

/*

  

  @(#) $Id: HTDemux.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTDescpt.h
::::::::::::::
/*

					W3C Sample Code Library libwww File descriptions




!File Descriptions!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Descriptions appearing in directory listings
are produced by this module. This may be overridden by another module
for those who which descriptions to come from somewhere else. It's
only HTTP directory listings that contain a description field (if
enabled by the Directory browsing module.

This module is implemented by HTDescpt.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTDESCRIPT_H
#define HTDESCRIPT_H


/*

.Description File.

This module gets descriptions from the file defined by global variable
HTDescriptionFile in the same directory as the directoy
to be listed. The default value is .www_descript:

*/

extern char * HTDescriptionFile;

/*

In the description file lines starting with a word starting with 'D'
are taken to be descriptions (this looks funny now, but this is to
make it easy to extend these description files to contain also other
information. An example of the format of the description file is:

*/

/*
**	DESCRIBE  welcome.html	Our welcome page
**	DESCRIBE  map*.gif	Map as a GIF image
**	DESCRIBE  map*.ps	Map as a PostScript image
*/

/*

.HTML Titles.

If description is not specified for a file that is of type
text/html, this module uses the HTML TITLE as the
description.  This feature can be turned off by setting the
HTPeekTitles variable to false.

*/

extern BOOL HTPeekTitles;

/*

.Read Description File.

The description file for a directory is read in only once by
HTReadDescriptions(), and the result returned by it is
given as an argument when finding out a description for a single file.

*/

extern HTList * HTReadDescriptions (char * dirname);

/*

.Get Description For a File.

Once description file has been read and the list of descriptions is
returned by HTReadDescriptions(), the function
HTGetDescription() can be used to get a description for a
given file:

*/

extern char * HTGetDescription (HTList *	descriptions,
				       char *	dirname,
				       char *	filename,
				       HTFormat	format);

/*

Directory name has to be present because this function may then take a
peek at the file itself (to get the HTML TITLE, for example).
If format is WWW_HTML and description is not
found, this module may be configured to use the HTML TITLE as the
description. 

No string returned by this function should be freed!


.Freeing Descriptions.

Once descriptions have been gotten, the description list returned by
HTReadDescriptions() must be freed by
HTFreeDescriptions():
*/

extern void HTFreeDescriptions (HTList * descriptions);

/*

*/

#endif /* !HTDESCRIPT_H */

/*



@(#) $Id: HTDescpt.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTDialog.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Messages and Dialogs


!
  Application side Error Messages And the like
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module provides some "make life easier" functions in order to get the
application going. The functionality of this module was originally in
HTAccess, but now It is part of the
application interface which the application
may use it if desired.

This module is implemented by HTHome.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTDIALOG_H
#define HTDIALOG_H
#include "WWWLib.h"

/*
.
  Default English Error Messages and Progress Notifications
.

The following functions provide a default set of error messages and prompts
in plain English. You can of course change this as you like.
(
  Default English User Prompts and Questions
)

This list corresponds to the enumeration list defined in the
HTAlert module
*/

#define HT_MSG_ENGLISH_INITIALIZER \
    "Please enter username:", \
    "Please enter username for proxy authentication:", \
    "Please enter username for this FTP server:", \
    "Password:", \
    "Please give name of file to save in:", \
    "Plase enter account:", \
    "You might not be allowed to use this method here, continue?", \
    "Location has moved, continue?", \
    "A new set of rules is requested to be added to your setup - continue?", \
    "This file already exists - replace existing file?", \
    "Authentication failed - retry?", \
    "Proxy authentication failed - retry?", \
    "This method has already been performed - repeat operation?", \
    "This document is very big - continue operation?", \
    "The source document for this operation has moved - continue operation \
with new location?", \
    "The destination document for this operation has moved - continue \
operation with new location?", \
    "A redirection may change the behavior of this method - proceed anyway?", \
    "An automatic request for changing proxy has been encountered - continue?", \
    "The persistent cache is already in use by another user. If this is not \
the case then you can manually delete this lock and restart.", \
    "The server has sent you a cookie - accept?"

/*
(
  Default English Messages and Progress Notifications
)

This list corresponds to the enumeration list defined in the
HTError module
*/

/*    CODE  ERROR MESSAGE				ERROR URL */
#define HTERR_ENGLISH_INITIALIZER \
    { 100, "Continue", 					"information" }, \
    { 101, "Switching Protocols",			"information" }, \
    { 200, "OK", 					"success" }, \
    { 201, "Created", 					"success" }, \
    { 202, "Accepted", 					"success" }, \
    { 203, "Non-authoritative Information",		"success" }, \
    { 204, "Document Updated",				"success" }, \
    { 205, "Reset Content",				"success" }, \
    { 206, "Partial Content",				"success" }, \
    { 207, "Partial Update OK",				"success" }, \
    { 300, "Multiple Choices",				"redirection" }, \
    { 301, "Moved Permanently",				"redirection" }, \
    { 302, "Found",  			                "redirection" }, \
    { 303, "See Other",					"redirection" }, \
    { 304, "Not Modified",       			"redirection" }, \
    { 305, "Use Proxy",					"redirection" }, \
    { 306, "Proxy Redirect",				"redirection" }, \
    { 307, "Temporary Redirect",			"redirection" }, \
    { 400, "Bad Request", 				"client_error" }, \
    { 401, "Unauthorized",				"client_error" }, \
    { 402, "Payment Required", 				"client_error" }, \
    { 403, "Forbidden", 				"client_error" }, \
    { 404, "Not Found",		       			"client_error" }, \
    { 405, "Method Not Allowed",	 		"client_error" }, \
    { 406, "Not Acceptable",		 		"client_error" }, \
    { 407, "Proxy Authentication Required", 		"client_error" }, \
    { 408, "Request Timeout",		 		"client_error" }, \
    { 409, "Conflict",			 		"client_error" }, \
    { 410, "Gone",			 		"client_error" }, \
    { 411, "Length Required",		 		"client_error" }, \
    { 412, "Precondition Failed",	 		"client_error" }, \
    { 413, "Request Entity Too Large",	 		"client_error" }, \
    { 414, "Request-URI Too Large",	 		"client_error" }, \
    { 415, "Unsupported Media Type",	 		"client_error" }, \
    { 416, "Range Not Satisfiable",	 		"client_error" }, \
    { 417, "Expectation Failed",	 		"client_error" }, \
    { 418, "Reauthentication Required",	 		"client_error" }, \
    { 419, "Proxy Reauthentication Reuired", 		"client_error" }, \
    { 500, "Internal Server Error",			"server_error" }, \
    { 501, "Not Implemented", 				"server_error" }, \
    { 502, "Bad Gateway", 				"server_error" }, \
    { 503, "Service Unavailable",			"server_error" }, \
    { 504, "Gateway Timeout", 				"server_error" }, \
    { 505, "HTTP Version not supported",		"server_error" }, \
    { 506, "Partial update Not Implemented",		"server_error" }, \
 \
    /* Cache Warnings */ \
    { 10,  "Response is Stale",				"cache" }, \
    { 11,  "Revalidation Failed",			"cache" }, \
    { 12,  "Disconnected Opeartion",			"cache" }, \
    { 13,  "Heuristic Expiration",			"cache" }, \
    { 14,  "Transformation Applied",			"cache" }, \
    { 99,  "Cache warning", 				"cache" }, \
 \
    /* Non-HTTP Error codes and warnings */ \
    { 0,   "Can't locate remote host", 			"internal" }, \
    { 0,   "No host name found", 			"internal" }, \
    { 0,   "No file name found or file not accessible", "internal" }, \
    { 0,   "FTP server replies", 			"internal" }, \
    { 0,   "FTP server doesn't reply", 			"internal" }, \
    { 0,   "FTP login failure", 			"internal" }, \
    { 0,   "Server timed out", 				"internal" }, \
    { 0,   "Gopher-server replies", 			"internal" }, \
    { 0,   "Data transfer interrupted", 		"internal" }, \
    { 0,   "Connection establishment interrupted", 	"internal" }, \
    { 0,   "CSO-server replies", 			"internal" }, \
    { 0,   "This is probably a HTTP server 0.9 or less","internal" }, \
    { 0,   "Bad, Incomplete, or Unknown Response",	"internal" }, \
    { 0,   "Unknown access authentication scheme",	"internal" }, \
    { 0,   "News-server replies",			"internal" }, \
    { 0,   "Trying `ftp://' instead of `file://'",	"internal" }, \
    { 0,   "Too many redirections",			"internal" }, \
    { 0,   "Method not suited for automatic redirection","internal" }, \
    { 0,   "Premature End Of File",			"internal" }, \
    { 0,   "Response from WAIS Server too Large - Extra lines \
ignored","internal"}, \
    { 0,   "WAIS-server doesn't return any data", 	"internal" }, \
    { 0,   "Can't connect to WAIS-server",		"internal" }, \
    { 0,   "operation failed",				"internal" }, \
    { 0,   "Wrong or unknown access scheme",		"internal" }, \
    { 0,   "Access scheme not allowed in this context",	"internal" }, \
    { 0,   "When you are connected, you can log in",	"internal" }, \
    { 0,   "This version has expired and will be automatically reloaded", "internal" }, \
    { 0,   "Loading new rules must be explicitly acknowledged", "internal" }, \
    { 0,   "Automatic proxy redirection must be explicitly acknowledged", "internal" }

/*
(
  Generate a Default Error Message
)

This function provides an unformatted English string containing the possibly
nested status message that explains the result of a request. This is essentially
"flattening out" the information provided in the request
error strack. The string must be freed by the caller.
*/

extern char * HTDialog_errorMessage (HTRequest * request, HTAlertOpcode op,
			             int msgnum, const char * dfault,
				     void * input);

/*
(
  Generate a Default Progress Notification Message
)

This function provides a string containin an English progress message that
the application can present to the user if desired. The string must be freed
by the caller.
*/

extern char * HTDialog_progressMessage (HTRequest * request, HTAlertOpcode op,
			                int msgnum, const char * dfault,
				        void * input);

/*
.
  Default User Interaction Handlers
.

You can register a set of callback functions to handle user prompting, error
messages, confimations etc. Here we give a set of functions that can be used
on almost anu thinkable platform. If you want to provide your own platform
dependent implementation then fine :-)
(
  Display a message, then wait for 'YES' or 'NO'
)

This function prompts the user for a confirmation on the message passed as
a parameter. If the user reacts in the affirmative, returns TRUE,
returns FALSE otherwise.
*/

extern HTAlertCallback HTConfirm;

/*
(
  Prompt the User a Question
)

Prompt for answer and get text back. Reply text is either NULL on error or
a dynamic string which the caller must free.
*/
		
extern HTAlertCallback HTPrompt;

/*
(
  Prompt for a Password
)

Prompt for password without echoing the reply. Reply text is weither NULL
on error or a dynamic string which the caller must free.

NOTE: The current version uses getpass which on many systems
returns a string of 8 or 16 bytes.
*/

extern HTAlertCallback HTPromptPassword;

/*
(
  Prompt for a UserID and a Password
)

This is just a composite function using HTPrompt and
HTPromptPassword. The strings returned must be freed by caller.
*/

extern HTAlertCallback HTPromptUsernameAndPassword;

/*
(
  Display a Message
)

This function simply puts out the message passed.
*/

extern HTAlertCallback HTAlert;

/*
(
  Progress Notification
)

This function can be used to indicate the current status of a certain action.
In order to avoid having strings directly in the core parts of the Library,
this function is passed a "state" argument from which the message can be
generated in this module. The "param" argument is for additional information
to be passed.
*/

extern HTAlertCallback HTProgress;

/*
(
  Generating a User Error Message of a request
)

This function outputs the content of the error list to standard output (used
in Line Mode Browser), but smart clients and servers might overwrite this
function so that the error messages can be handled to the user in a nice(r)
way. That is the reason for putting the actual implementation in
HTAlert.c.

*/

extern HTAlertCallback HTError_print;

/*
(
  Generating a Server Error Message of a request
)

Default function that creates an error message using HTAlert() to put out
the contents of the error_stack messages. Furthermore, the error_info structure
contains a name of a help file that might be put up as a link. This file
can then be multi-linguistic.
*/

extern BOOL HTError_response (HTRequest * request, HTAlertOpcode op,
			      int msgnum, const char * dfault, void * input,
			      HTAlertPar * reply);

/*
*/

#endif /* HTDIALOG_H */

/*

  

  @(#) $Id: HTDialog.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTDigest.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Generic Message Digest
  Interface


!
  Generic Message Digest Interface
!
*/

/*
**	(c) COPYRIGHT W3C, INRIA 1998.
**	Please first read the full copyright statement in the file COPYRIGHT.
*/

/*


Contains a generic interface to the message digest algorithms, inspired
from the RSA-Euro toolkit. For the moment, it only covers MD5.
SHA and other algorithms could be added later on. This code is only
used during message digest authentication.

AUTHORS:
   JK	Jose Kahan       jose@w3.org

HISTORY:
        Dec 98 JK	Created the module from scratch


This module is implemented by HTDigest.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTDigest_H
#define HTDigest_H
/* Library include files */
#include "WWWLib.h"
/* add the MD algorithm header files here below */
#include "md5.h"

/*
.
  Interface to message digest algorithms
.

The list of known message digest algorithms
*/

#define HTDaMD5 1

/*

This is our general digest context structure. If you add a new
algorithm, include its context in the union.
*/

typedef struct _HTDigestContext {
  int algorithm;          
    union { 
           MD5_CTX md5;
    } context;
} HTDigestContext;

/*

This is a set of generic functions for generating a message digest
*/

extern BOOL HTDigest_init (HTDigestContext *context, int digesttype);
extern BOOL HTDigest_update (HTDigestContext *context, char *input, unsigned int inputLen);
extern BOOL HTDigest_final (unsigned char *digest, HTDigestContext *context);

/*
*/

#endif	/* NOT HTDigest_H */

/*

  

  @(#) $Id: HTDigest.html,v 1.1.1.1 2005/07/06 09:34:01 gully Exp $

*/





::::::::::::::
HTDir.h
::::::::::::::
/*

					W3C Sample Code Library libwww DIRECTORY BROWSING




!Directory Browsing!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The directory manager generates directory listings for FTP and HTTP
requests. This module contains the protocol independent code and it
produces the HTML object. It is only included if either the FTP or the File module
is included. 

This module is implemented by HTDir.c, and it is
a part of the  W3C
Sample Code Library.

*/

#ifndef HTDIR_H
#define HTDIR_H
#include "HTReq.h"
#include "HTIcons.h"

/*

.What Should the Listings Look Like?.

If the HT_DS_DES is set then the Description
field is added as the last column in the listing.  File descriptions
are queried from the HTDescript
module. Make a full mask by adding/oring the following flags:

*/

typedef enum _HTDirShow {
    HT_DS_SIZE  = 0x1,			/* Show file size using K, M and G? */
    HT_DS_DATE  = 0x2,			/* Show last modified date? */
    HT_DS_HID   = 0x4,			/* Show hidden files? */
    HT_DS_DES	= 0x8,			/* Show descriptions? */
    HT_DS_ICON  = 0x10,			/* Show icons? */
    HT_DS_HOTI  = 0x20			/* Are Icons hot or cold? */
} HTDirShow;

typedef enum _HTDirKey {
    HT_DK_NONE	= 0,			/* No sorting */
    HT_DK_CSEN	= 1,			/* Case sensitive */
    HT_DK_CINS  = 2			/* Case insensitive */
} HTDirKey;

/*

(Length of Filenames and Descriptions)

The module automatically ajusts the width of the directory listing as
a function of the file name. The width can flows dynamically between
an upper and a lower limit.  The maximum length of
this field is specified by

*/

extern BOOL HTDir_setWidth (int minfile, int maxfile);

/*

.The Directory Object.

The directory object handles the generation of a directory listing. It
is a bit like a stream in that it accept data, but it must be
formatted in a special way which makes the normal stream architecture
inadequate.

(Width of File Names)

The module automatically ajusts the width of the directory listing as
a function of the file name. The width can flows dynamically between
an upper and a lower limit.

*/

extern BOOL HTDir_setWidth (int minfile, int maxfile);

/*

(Create a Directory Object)

Creates a structured stream object and sets up the initial HTML stuff
Returns the dir object if OK, else NULL

*/

typedef struct _HTDir HTDir;

extern HTDir * HTDir_new (HTRequest * request, HTDirShow show, HTDirKey key);

/*

(Add a Line to the List)

This function accepts a directory line. "data" and "size", and
"description" can all be NULL. Returns YES if OK, else NO

*/

extern BOOL HTDir_addElement	(HTDir *dir, char *name, char *date,
				 char *size, HTFileMode mode);

/*

(Free a Directory Obejct)

If we are sorting then do the sorting and put out the list,
else just append the end of the list.

*/

extern BOOL HTDir_free (HTDir * dir);

/*

*/

#endif /* HTDIR */

/*



@(#) $Id: HTDir.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTDNS.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww DNS Class


!
  Domain Name Service Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The DNS Class defines generic access to &nbsp;the DNS system. It maintains
a cache of all visited hosts so that subsequent connects to the same host
doesn't imply a new request to the DNS every time. Multihomed hosts are treated
specially in that the time spend on every connect is measured and kept in
the cache. On the next request to the same host, the IP-address with the
lowest average connect time is chosen. If one IP-address fails completely,
e.g. connection refused then it disabled and HTDoConnect tries one
of the other IP-addresses to the same host.

Every entry in the cache has its own time to live (TTL) and hence the cache
manages its own automatic garbage collection. Currently the TTL is not
bound to the DNS records which should be changed. You can set the DNS object
TTL

This module is implemented by HTDNS.c, and it is a
part of the  W3C Sample Code Library.
*/

#ifndef HTDNS_H
#define HTDNS_H


/*
*/
typedef struct _HTdns HTdns;

/*
.
  DNS Cache Expiration Time
.

When to remove an entry in the DNS cache. We maintain our own DNS cache as
we keep track of the connect time, pick the fastet host on multi-homed hosts
etc. However we DO NOT HONOR DNS TTL Records which is the
reason for why the expiration must be faily short (the default value is 30
mins), so that it doesn't collide with the DNS mechanism for timing out DNS
records befoew swapping IP addresses around.
*/

extern void HTDNS_setTimeout (time_t timeout);
extern time_t HTDNS_timeout  (time_t timeout);

/*
.
  Creation and Deletion Methods
.
(
  Add a DNS Object
)

Add an element to the cache of visited hosts. The homes variable
indicates the number of IP addresses found when looking up the name. A host
name must NOT contain a port number.
*/

extern HTdns * HTDNS_add (HTList * list, struct hostent * element,
			  char * host, int * homes);

/*
(
  Delete a DNS object
)

This function flushes the DNS object from the cache and frees up memory
*/

extern BOOL HTDNS_delete (const char * host);

/*
(
  Delete ALL DNS objects
)

This function is called from  HTLibTerminate. It
can be called at any point in time if the DNS cache is going to be flushed.
*/

extern BOOL HTDNS_deleteAll (void);

/*
.
  DNS Class Methods
.
(
  Recalculating the Time Weights on Multihomed Host
)

On every connect to a multihomed host, the average connect time is updated
exponentially for all the entries.
*/

extern BOOL HTDNS_updateWeigths (HTdns *dns, int cur, ms_t deltatime);

/*
.
  IDN (Internationalized Domain Names) Functions
.
(
  Calculate ACE (punycode) from UTF-8 encoded IDN
)

Converts to ACE (Ascii-compatible encoding, punycode) from an
Internationalized Domain name. %hh-escaping in domain name is
accepted for backwards compatibility. Returns 0 if successful.

*/

extern int HTACEfromUTF8 (char *hostUTF8, char *punycode, size_t punyLength);

/*
.
  Resolver Functions
.

These are the functions that resolve a host name
(
  Get Host By Socket
)

This function should have been called HTGetHostByAddr but for historical
reasons this is not the case.
*/

extern char * HTGetHostBySock (int soc);

/*
(
  Get Host By Name
)

This function gets the address of the host and puts it in to the socket
structure. It maintains its own cache of connections so that the communication
to the Domain Name Server is minimized. Returns the number of homes or -1
if error.
*/

extern int HTGetHostByName (HTHost * host, char *hostname, HTRequest * request);

/*
*/

#endif

/*

  

  @(#) $Id: HTDNS.html,v 1.1.1.2 2005/07/06 09:34:01 gully Exp $

*/
::::::::::::::
HTEPtoCl.h
::::::::::::::
/*

  
  
  
  					W3C Sample Code Library libwww Callback Stream Callbacks


!
  External Parser Callbacks
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

An interface between the XParse module and the
Application. This module contains the interface between the XParse module
and the client. The dummy function is only here so that clients that use
the XParse module can overwrite it. See also
HTXParse

This module is implemented by HTEPtoCl.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTEPTOCLIENT_H
#define HTEPTOCLIENT_H

#include "HTStream.h"
#include "HTXParse.h"

extern CallClient HTCallClient;

#endif

/*

  

  @(#) $Id: HTEPtoCl.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTError.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Error Class


!
  The Error Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Error class provides an easy API for registering errors ocurring while
libwww serves a request. All errors are registered in an "error stack"&nbsp;in
the Request object which allows for nested errors.
The Error class is both natural language independent and application independent
in that it uses enumerations in order to refer to specific errors. It is
for the application to provide an error presentation module which interprets
the errors associated with a request. An eample of such an implementation
can be found in the HTDialog module.

This module is implemented by HTError.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTERROR_H
#define HTERROR_H

typedef struct _HTError HTError;

typedef enum _HTSeverity {
    ERR_UNKNOWN		  = 0x0,
    ERR_FATAL		  = 0x1,
    ERR_NON_FATAL	  = 0x2,
    ERR_WARN	 	  = 0x4,
    ERR_INFO	 	  = 0x8
} HTSeverity;

#include "HTReq.h"

/*
.
  The Error Message Object
.

An error consists of a messsage code, a short, natural language specific
message, and a URI which can point to more information. This module also
provides a default set of error objects with English text.
Errors are registered together with a severity and you can also set the mode
for what class of error severities should be shown and which
should be ignored.
*/

typedef struct _HTErrorMessage {
    int  	code;           	/* Error number */
    char *	msg;          		/* Short explanation */
    char *	url;			/* Explaning URL */
} HTErrorMessage;

/*
(
  Error Message Index
)

Note: All non-HTTP error codes have (index number >
HTERR_HTTP_CODES), and they will not be shown in the error-message
generated.

Error codes are registered in an array where the following enumerations serve
as an index. They must not be replaced! See the
HTDialog module for default initialization
of these messages.
*/

typedef enum _HTErrorElement {
	HTERR_CONTINUE = 0,					/* 100 */
	HTERR_SWITCHING,					/* 101 */
	HTERR_OK,						/* 200 */
	HTERR_CREATED,						/* 201 */
	HTERR_ACCEPTED,						/* 202 */
	HTERR_NON_AUTHORITATIVE,				/* 203 */
	HTERR_NO_CONTENT,					/* 204 */
	HTERR_RESET,						/* 205 */
	HTERR_PARTIAL,						/* 206 */
	HTERR_PARTIAL_OK,					/* 207 */
	HTERR_MULTIPLE,						/* 300 */
	HTERR_MOVED,						/* 301 */
	HTERR_FOUND,						/* 302 */
	HTERR_METHOD,						/* 303 */
	HTERR_NOT_MODIFIED,					/* 304 */
	HTERR_USE_PROXY,					/* 305 */
	HTERR_PROXY_REDIRECT,					/* 306 */
	HTERR_TEMP_REDIRECT,					/* 307 */
	HTERR_BAD_REQUEST,					/* 400 */
	HTERR_UNAUTHORIZED,					/* 401 */
	HTERR_PAYMENT_REQUIRED,					/* 402 */
	HTERR_FORBIDDEN,					/* 403 */
	HTERR_NOT_FOUND,					/* 404 */
	HTERR_NOT_ALLOWED,					/* 405 */
	HTERR_NONE_ACCEPTABLE,					/* 406 */
	HTERR_PROXY_UNAUTHORIZED,				/* 407 */
	HTERR_TIMEOUT,						/* 408 */
	HTERR_CONFLICT,						/* 409 */
	HTERR_GONE,						/* 410 */
	HTERR_LENGTH_REQUIRED,					/* 411 */
	HTERR_PRECON_FAILED,					/* 412 */
	HTERR_TOO_BIG,						/* 413 */
	HTERR_URI_TOO_BIG,					/* 414 */
	HTERR_UNSUPPORTED,					/* 415 */
	HTERR_BAD_RANGE,					/* 416 */
	HTERR_EXPECTATION_FAILED,				/* 417 */
	HTERR_REAUTH,				                /* 418 */
	HTERR_PROXY_REAUTH,				        /* 419 */
	HTERR_INTERNAL,						/* 500 */
	HTERR_NOT_IMPLEMENTED,					/* 501 */
	HTERR_BAD_GATE,						/* 502 */
	HTERR_DOWN,						/* 503 */
	HTERR_GATE_TIMEOUT,					/* 504 */
	HTERR_BAD_VERSION,					/* 505 */
	HTERR_NO_PARTIAL_UPDATE,				/* 506 */

#ifdef HT_DAV 
	/* WebDAV error codes */
	HTERR_UNPROCESSABLE,					/* 422 */
	HTERR_LOCKED,           				/* 423 */
	HTERR_FAILED_DEPENDENCY,				/* 424 */
	HTERR_INSUFFICIENT_STORAGE,				/* 507 */
#endif

	/* Cache warnings */
	HTERR_STALE,						/* 10 */
	HTERR_REVALIDATION_FAILED,				/* 11 */
	HTERR_DISCONNECTED_CACHE,				/* 12 */
	HTERR_HEURISTIC_EXPIRATION,				/* 13 */
	HTERR_TRANSFORMED,					/* 14 */
	HTERR_CACHE,						/* 99 */

	/* Put all non-HTTP status codes after this */
	HTERR_NO_REMOTE_HOST,
	HTERR_NO_HOST,
	HTERR_NO_FILE,
	HTERR_FTP_SERVER,
	HTERR_FTP_NO_RESPONSE,
        HTERR_FTP_LOGIN_FAILURE,
	HTERR_TIME_OUT,
	HTERR_GOPHER_SERVER,
	HTERR_INTERRUPTED,
	HTERR_CON_INTR,
	HTERR_CSO_SERVER,
	HTERR_HTTP09,
	HTERR_BAD_REPLY,
	HTERR_UNKNOWN_AA,
	HTERR_NEWS_SERVER,
	HTERR_FILE_TO_FTP,
	HTERR_AUTO_REDIRECT,
	HTERR_MAX_REDIRECT,
	HTERR_EOF,
	HTERR_WAIS_OVERFLOW,
	HTERR_WAIS_MODULE,
	HTERR_WAIS_NO_CONNECT,
	HTERR_SYSTEM,
	HTERR_CLASS,
	HTERR_ACCESS,
	HTERR_LOGIN,
        HTERR_CACHE_EXPIRED,
        HTERR_NO_AUTO_RULES,
        HTERR_NO_AUTO_PROXY,
	HTERR_ELEMENTS		            /* This MUST be the last element */
} HTErrorElement;

/*
(
  Default English Language Messages
)

Default set of error messages arranged in an array into which the
index codes serve as index. See the
HTDialog module for default initialization
of these strings.
.
  What Errors should be Ignored or Passed Through?
.

This variable dictates which errors should be put out when generating the
message to the user. The first four enumerations make it possible to see
`everything as bad or worse than' this level, e.g. HT_ERR_SHOW_NON_FATAL
shows messages of type HT_ERR_SHOW_NON_FATAL and
HT_ERR_SHOW_FATAL.

Note: The default value is made so that it only puts a message to
stderr if a `real' error has occurred. If a separate widget is available
for information and error messages then probably
HT_ERR_SHOW_DETAILED would be more appropriate.
*/

typedef enum _HTErrorShow {
    HT_ERR_SHOW_FATAL     = 0x1,
    HT_ERR_SHOW_NON_FATAL = 0x3,
    HT_ERR_SHOW_WARNING   = 0x7,
    HT_ERR_SHOW_INFO 	  = 0xF,
    HT_ERR_SHOW_PARS	  = 0x10,
    HT_ERR_SHOW_LOCATION  = 0x20,
    HT_ERR_SHOW_IGNORE    = 0x40,
    HT_ERR_SHOW_FIRST     = 0x80,
    HT_ERR_SHOW_LINKS     = 0x100,
    HT_ERR_SHOW_DEFAULT	  = 0x13,
    HT_ERR_SHOW_DETAILED  = 0x1F,
    HT_ERR_SHOW_DEBUG	  = 0x7F
} HTErrorShow;

extern HTErrorShow HTError_show (void);
extern BOOL HTError_setShow (HTErrorShow mask);

/*
.
  Creation and Deletion Methods
.
(
  Add an Error
)

Add an error message to the error list. `par' and `where' might be set to
NULL. If par is a string, it is sufficient to let length be unspecified,
i.e., 0. If only a part of the string is wanted then specify a length inferior
to strlen((char *) par). The string is '\0' terminated automaticly. See also
HTError_addSystem for system errors. Returns YES if OK, else NO.
*/

extern BOOL HTError_add (HTList * 	list,
			 HTSeverity	severity,
			 BOOL		ignore,
			 int		element,
			 void *		par,
			 unsigned int	length,
			 char *		where);


/*
(
  Add a System Error
)

Add a system error message to the error list. syscall is the name of the
system call, e.g. "close". The message put to the list is that corresponds
to the error number passed. See also HTError_add. Returns YES if OK, else
NO.
*/

extern BOOL HTError_addSystem (HTList *		list,
			       HTSeverity 	severity,
			       int		errornumber,
			       BOOL		ignore,
			       char *		syscall);

/*
(
  Delete an Entire Error Stack
)

Deletes all errors in a list.
*/

extern BOOL HTError_deleteAll (HTList * list);

/*
(
  Deletes the Last Edded Entry
)

Deletes the last error entry added to the list. Return YES if OK, else NO
*/

extern BOOL HTError_deleteLast (HTList * list);

/*
.
  Object Methods
.
(
  Show the Error Entry?
)

Should we show this entry in the list or just continue to the next one?
*/

extern BOOL HTError_doShow (HTError * info);

/*
(
  Ignore last Added Error
)

Turns on the `ignore' flag for the most recent error entered the error list.
Returns YES if OK else NO
*/

extern BOOL HTError_ignoreLast	(HTList * list);
extern BOOL HTError_setIgnore	(HTError * info);

/*
(
  Error Index Number
)

Each error object is assigned an index number as defined by the
HTErrorElement above. The mapping from this index to an error
code and a message must be done by the application. The Library provides
a default implementation in the  HTDialog module,
but that can of course be changed depending on the application.
*/

extern int HTError_index		(HTError * info);

/*
(
  Error Severity
)

This function returns the severity of the error object passed by the caller
*/
extern HTSeverity HTError_severity	(HTError * info);

/*

You can ask whether a list of errors contains any error object with a severity
level which is higher than the one specifed.
*/
extern BOOL HTError_hasSeverity 	(HTList * list, HTSeverity severity);

/*
(
  Parameters Asscotiated with Error
)
*/

extern void * HTError_parameter		(HTError * info, int * length);

/*
(
  Where did it happen?
)
*/

extern const char * HTError_location	(HTError * info);

/*
*/

#endif /* HTERROR_H */

/*

  

  @(#) $Id: HTError.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTEscape.h
::::::::::::::
/*

  					W3C Sample Code Library libwww URIs


!
  Escape and Unescape Illegal Characters in URIs
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

URLs are written only with the graphic printable characters of the US-ASCII
coded character set. All other characters must be escaped before they can
be used in URLs. This module defines the methods required for escaping and
unescaping the URLs. Internally in the Library, all URLs are escaped so that
we never see illegal characters in the URL handled by the Library. We only
unescape the URLs when we have to, for example while taking to the local
file system etc.

This module is implemented by HTEscape.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTESCAPE_H
#define HTESCAPE_H


/*
.
  Encode Unacceptable Characters using %xy
.

This function takes a string containing any sequence of ASCII characters,
and returns a malloced string containing the same infromation but with all
"unacceptable" characters represented in the form %xy where
x and y are two hex digits.
*/

typedef enum _HTURIEncoding {
    URL_XALPHAS		= 0x1,     /* Escape all unsafe characters */
    URL_XPALPHAS	= 0x2,     /* As URL_XALPHAS but allows '+' */
    URL_PATH		= 0x4,     /* As URL_XPALPHAS but allows '/' */
    URL_DOSFILE         = 0x8      /* As URL_URLPATH but allows ':' */
} HTURIEncoding;

extern char * HTEscape (const char * str, HTURIEncoding mask);

/*

.
  Convert a single Character from Ascii Hex to Char
.

*/

extern char HTAsciiHexToChar (char c);

/*

.
  Decode %xy Escaped Characters
.

This function takes a pointer to a string in which character smay have been
encoded in %xy form, where xy is the acsii hex
code for character 16x+y. The string is converted in place, as it will never
grow.
*/

extern char * HTUnEscape (char * str);

/*
*/

#endif	/* HTESCAPE_H */

/*

  

  @(#) $Id: HTEscape.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTEvent.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Event Class


!
  The Event Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Event Class defines any event manager to be used by libwww for handling
events. An event is not strictly defined as it is highly platform
dependent and hence out of scope for the Library. If you are using the libwww
pseudo threads on Unix then an event is when the&nbsp;select() system
call returns a notification on&nbsp;a socket descriptor, but it may as well
be an asynchronous event from the windows manager etc. If your application
is not using anything but traditional blocking sockets then you do not need
an event manager at all. In that case, libwww will block on any socket or
system call until the process can proceed.

The libwww interface to an event manager is very simple as it consists of
registering a socket descriptor, the location in the
program, and the current state when an operation (for example
read) would block. When the event manager at a later point in
time gets a notification that the socket has become ready, it can then call
libwww with the state saved from the registration and libwww can continue.
Second, libwww must be able to unregister a socket when it is not
anymore in a state where it can block. Only in case the application
wishes to use non-blocking sockets it should register methods for
handling the registration process as described below.

Note: The library core does not define any event manager
- it is considered part of the application. The library comes with a
default event manager which can be initiated
using the function HTEventInit() in HTInit
module

This module is implemented by HTEvent.c, and it is
a part of the W3C Sample Code Library.
*/

#ifndef HTEVENT_H
#define HTEVENT_H
#include "wwwsys.h"
#ifdef IN_EVENT
typedef struct _HTTimer HTTimer;
#endif

typedef enum _HTPriority {
    HT_PRIORITY_INV = -1,
    HT_PRIORITY_OFF = 0,
    HT_PRIORITY_MIN = 1,
    HT_PRIORITY_MAX = 20
} HTPriority; 

#define HTEVENT_INDEX 0x10
typedef enum {
#ifdef WWW_WIN_ASYNC
    HTEvent_READ    = (0x001 | 0 << HTEVENT_INDEX),
    HTEvent_WRITE   = (0x002 | 1 << HTEVENT_INDEX),
    HTEvent_OOB     = (0x004 | 2 << HTEVENT_INDEX),
    HTEvent_ACCEPT  = (0x008 | 3 << HTEVENT_INDEX),
    HTEvent_CONNECT = (0x010 | 4 << HTEVENT_INDEX),
    HTEvent_CLOSE   = (0x020 | 5 << HTEVENT_INDEX),
    HTEvent_TYPES   = 6,	/* winsock has seperate events for all of these */
#define HTEVENT_TYPES	6 /* use in constructing the fake event below */
#else /* WWW_WIN_ASYNC */
    HTEvent_READ    = (0x001 | 0 << HTEVENT_INDEX),
    HTEvent_ACCEPT  = (0x002 | 0 << HTEVENT_INDEX),
    HTEvent_CLOSE   = (0x004 | 0 << HTEVENT_INDEX),
    HTEvent_WRITE   = (0x008 | 1 << HTEVENT_INDEX),
    HTEvent_CONNECT = (0x010 | 1 << HTEVENT_INDEX),
    HTEvent_OOB     = (0x020 | 2 << HTEVENT_INDEX),
    HTEvent_TYPES   = 3,	/* only READ, WRITE, and OOB are real types */
#define HTEVENT_TYPES	3 /* use in constructing the fake event below */
#endif /* !WWW_WIN_ASYNC */
    /*
    **	fake events - these don't correspond to event manager events, but they
    **	are usefull for communicating with the protocol modules
    */
    HTEvent_TIMEOUT = (0x040 | HTEVENT_TYPES << HTEVENT_INDEX),
    HTEvent_BEGIN   = (0x000 | HTEVENT_TYPES << HTEVENT_INDEX),
    HTEvent_END     = (0x080 | HTEVENT_TYPES << HTEVENT_INDEX),
    HTEvent_FLUSH   = (0x100 | HTEVENT_TYPES << HTEVENT_INDEX),
    HTEvent_RESET   = (0x200 | HTEVENT_TYPES << HTEVENT_INDEX),
    HTEvent_ALL     = 0xFFFF
} HTEventType;

#define HTEvent_BITS(type) (type & 0xFFFF)
#define HTEvent_INDEX(type) (type >> HTEVENT_INDEX)

#define HT_EVENT_INITIALIZER \
    {HTEvent_READ, "HTEvent_READ"}, \
    {HTEvent_ACCEPT, "HTEvent_ACCEPT"}, \
    {HTEvent_CLOSE, "HTEvent_CLOSE"}, \
    {HTEvent_WRITE, "HTEvent_WRITE"}, \
    {HTEvent_CONNECT, "HTEvent_CONNECT"}, \
    {HTEvent_OOB, "HTEvent_OOB"}, \
    {HTEvent_TIMEOUT, "HTEvent_TIMEOUT"}, \
    {HTEvent_BEGIN, "HTEvent_BEGIN"}, \
    {HTEvent_END, "HTEvent_END"}, \
    {HTEvent_FLUSH, "HTEvent_FLUSH"}, \
    {HTEvent_RESET, "HTEvent_RESET"}

extern char * HTEvent_type2str(HTEventType type);

/*
.
  Event Handlers
.

A location is a function that can be registered by the event manager
and called at a later point in time in order to continue an operation. All
locations must be of type &nbsp;HTEventCallback as defined here:
*/

typedef int HTEventCallback (SOCKET, void *, HTEventType);
typedef struct _HTEvent HTEvent;

/* Avoid circular include for HTReq->HTNet->HTHost: HTEvent blah */
#include "HTReq.h"

/*

There are many default event handlers provided with the Library. For example,
all the protocol modules such as the HTTP client module
are implemented as event handlers. In stead of using blocking sockets, this
allows a protocol module to register itself when performing an operation
that would block. When the sockets becomes ready the handler is called with
th socket in question, the request object, and the socket operation &nbsp;
.
  Registering and Unregistering Events
.

As mentioned above, the only interface libwww requires from an event manager
is a method to register an event when an operation would block and
unregister it when the operation has completed The library registers
and unregisters events by calling the following two functions:
*/

extern int HTEvent_register	(SOCKET, HTEventType, HTEvent *);
extern int HTEvent_unregister	(SOCKET, HTEventType);

/*

The register function contains information about which socket we are waiting
on to get ready and which operation we are waiting for (read, write, etc.),
the request object containing the current request, the event handler that
we want to be called when the socket becomes reasy, and finally the priority
by which we want the thread to be processed by the event manager. Likewise,
libwww can unregister a operation on a socket which means that libwww is
no longer waiting for this actiion to become ready.
.
  Registering an Event Manager
.

Libwww core does not contain any event manager as it depends on whether you
want to use pseudo threads no threads, or real threads. Instead, libwww comes
with a default implementation that you may register,
but you may as well implement and register your own. The register and unregister
functions above actually does nothing than looking for a registered event
manager and then passes the call on to that. You register your own event
manager by using the methods below:
*/

typedef int HTEvent_registerCallback(SOCKET, HTEventType, HTEvent *);
typedef int HTEvent_unregisterCallback(SOCKET, HTEventType);

extern void HTEvent_setRegisterCallback(HTEvent_registerCallback *);
extern void HTEvent_setUnregisterCallback(HTEvent_unregisterCallback *);

/*
(
  Has Register and Unregister Callbacks been setup?
)

Replies YES if both an HTEvent_setRegisterCallback and
HTEvent_setUnregisterCallback have been called with non NULL callbacks.
*/

extern BOOL HTEvent_isCallbacksRegistered(void);

/*
.
  Create and Delete Events
.
*/

extern HTEvent * HTEvent_new (HTEventCallback * cbf, void * context,
			      HTPriority pritority, int timeoutInMillis);
extern BOOL HTEvent_delete (HTEvent * event);

/*
(
  Event Timeouts, Priorities, Callbacks, and Contexts
)

Normally, these are set when creating the event.
*/

extern BOOL HTEvent_setParam(HTEvent * event, void * param);
extern BOOL HTEvent_setPriority(HTEvent * event, HTPriority priority);
extern BOOL HTEvent_setTimeout(HTEvent * event, int timeoutInMillis);
extern BOOL HTEvent_setCallback(HTEvent * event, HTEventCallback * cbf);

/*
.
  The Raw Event Type
.

Don't use this directly, use the methods above instead.
*/

struct _HTEvent {
    HTPriority		priority;	 /* Priority of this request (event) */
    int                 millis;              /* Timeout in ms for this event */
#ifdef IN_EVENT
    HTTimer *		timer;
#endif
    HTEventCallback *	cbf;			   /* Protocol state machine */
    void *		param;		       /* HTEvent_register parameter */
    HTRequest *		request;
};

/*

You can register the event manager provided together with libwww by using
the HTEventInit() in the HTInit module
*/

#endif /* HTEVENT_H */

/*

  

  @(#) $Id: HTEvent.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTEvtLst.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Default Event Manager


!
  Default Event Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module provides a default event registry and an eventloop which may
be used by an application if desired. See also the libwww timers defined
in the HTTimer module. An application may use
this module for:
	 
	   o 
	     Eventloop and registry - Application registers
    HTEvntrg_register and HTEvntrg_unregister and calls
    HTEventList_loop to dispatch events as they occur.
  o 
	     Event registry - Application just registers its own
    event handlers and chains them to
    HTEvntrg_register and HTEvntrg_unregister. When the
    application's eventloop gets activity on a socket, it calls
    HTEvent_dispatch to handle it.
  o 
	     Nothing - Application registers its own
    event handler uses its own eventloop
    to dispatch those events.

	 
This module is implemented by HTEvtLst.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTEVTLST_H
#define HTEVTLST_H

#include "wwwsys.h"
#include "HTEvent.h"
#include "HTReq.h"

/*
(
  Windows Specific Handles
)
*/

#if defined(WWW_WIN_ASYNC) || defined(WWW_WIN_DLL)
extern BOOL HTEventList_winHandle (HTRequest * request);
extern BOOL HTEventList_setWinHandle (HWND window, unsigned long message);
extern HWND HTEventList_getWinHandle (unsigned long * pMessage);
extern LRESULT CALLBACK AsyncWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif

/*
.
  Event Registry
.

The libwww event registry binds a socket and operation (FD_READ,
FD_WRITE, ...) to a callback function. Events are registered,
unregistered, and dispatched as they come in.
(
  Register an Event Handler
)

For a given socket, reqister a request structure, a set of operations, a
HTEventCallback function, and a priority. For this implementation, we allow
only a single HTEventCallback function for all operations. and the priority
field is ignored.
*/

extern HTEvent_registerCallback HTEventList_register;

/*
(
  Unregister an Event Handler
)

Remove the registered information for the specified socket for the actions
specified in ops. if no actions remain after the unregister, the registered
info is deleted, and, if the socket has been registered for notification,
the HTEventCallback will be invoked.
*/

extern HTEvent_unregisterCallback HTEventList_unregister;

/*
(
  Unregister ALL Event Handlers
)

Unregister all sockets. N.B. we just remove them for our internal data
structures: it is up to the application to actually close the socket.
*/

extern int HTEventList_unregisterAll (void);

/*
(
  Lookup and Dispatch Event Handlers
)

Callbacks can be looked up or dispatched based on the socket and operation
(read/write/oob)
*/

extern int HTEventList_dispatch (SOCKET s, HTEventType type, ms_t now);
extern HTEvent * HTEventList_lookup (SOCKET s, HTEventType type);

/*
.
  Libwww Default EventLoop
.

The libwww default eventloop dispatches events to the event
registry.
(
  Start and Stop the Event Manager
)
*/

extern BOOL HTEventInit (void);
extern BOOL HTEventTerminate (void);

/*
(
  Start the Eventloop
)

That is, we wait for activity from one of our registered channels, and dispatch
on that. Under Windows/NT, we must treat the console and sockets as distinct.
That means we can't avoid a busy wait, but we do our best.
*/

extern int HTEventList_newLoop (void);

/*

The next version is an old version of the eventloop start. The request is
not used for anything and can be NULL.
*/

extern int HTEventList_loop (HTRequest * request);

/*
(
  Stop the Eventloop
)

Stops the (select based) eventloop immediately. The function does not guarantee
that all requests have terminated so it is important that the application
does this before this function is called. This can be done using the
HTNet_isIdle() function in the HTNet Module
*/

extern void HTEventList_stopLoop (void);

/*
*/

#endif /* HTEVTLST_H */

/*

  

  @(#) $Id: HTEvtLst.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HText.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Rich Hypertext Object


!
  HyperText Object Builder
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the interface that &nbsp;you can use to build a parsed HTML object
(called an hypertext object) as output of the libwww
HTML parser. It is based on callback functions that the application can
register as needed in order to get the various events out of the HTML parser.
These are the different events that can be registered:

	 
	   o 
	     When parsing is about to start or terminate
  o 
	     When a chunk of plain text has been found
  o 
	     When a link has been found in some HTML element
  o 
	     When an HTML element is about to start or end
  o 
	     Handler for unparsed elements
  o 
	     Handler for unparsed entities

	 
Building an hypertext object can contain references to stylesheets. Libwww
doesn't come with a stylesheet implementation but it does have a
generic stylesheet manager which can be used for
registering and looking up styles. As an example, you can see how the libwww
robot uses the link callout whereas
the Line Mode Browser has a complete
implementation in the 
GridText module.
*/

#ifndef HTEXT_H
#define HTEXT_H

#include "HTAnchor.h"
#include "HTStream.h"

/*
.
  The HText Object
.

The HText object is only known as a name to libwww - it isn't defined
or used anywhere as an actual structure. The application can use the HText
object to contain the information needed to build a parsed object - a hypertext
object - as data arrives from the libwww HTML parser.
When a HText object is to be created, this module calls out to any registered
creation method and in turn uses the newly created HText object in every
subsequent call to any registered callback routine as the HTML stream is
parsed.
*/

typedef struct _HText HText;

/*
.
  Callback for Creating and Deleting an HText Object
.

When an HTML stream is created, the
HTML parser checks to see if there are any callbacks
registered for handling the HText object. If this is
the case then the creation callback is called so that the application can
create a new HText object. After that the various callbacks
are called (if registered) as text comes in and
gets parsed.
*/

typedef HText * HText_new (
	HTRequest *		request,
	HTParentAnchor *	anchor,
	HTStream *		output_stream);

typedef BOOL HText_delete (HText * me);

/*
(
  Register Creation/Deletion Callbacks
)
*/

extern BOOL HText_registerCDCallback (HText_new *, HText_delete *);
extern BOOL HText_unregisterCDCallback (void);

/*
.
  Callback for Start and Terminate Parsing
.

The call sequence is the following: First HText_build is called
with the status of HTEXT_BEGIN, then any combination of other append
calls, and at the end HText_build is called with the termination
status - if it terminated normally then the status is HTEXT_END,
if the download was aborted the status is HTEXT_ABORT.
*/

typedef enum _HTextStatus {
    HTEXT_BEGIN,
    HTEXT_END,
    HTEXT_ABORT
} HTextStatus;

typedef void HText_build (HText * text, HTextStatus status);

/*
(
  Register Start/End Callback
)
*/

extern BOOL HText_registerBuildCallback (HText_build *);
extern BOOL HText_unregisterBuildCallback (void);

/*
.
  Callback for Handling Chunks of Text
.

THE STRING IS NOT ZERO-TERMINATED!!! When plain text is
found then it can be passed to the application via this function. HTML text
is already stripped for unneeded white space whereas literal text isn't.
The text is of course to be taken "relative" to which element is is found
within - this is not checked by the HTML parser but can be checked by the
application by using the Element callback function.
*/

typedef void HText_addText (
	HText * 	text,
	const char * 	buffer,
	int		length);

/*
(
  Register Text Callback
)
*/

extern BOOL HText_registerTextCallback (HText_addText *);
extern BOOL HText_unregisterTextCallback (void);

/*
.
  Callback for Handling Hypertext Links
.

Whenever a link is found in the HTML stream, be it from an anchor element,
an inlined image, etc. then it is picked up and this called out to this function
with the parameters necessary to be able to see what type of link it is (the
element and the name of the attribute where it was found). The element number
and attribute number are integers that are defined by the
HTML DTD used by the HTMl parser. The
present and value arrays contains all the
SGML attributes and values found in the element
untouched. Again, the array is defined by the HTML
DTD used by the HTML parser.
*/

typedef void HText_foundLink (
	HText * 	text,
	int		element_number,
	int		attribute_number,
	HTChildAnchor *	anchor,
	const BOOL *	present,
	const char **	value);

/*
(
  Register Link Callback
)
*/

extern BOOL HText_registerLinkCallback (HText_foundLink *);
extern BOOL HText_unregisterLinkCallback (void);

/*
.
  Callback for Handling HTML Elements
.

Whenever an element is found in the HTML stream, be it an IMG element, a
BODY element, etc. then it is picked up and this called out to this function
with the parameters necessary to be able to see what type of element it is.
The element number and attribute number are integers that are defined by
the HTML DTD used by the HTMl parser. The
present and value arrays contains all the
SGML attributes and values found in the element
untouched. Again, the array is defined by the HTML
DTD used by the HTML parser.
*/

typedef void HText_beginElement (
	HText * 	text,
	int		element_number,
	const BOOL *	present,
	const char **	value);

typedef void HText_endElement (
	HText * 	text,
	int		element_number);

/*
(
  Register HTML Element Callback
)
*/

extern BOOL HText_registerElementCallback (HText_beginElement *, HText_endElement *);
extern BOOL HText_unregisterElementCallback (void);

/*
.
  Callback for Unparsed Elements
.

Whenever an element is found which is not known by the HTML DTD, then the
information is passed to the unparsed element handlers.
*/

typedef void HText_unparsedBeginElement (
	HText *		HText,
	const char * 	buffer,
	int		length);

typedef void HText_unparsedEndElement (
	HText *		HText,
	const char * 	buffer,
	int		length);

/*
(
  Register Unparsed Element Callback
)
*/

extern BOOL HText_registerUnparsedElementCallback (
	HText_unparsedBeginElement *,
	HText_unparsedEndElement *);
extern BOOL HText_unregisterUnparsedElementCallback (void);

/*
.
  Callback for Unparsed Entity
.

Whenever an entity is found which is not known by the HTML DTD, then the
information is passed to the default handler.
*/

typedef void HText_unparsedEntity (
	HText *		HText,
	const char * 	buffer,
	int		length);

/*
(
  Register Unparsed Entity Callback
)
*/

extern BOOL HText_registerUnparsedEntityCallback (HText_unparsedEntity *);
extern BOOL HText_unregisterUnparsedEntityCallback (void);

/*
*/

#endif /* HTEXT_H */

/*

  

  @(#) $Id: HText.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTextImp.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Internal Hypertext Object


!
  Internal implementation of Hypertext Object Builder
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

*/

#ifndef HTEXTIMP_H
#define HTEXTIMP_H

#include "HTReq.h"
#include "HTAnchor.h"
#include "HText.h"

/*
*/

typedef struct _HTextImp HTextImp;

extern HTextImp * HTextImp_new (
	HTRequest *	request,
	HTParentAnchor *anchor,
	HTStream *	output_stream);

extern BOOL HTextImp_delete (
	HTextImp *	me);

extern void HTextImp_build (
	HTextImp *	text,
	HTextStatus	status);

extern void HTextImp_addText (
	HTextImp * 	me,
	const char * 	buffer,
	int 		length);

extern void HTextImp_foundLink (
	HTextImp * 	me,
	int 		element_number,
	int 		attribute_number,
	HTChildAnchor *	anchor,
	const BOOL *	present,
	const char **	value);

extern void HTextImp_beginElement (
	HTextImp * 	me,
	int		element_number,
	const BOOL *	present,
	const char **	value);

extern void HTextImp_endElement (
	HTextImp * 	me,
	int		element_number);

extern void HTextImp_unparsedBeginElement (
	HTextImp * 	me,
	const char * 	buffer,
	int 		length);

extern void HTextImp_unparsedEndElement (
	HTextImp * 	me,
	const char * 	buffer,
	int 		length);

extern void HTextImp_unparsedEntity (
	HTextImp * 	me,
	const char * 	buffer,
	int 		length);

/*
*/

#endif /* HTEXTIMP_H */

/*

  

  @(#) $Id: HTextImp.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTFile.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library libwww Local File Access


!
  Local File Access
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

These are routines for local file access used by WWW browsers and servers.

This module is implemented by HTFile.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTFILE_H
#define HTFILE_H

#include "HTProt.h"

extern HTProtCallback HTLoadFile;

/*
.
  Directory Access
.

You can define the directory access for file URLs by using the following
function.
*/

typedef enum _HTDirAccess {
    HT_DIR_FORBID,			/* Altogether forbidden */
    HT_DIR_SELECTIVE,			/* Only if "selfile" exists */
    HT_DIR_OK				/* Directory reading always OK */
} HTDirAccess;

#define DEFAULT_DIR_FILE	".www_browsable"    /* If exists, can browse */

extern HTDirAccess  HTFile_dirAccess	(void);
extern BOOL HTFile_setDirAccess		(HTDirAccess mode);

/*
.
  Readme Files
.

You can specify the module to look for a README file and to put into a directory
listing. These are the possibilities:
*/

typedef enum _HTDirReadme {
    HT_DIR_README_NONE,
    HT_DIR_README_TOP,
    HT_DIR_README_BOTTOM
} HTDirReadme;

#define DEFAULT_README		"README"

extern HTDirReadme  HTFile_dirReadme	(void);
extern BOOL HTFile_setDirReadme		(HTDirReadme mode);

/*
.
  Should we do Automatic File Suffix Binding?
.

By default, libwww uses the file suffix bindings
to figure out the media type, natural language, charset, content encoding,
etc and assign the values to the anchor of the local file.

However, in some situations, the application can either already have done
this or isn't interested in using the libwww bindings. You can control whether
libwww should do thi or not using the following methods:
*/

extern BOOL HTFile_doFileSuffixBinding (BOOL mode);
extern BOOL HTFile_fileSuffixBinding (void);

/*
*/

#endif /* HTFILE_H */

/*

  

  @(#) $Id: HTFile.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTFilter.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww BEFORE and AFTER Filters


!
  Standard BEFORE and AFTER Filters
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module provides a set of default BEFORE and AFTER filters
that can be registered by the Net manager to be
called before and after a request. All filters can be registered either to
be called globally (all requests) or locally (pr request basis).

This module is implemented by HTFilter.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTFILTER_H
#define HTFILTER_H
#include "WWWLib.h"

/*
.
  BEFORE Filters
.

This is a standard set of BEFORE filters which the application may
initialize. This can be done in an easy way using the function
HTBeforeInit() in the Initialization
interface.
(
  Proxy and Gateway BEFORE filter
)

Checks for registerd proxy servers or gateways and sees whether this request
should be redirected to a proxy or a gateway. Proxies have higher priority
than gateways so we look for them first! For HTTP/1.0 and HTTP/1.1 we may
only send a full URL (including the host portion) to proxy servers. Therefore,
we tell the Library whether to use the full URL or the traditional HTTP one
without the host part.
*/

extern HTNetBefore HTProxyFilter;

/*
(
  Rule Translation BEFORE Filter
)

If we have a set of rules loaded (see the Rule manager) then check before
each request whether how that should be translated. The trick is that a parent
anchor has a "address" which is the part from the URL we used when we created
the anchor. However, it also have a "physical address" which is the place
we are actually going to look for the resource. Hence this filter translates
from the address to the physical address (if any translations are found)
*/

extern HTNetBefore HTRuleFilter;

/*
(
  Memory Cache (History List) Validation BEFORE Filter
)

Check if document is already loaded. The user can define whether the history
list should follow normal expiration or work as a traditional history list
where expired documents are not updated. We don't check for anything but
existence proof of a document associated with the anchor as the definition
is left to the application.
*/

extern HTNetBefore HTMemoryCacheFilter;

/*
(
  Client side authentication BEFORE filter
)

The filter generates the credentials required to access a document Getting
the credentials may involve asking the user in which case we use the methods
registered by the HTAlert module
*/
    
extern HTNetBefore HTCredentialsFilter;

/*
.
  AFTER Filters
.

Like BEFORE filters we provide a default set of typical AFTER
filters that may be initialized by the application. Again, an easy way of
doing this is to call the HTAfterInit() function in the
Initialization interface.
(
  Error and Information filter
)

It checks the status code from a request and generates an error/information
message if required.
*/

extern HTNetAfter HTInfoFilter;

/*
(
  Redirection filter
)

The redirection handler only handles automatic redirections on the GET
or HEAD method (or any other safe method). The users is asked for
all other methods.
*/

extern HTNetAfter HTRedirectFilter;

/*
(
  Proxy Redirection filter
)

This filter handles a "305 Use Proxy" response and retries the
request through the proxy
*/

extern HTNetAfter HTUseProxyFilter;

/*
(
  Client side authentication filter
)

The client side authentication filter uses the user dialog messages registered
in the HTAlert module. By default these are the
ones used by the line mode browser but you can just register something else.
*/

extern HTNetAfter HTAuthFilter;

/*
(
  Client side authentication information filter
)

This filter updates the client's local authentication information database 
with new information sent by the server via the authentication-info header.
This header is currently used only by the Digest authentication scheme.
This filter is initialized by default, but you can just register something
else.
*/

extern HTNetAfter HTAuthInfoFilter;

/*
(
  Request Common Log File Filter
)

Default Logging filter using the log manager provided by the
Log Manager.
*/

extern HTNetAfter HTLogFilter;

/*

(
  Request Referer Log File Filter
)

Default Referer Log filter using the log manager provided by the
Log Manager.
*/

extern HTNetAfter HTRefererFilter;

/*

*/

#endif /* HTFILTER_H */

/*

  

  @(#) $Id: HTFilter.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTFormat.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Stream Pipe Manager


!
  The Stream Pipe Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Stream Pipe Manager is responsible for setting up the stream pipe from
the Channel Object to the
Request Object when data is arriving, for example
as a response to s HTTP Get request. As data
arrives, we start to parse it and the more we know the more we can build
up our stream pipe. For example, in the case of HTTP, we first have a stream
that can parse the HTTP response line containing "200 OK". Then
we have a MIME parser for handling the MIME headers.
When the MIME headers have been parsed, we know the content type and any
encoding of the MIME body. If we need to decode a chunked encoding then we
set up a chunked decoder, and if we have to parse a HTML object then we set
up a HTML parser.

The Format Manager is also responsible for keeping track of the
"preferences" of the application and/or user. It is an integral part
of the Web and HTTP, that the client application can express its preferences
as a set of "accept" headers in a HTTP request. This task is highly related
to the task mentioned above as we there use the modules that are registered
and here tell the remote server what we are capable of doing and what we
would prefer.

Note: The library core does not define any default decoders
or parsers - they are all considered part of the application. The library
comes with a default set of parsers including the ones mentioned above which
can be initiated using the functions in HTInit
module. There are different initialization functions for content type
parsers and content encodings respectively.

	 
	   o 
	     Content Type Converters and Presenters
  o 
	     Content Encoders and Decoders
  o 
	     Content Charsets
  o 
	     Natural Languages

	 
The application can assign its preferences in two ways: either locally
to a single request or globally to all requests. The local assignment
can either add to or override the global settings depending
on how they are registered. All local registration is handled by the
Request Object and the global registration is handled
by the Format Manager.

This module is implemented by HTFormat.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTFORMAT_H
#define HTFORMAT_H

#include "HTUtils.h"
#include "HTStream.h"
#include "HTAtom.h"
#include "HTList.h"
#include "HTAnchor.h"
#include "HTReq.h"

/*
.
  Converters and Presenters
.

All content type converters are subclassed from the Generic stream objetc.
That way, we allow the application to do very fast progressive display of
incoming data. In other words, the stream model of the Library provides data
as soon as it arrives from the network, the application does not have to
wait until the whole document has been down loaded before it starts parsing
it.
(
  Predefined Content Types
)

These macros (which used to be constants) define some basic internally referenced
representations. The www/xxx ones are of course not MIME standard.
They are internal representations used in the Library but they can't be exported
to other apps!
*/

#define WWW_INTERNAL	HTAtom_for("www/*")          /* All internal formats */

/*

WWW_INTERNAL represent all internal formats. This can for example
be used to match using the HTMIMEMatch(...).
*/

#define WWW_RAW		HTAtom_for("www/void")   /* Raw output from Protocol */

/*

WWW_RAW is an output format which leaves the input untouched
exactly as it is received by the protocol module. For example, in
the case of FTP, this format returns raw ASCII objects for directory listings;
for HTTP, everything including the header is returned, for Gopher, a raw
ASCII object is returned for a menu etc.
*/

#define WWW_SOURCE	HTAtom_for("*/*")

/*

WWW_SOURCE is an output format which leaves the input untouched
exactly as it is received by the protocol module IF not a
suitable converter has been registered with a quality factor higher than
1 (for example 2). In this case the SUPER CONVERTER is preferred
for the raw output. This can be used as a filter effect that allows conversion
from, for example raw FTPdirectory listings into HTML but passes a MIME body
untouched.
*/

#define WWW_PRESENT	HTAtom_for("www/present")

/*

WWW_PRESENT represents the user's perception of the document.
If you convert to WWW_PRESENT, you present the material to the
user.
*/

#define WWW_DEBUG	HTAtom_for("www/debug")

/*

WWW_DEBUG represents the user's perception of debug information,
for example sent as a HTML document in a HTTP redirection message.
*/

#define WWW_UNKNOWN     HTAtom_for("www/unknown")

/*

WWW_UNKNOWN is a really unknown type. It differs from the real
MIME type "application/octet-stream" in that we haven't even tried
to figure out the content type at this point.
*/

#define WWW_CACHE         HTAtom_for("www/cache")
#define WWW_CACHE_APPEND  HTAtom_for("www/cache-append")

/*

WWW_CACHE is the internal content-type designated for a persistent
cache module which can store the object to local storage. The cache append
format is special in that we append information to an already existing cache
entry. This can happen if we have issued a If-Range request
and got back a "206 Partial response".

These are regular MIME types defined. Others can be added!
*/

#define WWW_HTML 	HTAtom_for("text/html")
#define WWW_PLAINTEXT 	HTAtom_for("text/plain")
#define WWW_FORM	HTAtom_for("application/x-www-form-urlencoded")

#define WWW_MIME	HTAtom_for("message/rfc822")
#define WWW_MIME_HEAD	HTAtom_for("message/x-rfc822-head")
#define WWW_MIME_FOOT	HTAtom_for("message/x-rfc822-foot")
#define WWW_MIME_PART   HTAtom_for("message/x-rfc822-partial")
#define WWW_MIME_CONT   HTAtom_for("message/x-rfc822-cont")
#define WWW_MIME_UPGRADE	HTAtom_for("message/x-rfc822-upgrade")

#define WWW_MIME_COPYHEADERS HTAtom_for("www/x-rfc822-headers")

#define WWW_AUDIO       HTAtom_for("audio/basic")

#define WWW_VIDEO 	HTAtom_for("video/mpeg")

#define WWW_GIF 	HTAtom_for("image/gif")
#define WWW_JPEG 	HTAtom_for("image/jpeg")
#define WWW_TIFF 	HTAtom_for("image/tiff")
#define WWW_PNG 	HTAtom_for("image/png")

#define WWW_BINARY 	HTAtom_for("application/octet-stream")
#define WWW_POSTSCRIPT 	HTAtom_for("application/postscript")
#define WWW_RICHTEXT 	HTAtom_for("application/rtf")

/*

We also have some MIME types that come from the various protocols when we
convert from ASCII to HTML.
*/

#define WWW_GOPHER_MENU HTAtom_for("text/x-gopher")
#define WWW_CSO_SEARCH	HTAtom_for("text/x-cso")

#define WWW_FTP_LNST	HTAtom_for("text/x-ftp-lnst")
#define WWW_FTP_LIST	HTAtom_for("text/x-ftp-list")

#define WWW_NNTP_LIST   HTAtom_for("text/x-nntp-list")
#define WWW_NNTP_OVER	HTAtom_for("text/x-nntp-over")
#define WWW_NNTP_HEAD	HTAtom_for("text/x-nntp-head")

#define WWW_HTTP	HTAtom_for("text/x-http")

/*

Finally we have defined a special format for our RULE files as they can be
handled by a special converter.
*/
#define WWW_RULES	HTAtom_for("application/x-www-rules")

/*
(
  The Quality Factor
)

Characteristic for all preferences is that there is a quality factor associated
with each member. The quality factor is a real number between 0 and 1 with
0 meaning "very bad" and 1 means "perfect". By registering a natural language
or any or other preference in this group together with a quality factor you
can specify "how well the preference is handled" either by the application
or by the user. In the case of the user the quality factor of a natural language
is how well the user understands the language. In my case, the quality factors
for, for example Greek would be close to zero and 1 for Danish (nothing bad
said about Greek!).

It is a bit different for converters where it is often the application's
ability of handling the data format rather than the user's perception. As
an example it is often faster to use a converter than a presenter as it takes
time to launch the external application and libwww can not use progressive
display mechanisms which is often the case for converters. Therefore, as
an example, if we capable of handling an image in png format inline
but rely on an external viewer for presenting postscript, we might set up
the following list:

HTConversion_add (converters, "image", "www/present", GifPresenter,
1.0, 0.0, 0.0);
HTPresentation_add (presenters, "application/postscript", "ghostview %s",
NULL, 0.5, 0.0, 0.0);>

where the gif converter is registered with a quality factor of 1.0
and the postscript presenter with a quality factor of 0.5.Register
Presenters
(
  The Converter Class
)

A converter is a stream with a special set of parameters and
which is registered as capable of converting from a MIME type to something
else (maybe another MIME-type). A converter is defined to be a function returning
a stream and accepting the following parameters. The content type elements
are atoms for which we have defined a prototype.
*/

typedef HTStream * HTConverter	(HTRequest *	request,
				 void *		param,
				 HTFormat	input_format,
				 HTFormat	output_format,
				 HTStream *	output_stream);

extern void HTConversion_add   (HTList *	conversions,
				const char * 	rep_in,
				const char * 	rep_out,
				HTConverter *	converter,
				double		quality,
				double		secs, 
				double		secs_per_byte);

extern void HTConversion_deleteAll	(HTList * list);

/*
(
  The Presenter Class
)

A presenter is a module (possibly an external program) which
can present a graphic object of a certain MIME type to the user. That is,
presenters are normally used to present objects that the
converters are not able to handle. Data is transferred to the
external program using a special "presenter stream" which for example can
use the local disk to transfer the data from libwww to the external program.

Libwww provides a default HTSaveAndExecute
stream which you may want to use for this purpose. However, any stream
that is of type HTConverter will do. You can manage the
special presenter stream using the following methods:
*/

extern void HTPresentation_setConverter (HTConverter * pconv);
extern HTConverter * HTPresentation_converter (void);

/*
Both presenters and converters are of the type
HTConverter.
*/

extern void HTPresentation_add (HTList *	conversions,
				const char * 	representation,
				const char * 	command,
				const char * 	test_command,
				double		quality,
				double		secs, 
				double		secs_per_byte);

extern void HTPresentation_deleteAll	(HTList * list);

/*
(
  Basic Converters
)

We have a small set of basic converters that can be hooked in anywhere. They
don't "convert" anything but are nice to have.
*/

extern HTConverter HTThroughLine;
extern HTConverter HTBlackHoleConverter;
extern HTConverter HTSaveConverter;

/*
.
  Content and Transfer Encoders and Decoders
.

Content codins are transformations applied to an entity object after it was
created in its original form. The Library handles two types of codings:

  
    Content Codings
  
    Content codings values indicate an encoding transformation that has been
    applied to a resource. Content cosings are primarily used to allow a document
    to be compressed or encrypted without loosing the identity of its underlying
    media type.
  
    Content Transfer Codings
  
    Content transfer codings values are used to indicate an encoding transformation
    that has been, can be, or may be need to be applied to an enity body in order
    to ensure safe transport through the network. This differs from a content
    coding in that the transfer coding is a property of the message, not the
    original message.


Both types of encodings use the same registration mechanism in the Library
which we describe below:
(
  Encoders and Decoders
)

Encoders and decoders are subclassed from the
generic stream class. Encoders are capable
of adding a content coding to a data object and decoders can remove
a content coding.
*/

typedef HTStream * HTCoder	(HTRequest *	request,
				 void *		param,
				 HTEncoding	coding,
				 HTStream *	target);

/*

The encoding is the name of the encoding mechanism reporesented
as an atom, for example "zip", "chunked", etc.
Encodings are registered in lists and content encodings are separated from
transfer encodings by registering them in different lists.
(
  Basic Encoders
)

We have a small set of basic coders that can be hooked in anywhere.
*/

extern HTCoder HTIdentityCoding;

/*
(
  The HTCoding Object
)

The HTCoding object represents a registered encoding together with
a encoder and a decoder.
*/

typedef struct _HTCoding HTCoding;

/*

Predefined Coding Types We have a set of pre defined atoms for various types
of content encodings and transfer encodings. "chunked" is not exactly in
the same group as the other encodings such as "binary" but it really doesn't
make any difference as it is just a matter of how the words are chosen. The
first three transfer encodings are actually not encodings - they are just
left overs from brain dead mail systems.
*/

#define WWW_CODING_7BIT		HTAtom_for("7bit")
#define WWW_CODING_8BIT		HTAtom_for("8bit")
#define WWW_CODING_BINARY	HTAtom_for("binary")
#define WWW_CODING_IDENTITY     HTAtom_for("identity")

#define WWW_CODING_BASE64	HTAtom_for("base64")
#define WWW_CODING_MACBINHEX	HTAtom_for("macbinhex")
#define WWW_CODING_CHUNKED	HTAtom_for("chunked")

#define WWW_CODING_COMPRESS	HTAtom_for("compress")
#define WWW_CODING_GZIP	        HTAtom_for("gzip")
#define WWW_CODING_DEFLATE      HTAtom_for("deflate")

/*
(
  Register Content Coders
)

Some documents are not send in their original data obejct but is encoded
in some way. On the Web this is mostly some kind of compression but other
encodings for example base 64 can be encountered when talking to NNTP servers
etc. Just as for the other preferences, an application can register a supported
encoders or decodes as a list. Encoders and decoders are registered in the
same way with no differentiation whether it is a encoder or a decoder:
*/

extern BOOL HTCoding_add (HTList * 	list,
			 const char *	encoding,
			 HTCoder *	encoder,
			 HTCoder *	decoder,
			 double		quality);

extern void HTCoding_deleteAll (HTList * list);

extern const char * HTCoding_name (HTCoding * me);

extern double HTCoding_quality (HTCoding * me);

/*
.
  Content Charsets
.

As the Web reaches all parts of the Internet there are more and more documents
written in languages which contains characters not included in the ISO-8859-1
character set. A consequence of this the set of characters sets is often
tightly connected with the natural language. libwww does not directly support
other character sets but in case an application is capable of handling
alternative sets it can register these as preferred character sets along
with a quality factor just as all the other preferences in this section.
*/
extern void HTCharset_add (HTList * list, const char * charset, double quality);

/*
*/
typedef struct _HTAcceptNode {
    HTAtom *	atom;
    double	quality;
} HTAcceptNode;

/*
*/

extern void HTCharset_deleteAll	(HTList * list);

/*
.
  Content Languages
.

The preferred natural language or languages is in almost all situations dependent
on the individual user and an application should therefore give the user
the opportunity to change the setup. When specifying a natural language
preference, libwww will send this preference along with all HTTP requests.
The remote server will then (it if supports this feature) look for a version
in the language or languages mentioned. If it finds a matching document then
it returns this one, otherwise it uses the best alternative. If no language
is specified the remote server may whatever version it finds.
*/
extern void HTLanguage_add (HTList * list, const char * lang, double quality);
extern void HTLanguage_deleteAll (HTList * list);

/*
.
  Global Preferences
.

There are two places where these preferences can be registered: in a
global list valid for all requests and a local list
valid for a particular request only. These are valid for all requests.
See the Request Manager fro local sets.
(
  Global Converters and Presenters
)

The global list of specific conversions which the format manager
can do in order to fulfill the request. There is also a
local list of conversions which contains
a generic set of possible conversions.
*/
extern void HTFormat_setConversion	(HTList * list);
extern HTList * HTFormat_conversion	(void);

extern void HTFormat_addConversion (const char *	input_format,
				    const char *	output_format,
				    HTConverter *	converter,
				    double		quality,
				    double		secs, 
				    double		secs_per_byte);

/*
(
  Global Content Codings
)
*/
extern void HTFormat_setContentCoding	(HTList * list);
extern HTList * HTFormat_contentCoding	(void);

extern BOOL HTFormat_addCoding ( char *		encoding,
				 HTCoder *	encoder,
				 HTCoder *	decoder,
				 double		quality);

/*

We also define a macro to find out whether a content encoding is really an
encoding or whether it is a unity encoder.
*/

#define HTFormat_isUnityContent(me) \
	((me)==NULL || \
	(me)==WWW_CODING_BINARY || (me)==WWW_CODING_IDENTITY || \
        (me)==WWW_CODING_7BIT || (me)==WWW_CODING_8BIT)

/*
(
  Global Transfer Codings
)
*/
extern void HTFormat_setTransferCoding	(HTList * list);
extern HTList * HTFormat_transferCoding	(void);

extern BOOL HTFormat_addTransferCoding ( char *		encoding,
					 HTCoder *	encoder,
					 HTCoder *	decoder,
					 double		quality);

/*

We also define a macro to find out whether a transfer encoding is really
an encoding or whether it is just a "dummy" as for example 7bit, 8bit, and
binary.
*/

#define HTFormat_isUnityTransfer(me) \
	((me)==NULL || \
	 (me)==WWW_CODING_BINARY || (me)==WWW_CODING_IDENTITY || \
         (me)==WWW_CODING_7BIT || (me)==WWW_CODING_8BIT)

/*
(
  Global Content Languages
)
*/
extern void HTFormat_setLanguage	(HTList * list);
extern HTList * HTFormat_language	(void);

/*
(
  Global Content Charsets
)
*/
extern void HTFormat_setCharset		(HTList * list);
extern HTList * HTFormat_charset	(void);

/*
(
  Delete All Global Lists
)

This is a convenience function that might make life easier.
*/
extern void HTFormat_deleteAll (void);

/*
.
  The Content Type Stream Stack
.

This is the routine which actually sets up the content type conversion. It
currently checks only for direct conversions, but multi-stage conversions
are forseen. It takes a stream into which the output should be sent in the
final format, builds the conversion stack, and returns a stream into which
the data in the input format should be fed. If guess is true
and input format is www/unknown, try to guess the format by
looking at the first few bytes of the stream.
*/

extern HTStream * HTStreamStack (HTFormat	rep_in,
				 HTFormat	rep_out,
				 HTStream *	output_stream,
				 HTRequest *	request,
				 BOOL		guess);

/*
(
  Cost of a Stream Stack
)

Must return the cost of the same stack which HTStreamStack would set up.
*/

extern double HTStackValue	(HTList *	conversions,
				 HTFormat	format_in,
				 HTFormat	format_out,
				 double		initial_value,
				 long int	length);

/*
.
  Content Encoding Stream Stack
.

When creating a coding stream stack, it is important that we keep the right
order of encoders and decoders. As an example, the HTTP spec specifies that
the list in the Content-Encoding header follows the order in which
the encodings have been applied to the object. Internally, we represent the
content encodings as atoms in a linked
list object.

The creation of the content coding stack is not based on quality factors
as we don't have the freedom as with content types. When using content codings
we must apply the codings specified or fail.
*/

extern HTStream * HTContentCodingStack (HTEncoding	coding,
					HTStream *	target,
					HTRequest *	request,
					void *		param,
					BOOL		encoding);

/*

Here you can provide a complete list instead of a single token. The list
has to be filled up in the order the _encodings_ are to be applied
*/

extern HTStream * HTContentEncodingStack (HTList *	encodings,
					  HTStream *	target,
					  HTRequest *	request,
					  void *	param);

/*

Here you can provide a complete list instead of a single token. The list
has to be in the order the _encodings_ were applied - that is, the same way
that _encodings_ are to be applied. This is all consistent with the order
of the Content-Encoding header.
*/

extern HTStream * HTContentDecodingStack (HTList *	encodings,
					  HTStream *	target,
					  HTRequest *	request,
					  void *	param);

/*
.
  Transfer Encoding Stream Stack
.

When creating a coding stream stack, it is important that we keep the right
order of encoders and decoders. As an example, the HTTP spec specifies that
the list in the Transfer-Encoding header follows the order in which
the encodings have been applied to the object. Internally, we represent the
content encodings as atoms in a linked
list object.

The creation of the content coding stack is not based on quality factors
as we don't have the freedom as with content types. When using content codings
we must apply the codings specified or fail.
*/

extern HTStream * HTTransferCodingStack (HTEncoding	coding,
					 HTStream *	target,
					 HTRequest *	request,
					 void *		param,
					 BOOL		encoding);

/*

Here you can provide a complete list instead of a single token. The list
has to be filled up in the order the _encodings_ are to be applied
*/

extern HTStream * HTTransferEncodingStack (HTList *	encodings,
					   HTStream *	target,
					   HTRequest *	request,
					   void *	param);

/*

Here you can provide a complete list instead of a single token. The list
has to be in the order the _encodings_ were applied - that is, the same way
that _encodings_ are to be applied. This is all consistent with the order
of the Transfer-Encoding header.
*/

extern HTStream * HTTransferDecodingStack (HTList *	encodings,
					  HTStream *	target,
					  HTRequest *	request,
					  void *	param);

/*
.
  Transfer Encoding Stream Stack
.

Creating the transfer content encoding stream stack is not based on quality
factors as we don't have the freedom as with content types. Specify whether
you you want encoding or decoding using the BOOL "encode" flag.
*/

extern HTStream * HTContentTransferCodingStack (HTEncoding	encoding,
					        HTStream *	target,
					        HTRequest *	request,
					        void *		param,
					        BOOL		encode);

/*
(
  Presentation Object
)

This object is not to be used - it should have been hidden&nbsp;
*/
typedef struct _HTPresentation {
    HTFormat	rep;			     /* representation name atomized */
    HTFormat	rep_out;			 /* resulting representation */
    HTConverter *converter;	      /* The routine to gen the stream stack */
    char *	command;			       /* MIME-format string */
    char *	test_command;			       /* MIME-format string */
    double	quality;		     /* Between 0 (bad) and 1 (good) */
    double	secs;
    double	secs_per_byte;
} HTPresentation;

/*
*/

#endif /* HTFORMAT */

/*

  

  @(#) $Id: HTFormat.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTFSave.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww ANSI C File Streams


!
  Basic ANSI C File Writer Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module contains some local file writer streams based on the basic file
writer stream defined in the HTFWrite module.
They can be used to do save-as, save-and-callback etc.

This module is implemented by HTFSave.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTFSAVE_H
#define HTFSAVE_H

#include "HTFWrite.h"

/*
.
  Various Converters using the File Writer Stream
.

This is a set of functions that can be registered as converters. They all
use the basic ANSI C file writer stream for writing out to the local file
system.
*/

extern HTConverter HTSaveAndExecute, HTSaveLocally, HTSaveAndCallback;

/*


  
    HTSaveLocally
  
    Saves a file to local disk. This can for example be used to dump date objects
    of unknown media types to local disk. The stream prompts for a file name
    for the temporary file.
  
    HTSaveAndExecute
  
    Creates temporary file, writes to it and then executes system command (maybe
    an external viewer) when EOF has been reached. The stream finds
    a suitable name of the temporary file which preserves the suffix. This way,
    the system command can find out the file type from the name of the temporary
    file name.
  
    HTSaveAndCallback
  
    This stream works exactly like the HTSaveAndExecute stream but
    in addition when EOF has been reached, it checks whether a callback
    function has been associated with the request object in which case, this
    callback is being called. This can be use by the application to do some
    processing after the system command has terminated. The callback
    function is called with the file name of the temporary file as parameter.

*/

#endif

/*

  

  @(#) $Id: HTFSave.html,v 1.1.1.1 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTFTPDir.h
::::::::::::::
/*

					W3C Sample Code Library libwww FTP DIRECTORY LISTING




!FTP Directory Listings!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module converts a FTP directory listing to a HTML object

This module is implemented by HTFTPDir.c, and it is
a part of the W3C
Sample Code Library.

*/

#ifndef HTFTPDIR_H
#define HTFTPDIR_H

#include "HTStream.h"
#include "HTFTP.h"

extern HTStream * HTFTPDir_new (HTRequest *	request,
				FTPServerType	server,
				char		list);
#endif


/*



@(#) $Id: HTFTPDir.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTFTP.h
::::::::::::::
/*

					W3C Sample Code Library libwww FTP CLIENT





!FTP access functions!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the FTP load module that handles all communication with
FTP-servers. 

This module is implemented by HTFTP.c, and it is
a part of the W3C
Sample Code Library.

*/

#ifndef HTFTP_H
#define HTFTP_H
#include "HTProt.h"

extern HTProtCallback HTLoadFTP;

typedef enum _FTPServerType {
    FTP_GENERIC 	= 0x1,
    FTP_MACHTEN		= 0x2,
    FTP_UNIX		= 0x4,
    FTP_VMS		= 0x8,
    FTP_CMS		= 0x10,
    FTP_DCTS		= 0x20,
    FTP_TCPC		= 0x40,
    FTP_PETER_LEWIS	= 0x80,
    FTP_NCSA		= 0x200,
    FTP_WINNT		= 0x400,
    FTP_UNSURE		= 0x8000
} FTPServerType;

#define MAX_FTP_LINE	128			 /* Don't use more than this */

/*

.
  Global Transfer Mode
.

Can be used to set the default transfer mode overruling what may be
indicated in the FTP URL.
Added by Neil Griffin, GAIN Software

*/

typedef enum _FTPTransferMode {
    FTP_DEFAULT_TRANSFER_MODE   = 0,
    FTP_ASCII_TRANSFER_MODE     = 1,
    FTP_BINARY_TRANSFER_MODE    = 2,
    FTP_DIR_TRANSFER_MODE       = 3
} FTPTransferMode;

extern FTPTransferMode HTFTP_transferMode (void);
extern void HTFTP_setTransferMode (FTPTransferMode mode);

/*

.
  Global Control Mode
.

Can be used to set the default control modes for various FTP settings
like always aski for user name and password, etc.

*/

typedef enum _FTPControlMode {
    FTP_DEFAULT_CONTROL_MODE   = 0,
    FTP_ALWAYS_ASK_UID_PW      = 1
} FTPControlMode;

extern FTPControlMode HTFTP_controlMode (void);
extern void HTFTP_setControlMode (FTPControlMode mode);

/*

*/

#endif

/*



@(#) $Id: HTFTP.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTFWrite.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww ANSI C File Streams


!
  Basic ANSI C File Writer Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module contains a basic file writer stream that can be used to
dump data objects to local disk. See also the various subclasses of
this basic stream which can be used to do save-as, save-and-callback etc. 
in the HTFSave module

This module is implemented by HTFWrite.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTFWRITE_H
#define HTFWRITE_H

#include "HTStream.h"
#include "HTReq.h"

/*
.
  Basic ANSI C File Writer Stream
.

This function puts up a new stream given an open file descripter.
If the file is not to be closed afterwards, then set
leave_open=NO.
*/

extern HTStream * HTFWriter_new	(
        HTRequest * request,
	FILE * fp,
	BOOL leave_open);

/*

*/

#endif

/*

  

  @(#) $Id: HTFWrite.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTGopher.h
::::::::::::::
/*

					W3C Sample Code Library libwww GOPHER CLIENT




!Gopher Access!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module also cantains the CSO Name Server access via Gopher. 

This module is implemented by HTGopher.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTGOPHER_H
#define HTGOPHER_H

#include "HTProt.h"

extern HTProtCallback HTLoadGopher;

#endif

/*



@(#) $Id: HTGopher.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTGuess.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Content-Type Guessing Stream


!
  Content-Type Guessing Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This interface provides functionality for guessing unknown media types from
magic words. The stream is a one that reads first a chunk of stuff, tries
to figure out the format, and calls HTStreamStack(). This is
a kind of lazy-evaluation of HTStreamStack().

This could be extended arbitrarily to recognize all the possible file formats
in the world, if someone only had time to do it.

This module is implemented by HTGuess.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTGUESS_H
#define HTGUESS_H

#include "HTStream.h"
#include "HTFormat.h"

extern HTConverter HTGuess_new;

#endif	/* !HTGUESS_H */

/*

  

  @(#) $Id: HTGuess.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTHash.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Hash Table Class


!
  Hash Table Class
!

Written and integrated into libwww by John Punin - thanks!

This module is implemented by HTHash.c, and is a part
of the  W3C Sample Code Library.

This HashTable class implements a simple hash table to keep objects associated
with key words.
*/

#ifndef HTHASH_H
#define HTHASH_H

#include "HTList.h"

typedef struct _HTHashtable HTHashtable;

struct _HTHashtable {
    void **table;
    int count;
    int size;
};
    
typedef struct _keynode keynode;

struct _keynode {
    char *key;
    void *object;
};

/*
.
  Creation and Deletion Methods
.

These methods create and deletes a Hash Table
*/

extern HTHashtable *	HTHashtable_new	(int size);

extern BOOL	HTHashtable_delete (HTHashtable *me);

/*
.
  Add an Element to a HashTable
.
*/

extern BOOL HTHashtable_addObject (HTHashtable *me, const char *key, void *newObject);

/*
.
  Remove an Element from a HashTable
.
*/

extern BOOL HTHashtable_removeObject (HTHashtable *me, const char *key);

/*
.
  Search for an Element in a Hash Table
.
*/

extern void *	HTHashtable_object (HTHashtable * me, const char *key);

/*
.
  Size of a Hash Table
.
*/

extern int	HTHashtable_count  (HTHashtable *me);

/*
.
  Walk all the elements in a Hash Table
.

Walking the hashtable calls the specified function pointer with each key
and object that is in the hash table.  If the callback function returns 0,
the walking stops.  If it returns a negative number, the current element
is removed from the hash table.  Return a positive number to keep going.

Note that it is legal for the walkFunc to call HTHashtable_removeObject()
on any element in the current hash table except the current
one (if you intend to keep going, that is).  The only legal way to delete the
current element while continuing to walk the table is to use the negative
return value.
*/

extern BOOL	HTHashtable_walk (HTHashtable *me, int (*walkFunc)(HTHashtable *, char *, void *));

/*
.
  Extract in a dynamic array all keys of the Hash Table
.
*/

extern HTArray * HTHashtable_keys  (HTHashtable *me);

/*
.
  Print the keys of the Hash Table
.
*/

extern void HTHashtable_print (HTHashtable *me);

/*
*/

#endif

/*

  

  @(#) $Id: HTHash.html,v 1.1.1.1 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTHeader.h
::::::::::::::
/*

  
  
  
  					W3C Sample Code Library libwww MIME Headers


!
  MIME Headers
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module handles lists of callback functions for generating and parsing
protocol headers. This works exactly like the lists in
HTFormat.

This module is implemented by HTHeader.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTHEADER_H
#define HTHEADER_H

#include "HTResponse.h"
#include "HTStream.h"

/*

We have two call back functions: the first is for generating headers. This
needs a stream to put down the extra headers. This one is defined in the
Request Manager. The other one is for parsing. This
needs the string to parse.
*/

typedef int HTParserCallback (HTRequest * request, HTResponse * response,
                              char * token, char * value);

/*
.
  Header Parser Management
.

Header Parsers can be registered to handle any header. The standard set of
HTTP/1.1 MIME parsers is registered by HTMIMEInit in the
HTInit module. The HTParserCallbacks are called
by the HTMIME module.

HTParserCallbacks may be registered for known MIME headers (HTParser_*),
or for regular expressions (HTRegexParser_*). To data the regex support is
limited to the use of '*' for a wild card.
.
  Header Generator Management
.

Header Generators can be use to add additional information to aprotocol request.
They will all be called.
*/

extern BOOL HTGenerator_add (HTList * gens, HTPostCallback * callback);
extern BOOL HTGenerator_delete (HTList * gens, HTPostCallback * callback);
extern BOOL HTGenerator_deleteAll (HTList * gens);

/*
.
  Global List Of Parsers and Generators
.

As in HTFormat module you can register a list
globally or locally as you like. The local registrations is managed by
Request Manager
(
  Header Parsers
)
*/

#define MIME_HASH_SIZE  HT_L_HASH_SIZE

extern void HTHeader_setMIMEParseSet (HTMIMEParseSet * list);
extern HTMIMEParseSet * HTHeader_MIMEParseSet (void);
extern BOOL HTHeader_addParser (const char * token, BOOL case_sensitive,
				HTParserCallback * callback);
extern BOOL HTHeader_addRegexParser (const char * token, BOOL case_sensitive,
				HTParserCallback * callback);
extern BOOL HTHeader_deleteParser (const char * token);

/*
(
  Header Generation
)
*/

extern void HTHeader_setGenerator (HTList * list);
extern BOOL HTHeader_addGenerator (HTPostCallback * callback);
extern BOOL HTHeader_deleteGenerator (HTPostCallback * callback);
extern HTList * HTHeader_generator (void);

/*
(
  Delete all Global Lists
)
*/

extern void HTHeader_deleteAll (void);

/*
*/

#endif /* HTHEADER_H */

/*

  

  @(#) $Id: HTHeader.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTHInit.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Default HTML Parser Initialization


!
  Default HTML Parser Initialization Methods
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

As mentioned in the Library Architecture,
libwww consists of a small core and a large set of hooks for adding
functionality. By itself, the core it not capable of performing any Web related
tasks like accessing a HTTP server or parsing a HTML document. All this
functionality must be registered by the application. This way, the core of
libwww is kept application independent and can be used as the basic building
block for any kind of Web application. The Library comes with a large set
of default functions, for example for accessing HTTP and FTP servers, parsing
RFC
822 headers etc. This module helps the application programmer setting
up the HTML parser, but it is important to note that none of it is
required in order to use the Library.

This module is implemented by HTInit.c, and it is
a part of the W3C Sample Code
Library. You can also have a look at the other
Initialization modules.
*/

#ifndef HTHINIT_H
#define HTHINIT_H
#include "WWWLib.h"

/*
.
  Default HTML Parsers
.

The Converters are used to convert a media type to another media
type, or to present it on screen. This is a part of the stream stack algorithm.
The Presenters are also used in the stream stack, but are initialized separately.
*/

#include "HTML.h"			/* Uses HTML/HText interface */
#include "HTPlain.h"			/* Uses HTML/HText interface */

#include "HTTeXGen.h"
#include "HTMLGen.h"

extern void HTMLInit		(HTList * conversions);


/*
*/
#endif

/*

  

  @(#) $Id: HTHInit.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $

*/
::::::::::::::
HTHist.h
::::::::::::::
/*

					W3C Sample Code Library libwww HISTORY




!History Manager!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is a simple history module for a WWW client.  It keeps a linear
history, with a destructive or non-destructive backtrack, and
list sequencing (previous, next) operations.

If you are building a client, you don't have to use this: just don't
call it.  This module is not used by any other modules in the libwww,
so if you don't refer to it you don't get it in your linked
application. 

This module is implemented by HTHist.c, and it
is a part of the 
W3C Sample Code Library.

*/

#ifndef HTHISTORY_H
#define HTHISTORY_H

#include "HTAnchor.h"

/*

.Creation and Deletion Methods.

The history module can handle multiple history lists which can be
useful in a multithreaded environment with several open windows in the
client application. A new histrory lidt is referenced by the handle
returned from the creation method.

*/

typedef struct _HTHistory HTHistory;

extern HTHistory *HTHistory_new		(void);
extern BOOL HTHistory_delete		(HTHistory *old);

/*

.Add and delete History Elements.

(Record an entry in a list)

Registers the object in the linear list. The first entry is the home
page. No check is done for duplicates.  Returns YES if ok, else NO

*/

extern BOOL HTHistory_record		(HTHistory *hist, HTAnchor *cur);

/*

(Replace list with new element)

Iserts the new element at the current position and removes all any
old list from current position. For example if c is cur pos
	 
	 o before: a b c d e
	 o after : a b f
	 
	 Returns YES if ok, else NO
	 
	 */

extern BOOL HTHistory_replace		(HTHistory *hist, HTAnchor *cur);

/*

(Delete last entry in a list)

Deletes the last object from the list Returns YES if OK, else NO

*/

extern BOOL HTHistory_removeLast 	(HTHistory *hist);

/*

(Remove the History list from position)

Deletes the history list FROM the entry at position 'cur' (excluded).
Home page has position 1.  Returns YES if OK, else NO

*/

extern BOOL HTHistory_removeFrom 	(HTHistory *hist, int pos);

/*

(Number of elements stored)

Returns the size of the history list or -1 if none.

*/

extern int HTHistory_count		(HTHistory *hist);

/*

(Current Position)

Returns the current position or -1 on error

*/

extern int HTHistory_position		(HTHistory *hist);

/*

(Find and re-register visited anchor)

Finds already registered anchor at given position and registers it
again EXCEPT if last entry. This allows for `circular' history lists
with duplicate entries. Position 1 is the home anchor. The current
position is updated.

*/

extern HTAnchor * HTHistory_recall 	(HTHistory *hist, int pos);

/*

(Find Entry at position)

Entry with the given index in the list (1 is the home page). Like
HTHistory_recall but without re-registration. Un success,
the current position is updated to the value 'pos' value.

*/

extern HTAnchor * HTHistory_find 	(HTHistory *hist, int pos);

/*

(List the History List)

This function is like HTHistory_find() but does
not update the current position

*/

extern HTAnchor * HTHistory_list	(HTHistory *hist, int pos);

/*

.Navigation.

(Can we back in history)

Returns YES if the current anchor is not the first entry (home page)

*/

extern BOOL HTHistory_canBacktrack 	(HTHistory *hist);

/*

(Backtrack with deletion)

Returns the previous object and erases the last object. This does not
allow for 'forward' as we are always at the end of the list. If no
previous object exists, NULL is returned so that the application knows
that no previous object was found. See also HTHistory_back().

*/

extern HTAnchor * HTHistory_backtrack 	(HTHistory *hist);

/*

(Backtrack without deletion)

Returns the previos object but does not erase the last object. This
does not allow for 'forward'. If no previous object exists, NULL is
returned so that the application knows that no previous object was
found. See also HTHistory_backtrack()

*/

extern HTAnchor * HTHistory_back 	(HTHistory *hist);

/*

(Can we go forward)

Returns YES if the current anchor is not the last entry

*/

extern BOOL HTHistory_canForward 	(HTHistory *hist);

/*

(Forward)

Return the next object in the list or NULL if none

*/

extern HTAnchor * HTHistory_forward 	(HTHistory *hist);

#endif /* HTHISTORY_H */

/*



@(#) $Id: HTHist.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTHome.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Home Page Management


!
  Home Page Management
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module provides some "make life easier" functions in order to
get the application going. The functionality of this module was originally
in HTAccess, but now it has been moved here as
a part of the application interface where the
application may use it if desired.

This module is implemented by HTHome.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTHOME_H
#define HTHOME_H
#include "WWWLib.h"

/*

The home page is special in that this is is the first page to visit
when &nbsp;a client application starts up. Note that a home page is a generic
URL and hence can be any resouce - not only resources on the local file system.
.
  Personal Home Page
.
*/
#define LOGICAL_DEFAULT 	"WWW_HOME"    /* Defined to be the home page */

#ifndef PERSONAL_DEFAULT
#define PERSONAL_DEFAULT 	"WWW/default.html"	/* in home directory */
#endif

/* If the home page isn't found, use this file: */
#ifndef LAST_RESORT
#define LAST_RESORT		"http://www.w3.org/"
#endif

/*
.
  Home Page for Remote Access
.

Some Web applications can also be run remotely - for example as a telnet
login shell. The Line Mode Browser is an example of such an application.&nbsp;In
that case, the home page is often more generic than a personal home page.
*/

/* If one telnets to an access point it will look in this file for home page */
#ifndef REMOTE_POINTER
#define REMOTE_POINTER 		 "/etc/www-remote.url"	    /* can't be file */
#endif

/* and if that fails it will use this. */
#ifndef REMOTE_ADDRESS
#define REMOTE_ADDRESS  	"http://www.w3.org/"	    /* can't be file */
#endif

#ifndef LOCAL_DEFAULT_FILE
#define LOCAL_DEFAULT_FILE 	"/usr/local/lib/WWW/default.html"
#endif

/*
.
  Get an Anchor for the Home Page
.

Getting an anchor for the home page involves looking for the (environment)
variables described in the section above. As this is something that almost
all client applications must do then we provide some simple methods that
do the work for you.
*/

extern HTParentAnchor * HTHomeAnchor (void);

/*
.
  Create a New Anchor for Temporary Local Files
.

When the user starts writing a new document, the client application should
create a new anchor which can contain the document while it is created. This
can also be the location for backups and for security "auto-save" functionality.
This functions creates a new anchor with a URL pointing to the temporary
location defined by this user profile and returns that anchor.
Andy Levine: I additionally found that calling HTTmpAnchor repeatedly without
freeing the newly allocated anchor will cause the anchor hash table to
continue to grow.
*/

extern HTParentAnchor * HTTmpAnchor (HTUserProfile * up);

/*
.
  Get The Current Directory in URL form
.

Creates a local file URL that can be used as a relative name when calling
expanding other URLs relative to the current location in the local file system
tree where the application is running. The code for this routine originates
from the Line Mode Browser and was moved here by howcome@w3.org
in order for all clients to take advantage.
*/

#define HTFindRelatedName	HTGetCurrentDirectoryURL
extern char *  HTGetCurrentDirectoryURL (void);

/*
.
  Handle HTML Form Input fields
.

Takes a string of the form "a=b" containing HTML form data,
escapes it accordingly and puts it into the association list so that it readily
can be passed to any of the HTAccess function that handles HTML form data.
The string should not be encoded in any way - this function encodes it according
to the HTML form encoding rules.

Examples are "foo=bar", "baz=foo and bar", "a= b ", " a = b ", "toto=", "four
= two + two", "six three + three", and "a=b=c"
*/

extern BOOL HTParseFormInput (HTAssocList * list, const char * str);

/*
.
  Handle Library Trace Messages
.

Standard interface to libwww TRACE messages.
Pass this function a string of characters.  It will set up the appropriate
TRACE flags. The following characters are used as follows:

  
    f
  
    Show BASIC UTILITIES Trace Messages
  
    l
  
    Show APPLICATION LEVEL Trace Messages
  
    c
  
    Show CACHE Trace Messages
  
    g
  
    Show SGML Trace Messages
  
    b
  
    Show BIND Trace Messages
  
    t
  
    Show THREAD Trace Messages
  
    s
  
    Show STREAM Trace Messages
  
    p
  
    Show PROTOCOL Trace Messages
  
    m
  
    Show MEMORY Trace Messages
  
    q
  
    Show SQL Trace Messages
  
    u
  
    Show URI Trace Messages
  
    h
  
    Show AUTH Trace Messages
  
    a
  
    Show ANCHOR Trace Messages
  
    i
  
    Show PICS Trace Messages
  
    o
  
    Show CORE Trace Messages
  
    x
  
    Show MUX Trace Messages
  
    *
  
    Show ALL Trace Messages


The string must be null terminated, an example is "sop".
*/

extern int HTSetTraceMessageMask (const char * shortnames);

/*
*/

#endif /* HTHOME_H */

/*

  

  @(#) $Id: HTHome.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTHost.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Host Class


!
  The Host Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Host class manages what we know about a remote host. This can for example
be what type of host it is, and what version it is using. Notice that a host
object can be used to describe both a server or a client - all information
in the Host object can be shared regardless of whether it is to be used in
a server application or a client application.

This module is implemented by HTHost.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTHOST_H
#define HTHOST_H

typedef struct _HTHost HTHost;
#define HOST_HASH_SIZE		HT_M_HASH_SIZE

#include "HTChannl.h"
#include "HTReq.h"
#include "HTEvent.h"
#include "HTProt.h"
#include "HTTimer.h"

/*

The Host class contains information about the remote host, for example the
type (HTTP/1.0, HTTP/1.1, FTP etc.) along with information on how the connections
can be used (if it supports persistent connections, interleaved access etc.)
.
  Creation and Deletion Methods
.

We keep a cache of information that we know about a remote host. This allows
us to be much more detailed in generating requests. Search the host info
cache for a host object or create a new one and add it. Examples of host
names are
	 
	   o 
	     www.w3.org
	   o 
	     www.foo.com:8000
	 
	 (
  Add a Host Object
)
*/

extern HTHost * HTHost_new (char * host, u_short u_port);
extern HTHost * HTHost_newWParse(HTRequest * request, char * url, u_short u_port);
extern int HTHost_hash (HTHost * host);

/*
(
  Delete a Host Object
)

The Host Class contains an automatic garbage collection of Host objects so
that we don't keep information around that is stale.
(
  Find a Host Object
)

Searches the cache of known hosts to see if we already have information about
this host. If not then we return NULL.
*/

extern HTHost * HTHost_find (char * host);

/*
(
  Delete the Host table
)

Cleanup and delete the host table.
*/

extern void HTHost_deleteAll (void);

/*
(
  Is Host Idle?
)

You can use this function to see whether a host object is idle or in use.
We have several modes describing how and when a host is idle. This is a function
of the Transport Object
*/

extern BOOL HTHost_isIdle (HTHost * host);

/*
.
  Remote Host Information
.

We keep track of the capabilities of the host in the other end so thatwe
may adjust our queries to fit it better
(
  Remote Host Name
)

Get the name of the remote host. This is set automatically when a new Host
object and can be asked for at any point in time. You can not change the
host name but must create a new Host object instead.
*/

extern char * HTHost_name	(HTHost * host);

/*
(
  Remote Host Protocol Class and Version
)

Define the host class of the host at the other end. A class is a
generic description of the protocol which is exactly like the access method
in a URL, for example "http" etc. The host version is a finer
distinction (sub-class) between various versions of the host class, for example
HTTP/0.9, HTTP/1.1 etc. The host version is a bit flag that the protocol
module can define on its own. That way we don't have to change this module
when registering a new protocol module. The host type is a description
of whether we can keep the connection persistent or not.
*/

extern char * HTHost_class	(HTHost * host);
extern void HTHost_setClass	(HTHost * host, char * s_class);

extern int  HTHost_version	(HTHost * host);
extern void HTHost_setVersion	(HTHost * host, int version);

/*
(
  Public Methods accessible on This Host
)

A server can inform a client about the supported methods using the
Public header.
*/
extern HTMethod HTHost_publicMethods 	(HTHost * me);
extern void HTHost_setPublicMethods 	(HTHost * me, HTMethod methodset);
extern void HTHost_appendPublicMethods	(HTHost * me, HTMethod methodset);

/*
(
  Server Name of Remote Host
)

A server can send its server application name and version in a HTTP response.
We pick up this information and add it to the Host object
*/
extern char * HTHost_server	(HTHost * host);
extern BOOL HTHost_setServer	(HTHost * host, const char * server);

/*
(
  User Agent Name of Remote Host
)

A client can send the name of the client application in a HTTP request. We
pick up this information and add it to the Host Object
*/
extern char * HTHost_userAgent 	(HTHost * host);
extern BOOL HTHost_setUserAgent	(HTHost * host, const char * userAgent);

/*
(
  Range Units Accepted by this Host
)

Since all HTTP entities are represented in HTTP messages as sequences of
bytes, the concept of a byte range is meaningful for any HTTP entity. (However,
not all clients and servers need to support byte-range operations.) Byte
range specifications in HTTP apply to the sequence of bytes in the entity-body
(not necessarily the same as the message-body). A byte range operation may
specify a single range of bytes, or a set of ranges within a single entity.

You can also check whether a specific range unit is OK. We always say
YES except if we have a specific statement from the server that
it doesn't understand byte ranges - that is - it has sent "none" in a
"Accept-Range" response header
*/

extern char * HTHost_rangeUnits  (HTHost * host);
extern BOOL HTHost_setRangeUnits (HTHost * host, const char * units);
extern BOOL HTHost_isRangeUnitAcceptable (HTHost * host, const char * unit);

/*
(
  User Defined Contexts
)

This can be used for anything that the application would like to keep tabs
on.
*/

extern void HTHost_setContext (HTHost * me, void * context);
extern void * HTHost_context  (HTHost * me);

/*
.
  Register a Request on a Host Object
.

Requests are queued in the Host object until we have
resources to start them. The request is in the form
of a Net object as we may have multiple socket requests
per Request object. This is for example the case
with FTP which uses two connections.
*/

extern int  HTHost_addNet    (HTHost * host, HTNet * net);
extern BOOL HTHost_deleteNet (HTHost * host, HTNet * net, int status);

extern HTList * HTHost_net   (HTHost * host);

/*
.
  Channels
.

A Channel object is an abstraction for a transport,
like a TCP connection, for example. Each host object can have at most one
channel object associated with it.
(
  Create a Channel to a Host
)

As a Net Object doesn't necessarily know whether
there is a channel up and running and whether that channel can be reused,
it must do an explicit connect the the host.
*/

extern int HTHost_connect (HTHost * host, HTNet * net, char * url);

extern int HTHost_accept  (HTHost * host, HTNet * net, char * url);

extern int HTHost_listen  (HTHost * host, HTNet * net, char * url);

/*
(
  Is Channel About to Close?
)

As soon as we know that a channel is about to close (for example because
the server sends us a Connection: close header field) then we register
this informtation in the Host object:
*/

extern BOOL HTHost_setCloseNotification (HTHost * host, BOOL mode);
extern BOOL HTHost_closeNotification (HTHost * host);

/*
(
  Find Channel Associated with a Host Object
)

Here you can find an already associated channel with a host object or you
can explicitly associate a channel with a host object.
*/

extern BOOL HTHost_setChannel (HTHost * host, HTChannel * channel);
extern HTChannel * HTHost_channel (HTHost * host);

/*
(
  Delete a Channel
)

When a channel is deleted, it must be unregistered from the host object which
is done by this operation:
*/

extern BOOL HTHost_clearChannel (HTHost * host, int status);

/*
.
  Transport Mode
.

The way a channel can be used depends on the
transport and what mode the channel is in. The
mode (whether we can use persistent connections, pipeline, etc.) may change
mode in the middle of a connection If the new mode is lower than the old
mode then adjust the pipeline accordingly. That is, if we are going into
single mode then move all entries in the pipeline and move the rest to the
pending queue. They will get launched at a later point in time.
*/

extern HTTransportMode HTHost_mode (HTHost * host, BOOL * active);
extern BOOL HTHost_setMode (HTHost * host, HTTransportMode mode);

/*
.
  Handling Pending Requests
.

There are two ways we can end up with pending requests:

  o 
	     If we are out of sockets then register new host objects as pending.
	   o 
	     If we are pending on a connection then register new net objects as pending
	 

This set of functions handles pending host objects and can start new requests
as resources get available. The first function checks the host object for
any pending Net objects and return the first of
these Net objects.
*/

extern HTNet * HTHost_nextPendingNet (HTHost * host);

/*

The second checks the list of pending host objects waiting for a socket and
returns the first of these Host objects.
*/

extern HTHost * HTHost_nextPendingHost (void);

/*
(
  Start the Next Pending reqeust
)

Start the next pending request if any. First we look for pending requests
for the same host and then we check for any other pending hosts. If nothing
pending then register a close event handler to have something catching the
socket if the remote server closes the connection, for example due to timeout.
*/

extern BOOL HTHost_launchPending (HTHost * host);

/*
(
  Stop Launch of Pending Requests
)

Controls whether pending requests should be automatically activated. The
default is on, but if turned off then no pending requests are launched.
*/

extern void HTHost_enable_PendingReqLaunch (void);
extern void HTHost_disable_PendingReqLaunch (void);

/*
.
  Persistent Connections
.

We don't want more than (Max open sockets) - 2 connections to be persistent
in order to avoid deadlock. You can set the max number of simultaneous open
connection in the HTNet manager.
(
  Is this host Persistent?
)
*/

extern BOOL HTHost_setPersistent (HTHost * host, BOOL persistent,
                                  HTTransportMode mode);
extern BOOL HTHost_isPersistent (HTHost * host);

/*
(
  Persistent Connection Timeouts
)

If the server doesn't close the connection on us then we close it after a
while so that we don't unnecessarily take up resources (see also how the
timeouts of individual requests can be set).
Libwww provides two mechanisms: an active timeout and a passive timeout.
The former uses libwww timers and is the preferred
mechanism, the latter passively looks at the Host object when a new request
is issued in order to determine whether the existing channel can be reused.
This is primariliy for non-preemptive requests which in general is deprecated.

By default we have an active timeout of 60 secs and a passive timeout of
120 secs (the latter is longer as this is less reliable). Active timeout
s can be accessed using these functions:
*/

extern BOOL HTHost_setActiveTimeout (ms_t timeout);
extern ms_t HTHost_activeTimeout (void);

/*

and passive timeouts can be accessed using these functions
*/

extern time_t HTHost_persistTimeout (void);
extern BOOL HTHost_setPersistTimeout (time_t timeout);

/*

The following two functions are deprecated:
*/

extern void HTHost_setPersistExpires (HTHost * host, time_t expires);
extern time_t HTHost_persistExpires (HTHost * host);

/*
(
  Keeping Track of Number of Reqeusts
)

Another way to detect when a connection is about to close is to count the
number of requests made. For example, the (current) default bevaior by most
Apache servers is to close a TCP connection after 100 requests. I don't quite
think it makes sense to control the close of a connection like this but anyway,
there we go.
*/

extern void HTHost_setReqsPerConnection (HTHost * host, int reqs);
extern int HTHost_reqsPerConnection (HTHost * host);
extern void HTHost_setReqsMade (HTHost * host, int reqs);
extern int HTHost_reqsMade (HTHost * host);

/*
.
  Read and Write Management
.

Which Net object can read and/or write? When doing
pipelining, we essentially serialize requests and therefore we must keep
track of who can read and who can write.
(
  Get the Next Net object for Reading and Writing
)
*/

extern HTNet * HTHost_firstNet     (HTHost * host);
extern HTNet * HTHost_getReadNet  (HTHost * host);
extern HTNet * HTHost_getWriteNet (HTHost * host);

/*
(
  Get input and output Streams for this Host
)
*/

extern HTInputStream * HTHost_getInput (HTHost * host, HTTransport * transport,
				        void * param, int mode);

extern HTOutputStream * HTHost_getOutput (HTHost * host, HTTransport * tp,
					  void * param, int mode);

/*
(
  Reading Data and Keeping Track of how Much
)

Because of the push streams, the streams must keep track of how much data
actually was consumed by that stream.
*/

extern int HTHost_read(HTHost * host, HTNet * net);

extern BOOL HTHost_setConsumed(HTHost * host, size_t bytes);
extern BOOL HTHost_setRemainingRead(HTHost * host, size_t remainaing);
extern size_t HTHost_remainingRead (HTHost * host);

/*
.
  Pipelining Requests
.

When possible, we try to pipeline requests onto the same connection as this
saves a lot of time and leads to much higher throughput.
(
  How many Requests can we Pipeline onto the same Connection?
)

Use these functions to set the max number of requests that can be pipelined
at any one time on a single, persistent connection. The higher the number,
the more we have to recover if the server closes the connection prematurely.
The default is about 50 requests which is enough to fill most links.
*/

extern BOOL HTHost_setMaxPipelinedRequests (int max);
extern int HTHost_maxPipelinedRequests (void);

/*
(
  How many Pending and Outstanding Net objects are there on a Host?
)

You can query how many Het objects (essentially requests) are outstanding
or pending on a host object using these methods:
*/

extern int HTHost_numberOfOutstandingNetObjects (HTHost * host);
extern int HTHost_numberOfPendingNetObjects (HTHost * host);

/*
(
  Pipeline Recovery
)

Pipelines normally run by themselves (requests are issued and responses
recieved). However, it may be necessry to either prematurely abort a pipeline
or to recover a broken pipeline due to communication problems with the server.
In case a pipeline is broken then we have to recover it and start again.
This is handled automatically by the host object, so you do not have to call
this one explicitly.
*/

extern BOOL HTHost_recoverPipe (HTHost * host);
extern BOOL HTHost_doRecover (HTHost * host);

/*
(
  Kill a Pipeline
)

Call this function to terminate all requests (pending as well as active)
registered with a host object. This is typically the function that handles
timeout, abort (user hits the red button, etc). You can also use the
HTNet object kill method which in terms call this
function.
*/
extern BOOL HTHost_killPipe (HTHost * host);

/*
.
  Event Management
.

These functions are used to register and unregister events (read, write,
etc.) so that the host object knows about it.
*/

extern int HTHost_register(HTHost * host, HTNet * net, HTEventType type);
extern int HTHost_unregister(HTHost * host, HTNet * net, HTEventType type);
extern int HTHost_tickleFirstNet(HTHost * host, HTEventType type);

extern SockA * HTHost_getSockAddr(HTHost * host);

/*
(
  Request Timeouts
)

Events can be assigned a timeout which causes the event to be triggered if
the timeout happens before other action is available on the socket. You can
assign a global timeout for all host object using the following methods.
The default is no timeout.
*/

extern int HTHost_eventTimeout (void);
extern void HTHost_setEventTimeout (int millis);

/*
.
  Delayed Flush Timer
.

These methods can control how long we want to wait for a flush on a pipelined
channel. The default is 30ms which is OK in most situations.
*/

extern BOOL HTHost_setWriteDelay (HTHost * host, ms_t delay);
extern ms_t HTHost_writeDelay (HTHost * host);
extern int HTHost_findWriteDelay(HTHost * host, ms_t lastFlushTime, int buffSize);

/*

It is also possible to explicitly require a flush using the following method.
This can also be set directly in the request object
for a single request.
*/

extern int HTHost_forceFlush(HTHost * host);

/*

You can also set the global value so that all new host objects (and
therefore all new requests) will inherit this value instead of setting it
individually.
*/
extern BOOL HTHost_setDefaultWriteDelay (ms_t delay);
extern ms_t HTHost_defaultWriteDelay (void);

/*
.
  Multi homed Host Management
.

We keep track of hosts with multiple IP addresses - socalled multi-homed
hosts. This is used for two things: finding the fastest IP address of
that host and as a backup if one or more of the hosts are down. This is handled
in connection with the DNS manager
*/

extern BOOL HTHost_setHome (HTHost * host, int home);
extern int HTHost_home (HTHost * host);

extern BOOL HTHost_setRetry (HTHost * host, int retry);
extern int HTHost_retry (HTHost * host);
extern BOOL HTHost_decreaseRetry (HTHost * host);

/*
.
  Notify Request that it has become Active
.

A new callback plugged to the activation of a request which allows an application
to know when a request has become active.
*/

typedef int HTHost_ActivateRequestCallback (HTRequest * request);
extern void HTHost_setActivateRequestCallback
		(HTHost_ActivateRequestCallback * cbf);

/*

*/

#endif /* HTHOST_H */

/*

  

  @(#) $Id: HTHost.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTHstMan.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Private Hst Definition


!
  Private Host Definition
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the private definition of the Host Class. Please look in the public
Host Class for more documentation

This module is implemented by HTHost.c, and it is
a part of the W3C Sample Code Library.
*/

#ifndef HTHSTMAN_H
#define HTHSTMAN_H
#include "HTHost.h"
#include "HTDNS.h"
#include "HTEvent.h"
#include "HTProt.h"

#define PIPE_BUFFER_SIZE	8192

/*

The HTHost object is the core of the request queue management.
This object contains information about the socket descriptor, the input read
buffer etc. required to identify and service a request.
*/

typedef enum _TCPState {
    TCP_DNS_ERROR	= -3,
    TCP_ERROR		= -2,
    TCP_CONNECTED	= -1,
    TCP_BEGIN		= 0,
    TCP_CHANNEL,
    TCP_DNS,
    TCP_NEED_SOCKET,
    TCP_NEED_BIND,
    TCP_NEED_LISTEN,
    TCP_NEED_CONNECT,
    TCP_IN_USE
} TCPState;

struct _HTHost {
    int                 hash;

    /* Information about the otherend */
    char *  		hostname;	     /* name of host + optional port */
    u_short		u_port;
    time_t		ntime;				    /* Creation time */
    char *		type;				        /* Peer type */
    int 		version;			     /* Peer version */
    HTMethod		methods;	       	/* Public methods (bit-flag) */
    char *		server;				      /* Server name */
    char *		user_agent;			       /* User Agent */
    char *		range_units;			       	      /* ??? */

    /* When does this entry expire? */
    time_t		expires;	  /* Persistent channel expires time */
    int			reqsPerConnection;	  /* from Keep-Alive: header */
    int			reqsMade;		 /* updated as they are sent */

    /* Queuing and connection modes */
    HTList *		pipeline;		 /* Pipe line of net objects */
    HTList *		pending;	      /* List of pending Net objects */
    HTNet *             doit;               /* Transfer from pending to pipe */ 
    HTNet *             lock;             /* This is a kludge! */
    HTNet *		listening;	 /* Master for accepting connections */
    BOOL		persistent;
    HTTransportMode	mode;	      			   /* Supported mode */
    HTTimer *           timer;         /* Timer for handling idle connection */
    BOOL                do_recover;         /* If we are supposed to recover */
    int                 recovered;        /* How many times had we recovered */
    BOOL                close_notification;        /* Got a hint about close */
    BOOL                broken_pipe;

    /* Support for transports */
    HTChannel *		channel;			     /* data channel */

    /* Connection dependent stuff */
    HTdns *		dns;			       /* Link to DNS object */
    TCPState		tcpstate;		      /* State in connection */
    SockA 		sock_addr;	     /* SockA is defined in wwwsys.h */
    int			retry;		     /* Counting attempts to connect */
    int 		home;			 /* Current home if multiple */
    ms_t		connecttime;	   /* Time in ms on multihomed hosts */

    /* Event Management */
    HTEvent *		events[HTEvent_TYPES];/* reading and writing may differ */
    HTEventType	        registeredFor;	  /* Which actions are we blocked on */
    size_t		remainingRead;	 /* Tells HostEvent to call next net */

    /* User specific stuff */
    ms_t                delay;                          /* Write delay in ms */
    void *		context;		/* Protocol Specific context */
    int			forceWriteFlush;
    int                 inFlush;         /* Tells if we're currently processing
                                            a file flush */
};

#define HTHost_bytesRead(me)		((me) ? (me)->bytes_read : -1)
#define HTHost_bytesWritten(me)		((me) ? (me)->bytes_written : -1)

#define HTHost_setBytesRead(me,l)	((me) ? (me->bytes_read=(l)) : -1)
#define HTHost_setBytesWritten(me,l)	((me) ? (me->bytes_written=(l)) :-1)
#define HTHost_setDNS (host, dns)	((me) ? (me->dns=(dns)) :-1)

/*
*/

#endif /* HTHSTMAN_H */

/*

  

  @(#) $Id: HTHstMan.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTIcons.h
::::::::::::::
/*


  					W3C Sample Code Library libwww Icon Management


!
  Icon Management
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Icons for directory listsings etc. are bound to MIME
content-types and content-encodings as described
in the format manager. These functions bind icon
URLs to given content-type or encoding templates. Templates
containing a slash are taken to be content-type templates, other
are content-encoding templates.

This module is implemented by HTIcons.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTICONS_H
#define HTICONS_H

#include "WWWLib.h"

/*
*/

typedef struct _HTIconNode HTIconNode;

/*
.
  Add new Icons
.

All of these functions take an absolute URL and alternate text to use. Add
an icon the list
(
  Generic Icons
)
*/
extern BOOL HTIcon_add (const char * url, const char * prefix,
				char * alt, char * type_templ);

/*
(
  Specific Icons
)

We also have a special set of icons used to represent well-known things in
direcctory listings.

  Unknown Icon


Add a unknown icon representing files that we can't figure out what is and
hence can`'t come up with a better icon.
*/
extern BOOL HTIcon_addUnknown (const char * url, const char * prefix,
				char * alt);

/*

  Empty Icon


In order to aligned HTML pages for directory listings in preformatted mode,
we need an empty (or blank) icon of the same size as the other icons.
*/
extern BOOL HTIcon_addBlank (const char * url, const char * prefix,
				char * alt);

/*

  Parent Icon


Add an icon representing a level up in a directory listing - the parent
directory.
*/
extern BOOL HTIcon_addParent (const char * url, const char * prefix,
				char * alt);

/*

  Directory Icon


This icon represents a directory or a folder
*/
extern BOOL HTIcon_addDir (const char * url, const char * prefix,
				char * alt);

/*
.
  Find an Icon
.

This is a simplified file mode enumeration that can is used in directory
listings.
*/

typedef  enum _HTFileMode {
    HT_IS_FILE,				/* Normal file */
    HT_IS_DIR,				/* Directory */
    HT_IS_BLANK,			/* Blank Icon */
    HT_IS_PARENT			/* Parent Directory */
} HTFileMode;


extern HTIconNode * HTIcon_find (HTFileMode	mode,
				 HTFormat	content_type,
				 HTEncoding	content_encoding);

/*
.
  Icon URL
.

When you want to add the icon reference into a directory listing, you can
get the URL of the icon by using this method. Don't free or modify the string
returned!
*/
extern char * HTIcon_url (HTIconNode * node);

/*
.
  Alternative text
.

Get the alternative text (if any) for text based clients or if you don't
want to download the image right away. The string returned must be freed
by the caller.
*/
extern char * HTIcon_alternative (HTIconNode * node, BOOL brackets);

/*
.
  Delete all icons
.

Cleans up all memory used by icons. Should be called by
HTLibTerminate() (but it isn't).
*/
extern void HTIcon_deleteAll (void);

/*
.
  A Standard Set of Icons
.

The WWWFile interface does not define a default
set of icons but the Library distribution files comes with a standard
set of icons that can be used if desired. The Icons can be found in
$(datadir)/www-icons.The set covers the types described below
and they can be set up using the HTIconInit()
initialization function in the WWWInit startup
interface

	 
	   o 
	     blank.xbm for the blank icon
  o 
	     directory.xbm for directory icon
  o 
	     back.xbm for parent directory
  o 
	     unknown.xbm for unknown icon
  o 
	     binary.xbm for binary files
  o 
	     text.xbm for ascii files
  o 
	     image.xbm for image files
  o 
	     movie.xbm for video files
  o 
	     sound.xbm for audio files
  o 
	     tar.xbm for tar and gtar files
  o 
	     compressed.xbm for compressed and gzipped files

	 */

#endif /* HTICONS */

/*

  

  @(#) $Id: HTIcons.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTInet.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Generic Network Communication


!
  Generic Network Communication
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module has the common code for handling typical Internet functions like
getting the name of the local host, getting the domain name and email address
of user, parsing error codes returned in errno or equivalent
etc.

This module is implemented by HTInet.c, and it is
a part of the W3C Sample Code Library.
*/

#ifndef HTINET_H
#define HTINET_H
#include "HTReq.h"
#include "HTHstMan.h"

/*
(
  System Description of Error Message
)

Return error message corresponding to errno number given. We need to pass
the error number as a parameter as we on some platforms get different codes
from sockets and local file access.
*/

extern char * HTErrnoString	(int errnum);
extern int HTInetStatus		(int errnum, char * where);

/*
(
  Parse a Cardinal Value
)

Converts a string to a cardinal value. On entry: *pp points to first character
to be interpreted, terminated by non 0..9 character. *pstatus points to status
already valid, maxvalue gives the largest allowable value. On exit: *pp points
to first unread character, *pstatus points to status updated iff bad
*/

extern unsigned int HTCardinal (int *		pstatus,
				char **		pp,
				unsigned int	max_value);

/*
(
  Produce a string for an internet address
)

This function is equivalent to the BSD system call inet_ntoa in that
it converts a numeric 32-bit IP-address to a dotted-notation decimal string.
The pointer returned points to static memory which must be copied if it is
to be kept.
*/

extern const char * HTInetString (struct sockaddr_in * sin);

/*
(
  Parse a network node address and port
)

It is assumed that any portnumber and numeric host address is given in decimal
notation. Separation character is '.' Any port number given in host name
overrides all other values. 'host' might be modified.
*/

extern int HTParseInet (HTHost * host, char * hostname, HTRequest * request);

/*
(
  Timezone Offset
)

Calculates the offset from GMT in seconds.
*/

extern time_t HTGetTimeZoneOffset (void);

/*
(
  Get Time of day in Milli Seconds
)

Return the time of day in milli seconds.
*/
extern ms_t HTGetTimeInMillis (void);

/*
(
  FQDN of this Host
)

This function returns a the name of this host or NULL if not available. The
name is stored in a static variable.
*/

extern char * HTGetHostName (void);

/*
(
  User Email Address
)

This functions returns a char pointer to a static location containing the
mail address of the current user. The static location is different from the
one of the current host name so different values can be assigned. The default
value is <USER>@hostname where hostname is as returned
by HTGetHostName().
*/

#ifndef HT_DEFAULT_LOGIN
#define HT_DEFAULT_LOGIN	"libwww"
#endif

extern char * HTGetMailAddress (void);

/*
(
  News server
)

The default news host is "news" but you can get ans set the value here.
*/
extern char * HTGetNewsServer (void);

/*
(
  Get a Temporary File Name
)

HTGetTmpFileName() allows the user to control the choice of a directory.
The argument dir points to the name of the directory in which the file is
to be created. This is equivalent to tempnam() function.
*/

extern char * HTGetTmpFileName (const char * dir);

/*
(
  Signal Handling
)

This is only necessary to compile on a few platforms and only if the application
does not have its own signal handling. It is required on Solaris 2.3 (and
other SVR4 platforms?) due to a bug in the TCP kernel. When a
connect() is tried to a illegal port, solaris gives a SIGPIPE
signal instead of returning Connection refused.
*/

#ifdef WWWLIB_SIG
extern void HTSetSignal (void);
#endif

#endif   /* HTINET_H */

/*

  

  @(#) $Id: HTInet.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTInit.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Default Initialization


!
  Default Initialization Methods
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

As mentioned in the Library Architecture,
libwww consists of a small core and a large set of hooks for adding
functionality. By itself, the core it not capable of performing any Web related
tasks like accessing a HTTP server or parsing a HTML document. All this
functionality must be registered by the application. This way, the core of
libwww is kept application independent and can be used as the basic building
block for any kind of Web application. The Library comes with a large set
of default functions, for example for accessing HTTP and FTP servers, parsing
RFC
822 headers etc. This module helps the application programmer setting
up all this functionality, but it is important to note that none of it is
required in order to use the Library.

This module is implemented by HTInit.c, and it is
a part of the W3C Sample Code
Library. You can also have a look at the other
Initialization modules.
*/

#ifndef HTINIT_H
#define HTINIT_H
#include "WWWLib.h"
#include "WWWApp.h"

/*
.
  Default Transport Protocol Modules
.

Register the default set of transport protocols.
*/

#include "WWWTrans.h"

extern void HTTransportInit (void);

/*
.
  Default Protocol Modules
.

Set up default bindings between access schemes and the set of protocol modules
in the Library. The preemptive version registers all protocol modules to
use blocking sockets.
*/

#include "WWWHTTP.h"
#include "WWWFile.h"
#include "WWWFTP.h"
#include "WWWGophe.h"
#include "WWWTelnt.h"
#include "WWWNews.h"

#ifdef HT_DIRECT_WAIS
#include "WWWWAIS.h"
#endif

#ifndef FTP_PORT
#define FTP_PORT	21
#endif
#ifndef NEWS_PORT
#define NEWS_PORT	119
#endif
#ifndef GOPHER_PORT
#define GOPHER_PORT	70
#endif
#ifndef WAIS_PORT
#define WAIS_PORT	666
#endif
#ifndef HTTP_PORT
#define HTTP_PORT	80
#endif

#define HTAccessInit	HTProtocolInit

extern void HTProtocolInit (void);

extern void HTProtocolPreemptiveInit (void);

/*
.
  Default MIME Parsers
.

The core doesn't have any built in MIME parsers, but many of the protocols
need them. For instance, many elements of the library rely on the
Content-Length being correctly set. HTMIMEInit()
provides the minimal functionality needed for library reliabilty.
*/

#include "WWWMIME.h"
#include "WWWApp.h"

extern void HTMIMEInit (void);

/*
.
  Default Event Manager
.

libwww core does not have any default event loop - it has to be added by
the application. However, it does come with an example implementation thta
may be used. This implementation is based on a select system
call using non-blocking and interleaved sockets.
*/

#include "WWWApp.h"

/*
.
  Default Media Type Conversions
.

The Converters are used to convert a media type to another media
type, or to present it on screen. This is a part of the stream stack algorithm.
The Presenters are also used in the stream stack, but are initialized separately.
*/

#include "WWWMIME.h"
#include "WWWHTML.h"
#include "WWWStream.h"
#include "WWWDir.h"
#include "WWWCache.h"

#ifdef HT_EXPAT
#include "WWWXML.h"
#endif

extern void HTConverterInit	(HTList * conversions);

/*
(
  Presenters
)

The Presenters are used to present media types by calling
external programs, for example,  a Postscript viewer. This is a part of
the stream stack algorithm. The Converters are also used in the stream
stack, but are initialized separately. The Presenters use the same
include files as the Converters.
*/

extern void HTPresenterInit	(HTList * conversions);

/*
(
  Converters and Presenters
)

This function is only defined in order to preserve backward compatibility.
*/

extern void HTFormatInit	(HTList * conversions);

/*
.
  Default Transfer Encodings
.

Transfer encoders and decoders can handle encodings like chunked
etc.
*/
#include "WWWHTTP.h"

extern void HTTransferEncoderInit	(HTList * encodings);

/*
.
  Default Content Encodings
.

Content encoders and decoders can handle encodings like deflate
etc.
*/
#include "WWWZip.h"

extern void HTContentEncoderInit	(HTList * encodings);

/*
.
  Default BEFORE and AFTER Filters
.

This module provides a set of default BEFORE and AFTER filters
that can be registered by the Net manager to be
called before and after a request. All filters can be registered either to
be called globally (all requests) or locally (pr request basis).
Not done automaticly - may be done by application!
(
  BEFORE Filters
)

The BEFORE filters handle proxies, caches, rule
files etc. The filters are called in the order by which the are registered
*/
#include "WWWApp.h"

extern void HTBeforeInit (void);

/*
(
  AFTER Filters
)

The AFTER filters handle error messages, logging, redirection,
authentication etc. The filters are called in the order by which the are
registered
*/
extern void HTAfterInit (void);

/*
(
  BEFORE and AFTER Filters
)

This is just a short cut for registrating both BEFORE and AFTER
at once
*/
extern void HTNetInit (void);

/*
.
  Default Access Authentication Modules
.

The Access Manager which is implemented as a
BEFORE and an AFTER filter (automatically registered in
HTNetInit()) does not, by default, know of any access 
authentication schemes. As everything else, this must be registered! This 
function does the job and should be all you need.
*/
extern void HTAAInit (void);

/*
.
  Default Message and Dialog Functions
.

We register a set of alert messages Not done automaticly - may be done by
application!
*/
#include "WWWApp.h"

extern void HTAlertInit (void);

/*
.
  Default Icons for Directory Listings
.

The WWWDir interface contains support for including
references (URLs and ALT text tags) to icons in directory listings.
The icons are selected as a function of the media type and the content encoding
of the file in question. That is - you can set up icons for compressed files,
postscript files etc. There is also a small set of specific icons representing
directories etc.
*/
#include "WWWFile.h"

extern void HTIconInit (const char * url_prefix);

/*
*/

#endif

/*

  

  @(#) $Id: HTInit.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTIOStream.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww I/O Stream Classes


!
  I/O Stream Classes
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The I/O Stream class defines objects which accepts a sequence of characters
to and from a transport &nbsp;The input and output
stream are mainly derived from the generic stream
class and contains much of the same functionality. The main difference
is that the I/O streams also contains methods for reading and writing to
a transport.

This module is a part of the W3C
Sample Code Library.
*/

#ifndef HTIOSTREAM_H
#define HTIOSTREAM_H

typedef struct _HTInputStream HTInputStream;
typedef struct _HTOutputStream HTOutputStream;

#include "HTList.h"
#include "HTStream.h"
#include "HTChannl.h"

/*
.
  Input Stream
.

An input stream is a stream that can read data from a transport and via a
channel putting the data down to the application.
*/

typedef struct _HTInputStreamClass {

    char * name;

/*

This field is for diagnostics only
*/

    int (*flush)	(HTInputStream * me);

/*

The flush method is introduced in order to allow the stream to put
any buffered data down the stream pipe but without taking the stream pipe
down. It is for the stream to decide whether it has buffered data or not.
In some situations, the stream might not want to send buffered data down
the target as the date might be relevant for this stream only.
*/

    int (*_free)	(HTInputStream * me);

/*

The free method is like the flush method
but it also frees the current stream object and all stream objects down stream.
When the free method has been called, the whole stream
pipe (not only this object) should not accept any more data. See also the
close method below
*/

    int (*abort)	(HTInputStream * me, HTList * errorlist);

/*

The abort method should only be used if a stream is interrupted, for
example by the user, or an error occurs.
*/

    int (*read)		(HTInputStream * me);

/*

The read method is the method by which we can read data from the
transport layer.
*/

    int (*close)	(HTInputStream * me);

/*

Pipelined transports need to know how many bytes were consumed by 
the net object.
*/

    int (*consumed)	(HTInputStream * me, size_t bytes);

/*

The close method closes the transport and deletes the input
stream object. Note that this is different than the free method which doesn't
have to delete the input stream object itself.
*/

} HTInputStreamClass;

/*
.
  Output Stream
.

The output stream is similar to the generic stream
definition in that it has a superset of methods. The param
parameter and the mode parameter can be used for whatever purpose
suited.
*/

typedef struct _HTOutputStreamClass {

    char * name;

    int (*flush)	(HTOutputStream * me);

    int (*_free)	(HTOutputStream * me);

    int (*abort)	(HTOutputStream * me, HTList * errorlist);

    int (*put_character)(HTOutputStream * me, char ch);

    int (*put_string)	(HTOutputStream * me, const char * str);

    int (*put_block)	(HTOutputStream * me, const char * str, int len);

/*

See the generic Stream Definition for an explanation
of these methods. Note that they all have a HTOutputStream object
a the parameter, not a generic stream. This is to avoid incompatible
pointer warnings
*/

    int (*close)	(HTOutputStream * me);

/*

The close method closes the transport and deletes the input
stream object. Note that this is different than the free method which doesn't
have to delete the input stream object itself.
*/

} HTOutputStreamClass;

/*
.
  Transport Streams
.

Transport streams are special streams with creation methods like defined
below. Transport streams can be registered in a
transport object as ways of communicating with
the a transport.
(
  Transport Input Stream
)

We have two modes of the input stream depending on model used for data reading
is PUSH or PULL. The PUSH model is suitable if we are using
pseudo threads based on a select() call or equivalent and the
PULL is suitable in a real thread environment. In the latter case
it doesn't matter if a read procedure blocks as this only concerns a single
thread.
*/

typedef HTInputStream * HTInput_new	(HTHost *	host,
					 HTChannel *	ch,
					 void *		param,
					 int		mode);

/*
(
  Transport Output Stream
)
*/

typedef HTOutputStream * HTOutput_new	(HTHost *	host,
					 HTChannel *	ch,
					 void *		param,
					 int		mode);

/*
(
  Transport Output Stream Converter
)
*/

typedef HTOutputStream * HTOutputConverter_new(
	HTHost *		host,
	HTChannel *		ch,
	void *			param,
	int			mode,
	HTOutputStream *	target);

/*
*/

#endif /* HTIOSTREAM_H */

/*

  

  @(#) $Id: HTIOStream.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTLib.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Initialization


!
  Libwww Initialization
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module contains some generic functions for getting the name and version
of libwww. It also contains some global configuration options like if you
can access the local file system, for example.

This module is implemented by HTLib.c, and it is a
part of the  W3C Sample Code Library.
*/

#ifndef HTLIB_H
#define HTLIB_H

#include "HTUser.h"

/*
.
  Initializing and Terminating libwww
.

These two functions initialize memory and settings for the libwww core and
cleans up memory kept by libwww core when exiting the application. They
&nbsp;MUST be used as libwww otherwise is in a undefined state.
*/
extern BOOL HTLibInit (const char * AppName, const char * AppVersion);
extern BOOL HTLibTerminate (void);

/*
.
  Libwww Name and Version
.

You can get the generic name of the Library and the version by using the
following functions:
*/
extern const char * HTLib_name (void);
extern const char * HTLib_version (void);

/*
.
  Is libwww Initalized?
.

Returns YES or NO
*/
extern BOOL HTLib_isInitialized (void);

/*
.
  Application Name and Version
.

Returns the name of the application name and the version number. The name
and version SHOULD be short and to the point. They MUST NOT be used for
advertising or other non-essential information. Although any token character
MAY appear in a product-version, this token SHOULD only be used for a version
identifier.
(
  Set or get the application name
)

The name can not contain any spaces as it is used as part of the user agent
field. For the same reason, the string MUST be in US-ASCII. For example,
"SmartApp"
*/

extern const char * HTLib_appName (void);
extern BOOL HTLib_setAppName (const char * name);

/*
(
  Set or get the application version
)

The version token can not contain any spaces as it is used as part of the
user agent field. For the same reason, the string MUST be in US-ASCII. For
example, "1.0". 
*/

extern const char * HTLib_appVersion (void);
extern BOOL HTLib_setAppVersion (const char * version);

/*
.
  Accessing the Local File System
.

Libwww does normally use the local file system for dumping unknown data objects,
file cache etc. In some situations this is not desired, and we can therefore
turn it off. This mode also prevents you from being able to access other
resources where you have to login telnet, for example.
*/
extern BOOL HTLib_secure (void);
extern void HTLib_setSecure (BOOL mode);

/*
.
  Default User Profile
.

The default user profile is automatically created
by the libwww in order to get information about the hostname, default
email -address etc. All request objects will
be created with this default user profile. The application may assign individual
user profiles to every request object or may set the default user profile.
*/
extern HTUserProfile * HTLib_userProfile (void);
extern BOOL HTLib_setUserProfile (HTUserProfile * up);

/*
*/

#endif /* HTLIB_H */

/*

  

  @(#) $Id: HTLib.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTLink.h
::::::::::::::

/*



					W3C Sample Code Library libwww Link Class



!The Link Class!
*/
/*
**        (c) COPYRIGHT MIT 1995.
**        Please first read the full copyright statement in the file COPYRIGH.
*/
/*

The HTLink class represents links between anchor objects. By keeping the link as a object and
not as part of the anchor we are capable of handling link semantics in a much
more organized way. For example, we can then search for link types among all
the link objects that we have created. Anchor
objects are bound together using Link objects. Each anchor can be the
source or destination of zero, one, or more links from and to other
anchors.

Link information can come from many places - two classic examples are the
HTML LINK element and the HTTP Link header field.
Libwww supports both - the HTML LINK element is handled by the HTML parser and the HTTP Link header field
is handled by the MIME parser.

The Webbot uses the link class to maintain the
information of the Web that it is seeing when traversing the Web as a
robot.

This module is implemented by HTLink.c, and it is a
part of the  W3C Sample Code
Library.
*/
#ifndef HTLINK_H
#define HTLINK_H

typedef struct _HTLink        HTLink;

#include "WWWUtil.h"
#include "HTMethod.h"
#include "HTAnchor.h"
/*

.Creation and Deletion Methods.

These are the methods for crating and deleting new link objects

(Create a new Link Object)
*/
typedef HTAtom *         HTLinkType;

typedef enum _HTLinkResult {
    HT_LINK_INVALID = -1,
    HT_LINK_NONE = 0,
    HT_LINK_ERROR,
    HT_LINK_OK
} HTLinkResult;

struct _HTLink {
    HTAnchor *          dest;              /* The anchor to which this leads */
    HTLinkType          type;                      /* Semantics of this link */
    HTMethod            method;            /* Method for this link, e.g. PUT */
    HTLinkResult        result;    /* Result of any attempt to get this link */
};

HTLink * HTLink_new (void);
/*

(Delete a Link Object)

A link can be removed as any other object
*/
BOOL HTLink_delete (HTLink * link);
/*

(Remove All Link Information from an Anchor)

This is normally a part of deleting anchor objects.
*/
extern BOOL HTLink_removeAll (HTAnchor * me);
/*

.Predefined Link Types.

Just for ease of use, we define a seet of commonly used link types. You can
ofcourse use any other link type you want.
*/
#define HT_LR_PERM_REDIRECT        HTAtom_for("PERMANENT_REDIRECTION")
#define HT_LR_TEMP_REDIRECT        HTAtom_for("TEMPORARY_REDIRECTION")
#define HT_LR_SEE_OTHER            HTAtom_for("SEE_OTHER")
/*

.Handle Link Between Anchors.

As mentioned, link objects are the ones that bind anchor objects together
in a Web like structure

(Add a Link between two Anchors)

This method creates a new link between two anchor
objects.
*/
extern BOOL HTLink_add (
        HTAnchor *        source,
        HTAnchor *        destination, 
        HTLinkType        type,
        HTMethod          method);
/*

(Remove All Links Between two Anchors)

Removes link information from one anchor to another.
*/
extern BOOL HTLink_remove (
        HTAnchor *        source,
        HTAnchor *        destination);
/*

(Find a Link)

Find the anchor object between a destination and a source ancher. Return
link object if any, else NULL
*/
extern HTLink * HTLink_find (HTAnchor * source, HTAnchor * destination);
/*

(Find a Link with a given link type)

Returns a link with a given link type or NULL if nothing found
*/
extern HTLink * HTLink_findType (HTAnchor * me, HTLinkType type);
/*

.Link Information.

This is the set of methods for accessing the information carried by a link
object

(Link Destination)

The link destination is the destination anchor pointed to by the link.
*/
extern BOOL HTLink_setDestination (HTLink * link, HTAnchor * dest);
extern HTAnchor * HTLink_destination (HTLink * link);
/*

(Link Types and Semantic Links)

Each link has a sematic representation associated with it. This means that
the application can distinguish between pages based on the semantics of the
link. This is very similar to the LINK tag in HTML pages which
indicates the meaning if this pages to other pages.
*/
extern BOOL HTLink_setType (HTLink * link, HTLinkType type);
extern HTLinkType HTLink_type (HTLink * link);
/*

(Link Method)

The link method is the HTTP method we have performed between the two links.
For example, it can be a POST operation, or a PUT operation where the
operation on the first anchor created a new anchor.
*/
extern BOOL HTLink_setMethod (HTLink * link, HTMethod method);
extern HTMethod HTLink_method (HTLink * link);
/*

(Link Result)

When a link has been used for posting an object from a source to a
destination link, the result of the operation is stored as part of the link
information. This means that we can keep track of which operations we have
performed on a link and hence the application can ask the user whether he or
she wants to do a re-post, for example.
*/
extern BOOL HTLink_setResult (HTLink * link, HTLinkResult result);
extern HTLinkResult HTLink_result (HTLink * link);
/*
*/
#endif /* HTLINK_H */
/*





@(#) $Id: HTLink.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $ 

*/
::::::::::::::
HTList.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww List Class


!
  The List Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The list class defines a generic container for storing collections of things
in order. In principle it could be implemented in many ways, but in practice
knowing that it is a linked list is important for speed.

This module is implemented by HTList.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTLIST_H
#define HTLIST_H

#include "HTArray.h"

typedef struct _HTList HTList;

struct _HTList {
  void * object;
  HTList * next;
};

/*
.
  Creation and Deletion Methods
.

These two functions create and deletes a list
*/

extern HTList *	HTList_new	(void);
extern BOOL	HTList_delete	(HTList *me);

/*
.
  Add an Element to List
.

A new list element is added to the beginning of the list so that it is first
element just after the head element.
*/
extern BOOL HTList_addObject (HTList *me, void *newObject);

/*

 You can also append an element to the end of
the list (the end is the first entered object) by using the following function:
*/

extern BOOL HTList_appendObject (HTList * me, void * newObject);

/*
The following two functions, contributed by Vic 
Bancroft (bancroft@america.net) that do the same operation as above, but return
a pointer to the new HTList element that was added or appended.  This allows
one to keep a  reference to the end of the list outside of the list itself, 
which can be used to speed up certain list operations.
*/

extern HTList * HTList_addList (HTList * me, void * newObject);
extern HTList * HTList_appendList (HTList * me, void * newObject);

/*
.
  Remove List Elements
.

You can delete elements in a list using the following methods. The
first method only removes the first entry that it finds matching the
oldObject whereas the second method removes all
occurances of oldObject.

*/

extern BOOL	HTList_removeObject		(HTList * me, void * oldObject);
extern BOOL	HTList_quickRemoveElement	(HTList * me, HTList * last);
extern BOOL	HTList_removeObjectAll		(HTList * me, void * oldObject);

extern void *	HTList_removeLastObject		(HTList * me);
extern void *	HTList_removeFirstObject	(HTList * me);

/*
.
  Size of a List
.

Two small function to ask for the size
*/

#define 	HTList_isEmpty(me)		(me ? me->next == NULL : YES)
extern int	HTList_count			(HTList *me);

/*
.
  Reference List Elements By Index
.

In some situations is is required to use an index in order to refer to a
list element. This is for example the case if an element can be registered
multiple times.
*/

extern int	HTList_indexOf	 (HTList * me, void * object);
extern int	HTList_indexOfElement (HTList * me, HTList * element);
extern void *	HTList_objectAt	 (HTList * me, int position);
extern HTList * HTList_elementOf (HTList * me, void * object, HTList ** pLast);
#define 	HTList_objectOf(me)		(me ? me->object: NULL)

/*
.
  Find List Elements
.

This method returns the last element to the list or NULL if list is
empty
*/

#define		HTList_lastObject(me) \
		((me) && (me)->next ? (me)->next->object : NULL)

/*

This method returns the first element to the list or NULL if list
is empty
*/
extern void * HTList_firstObject  (HTList * me);

/*
.
  Traverse list
.

Fast macro to traverse the list. Call it first with copy of list header:
it returns the first object and increments the passed list pointer. Call
it with the same variable until it returns NULL.
*/

#define		HTList_nextObject(me) \
		((me) && ((me) = (me)->next) ? (me)->object : NULL)

/*
.
  Insertion Sort a List
.

This function sorts a list using the insertion sort mechanism. The comparison
function is passed as a parameter and you can &nbsp;find the definition of
HTComparer in the HTArray module.
Insertion sort is good method whenever a list is nearly in the correct order
and few items are many positions away from their sorted location. If the
list gets very long then you may wanna use a quicksort instead.
*/
extern BOOL HTList_insertionSort(HTList * list, HTComparer * comp);

/*
.
  Free list
.
*/

#define HTList_free(x)  HT_FREE(x)

#endif /* HTLIST_H */

/*

  

  @(#) $Id: HTList.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTLocal.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Local File Access


!
  Local File Access
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module has the common code for opening and closing local files.

This module is implemented by HTTCP.c, and it is a
part of the  W3C Sample Code
Library.
*/

#ifndef HTLOCAL_H
#define HTLOCAL_H

#include "HTNet.h"

/*
.
  Mode of File
.

A file can be opened in variuos modes dependent on whether it is to be opened
for reading or writing or both. We here define a set that is largely equivalent
to what we know from ANSI C file modes and Unix file modes:
*/

#ifndef NO_UNIX_IO
typedef int HTLocalMode;

#define HT_FB_RDONLY	O_RDONLY
#define HT_FT_RDONLY	HT_FB_RDONLY

#define HT_FB_WRONLY	O_WRONLY|O_CREAT
#define HT_FT_WRONLY	HT_FB_WRONLY

#define HT_FB_RDWR	O_RDWR
#define HT_FT_RDWR	HT_FB_RDWR

#define HT_FB_APPEND	O_APPEND
#define HT_FT_APPEND	HT_FB_APPEND

#else 
typedef const char *HTLocalMode;

#define HT_FB_RDONLY	"rb"
#define HT_FT_RDONLY	"r"

#define HT_FB_WRONLY	"wb"
#define HT_FT_WRONLY	"w"

#define HT_FB_RDWR	"r+b"
#define HT_FT_RDWR	"r+"

#define HT_FB_APPEND	"ab"
#define HT_FT_APPEND	"a"

#endif

/*
.
  Open a Local File
.

Opens a local file using whatever means are available on the current platform.
If we have unix file descriptors then use that as we can use select on them.
On windows we want to use asynchrounous handles - just like we handle the
socket interface as well. On other platforms, we use ANSI C file descriptors.
*/

extern int HTFileOpen (HTNet * net, char * local, HTLocalMode mode);

/*
.
  Close a Local File
.

Closes a file descriptor whatever means are available on the current platform.
If we have unix file descriptors then use this otherwise use the ANSI C file
descriptors
*/

extern int HTFileClose (HTNet * net);

/*
*/

#endif   /* HTLOCAL_H */

/*

  

  @(#) $Id: HTLocal.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTLog.h
::::::::::::::
/*

					W3C Sample Code Library libwww Log Class



!Log Manager!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is a generic log object which can be used to log events to a file.

This module is implemented by HTLog.c, and it is
a part of the  W3C
Sample Code Library.

*/

#ifndef HTLIBLOG_H
#define HTLIBLOG_H

#include "HTReq.h"

/*

.Create a new Log Object.

Create a new object and open the log file. The time used in the log file
is either GMT or local dependent on local.

*/

typedef struct _HTLog HTLog;

extern HTLog * HTLog_open (const char * filename, BOOL local, BOOL append);

/*

.Delete a Log Object.

Close the log file and delete the object

*/

extern BOOL HTLog_close (HTLog * log);

/*

.How many times has log object been accessed?.

Returns access count number or -1

*/

extern int HTLog_accessCount (HTLog * log);

/*

.Log a Client Request in CLF.

This functions logs the result of a request in what's close to CLF. It can 
be used on client side to track user behavior.

*/

extern BOOL HTLog_addCLF (HTLog * log, HTRequest * request, int status);

/*

.Log Referer Fields.

This functions logs the referer logs of where the user has been.

*/

extern BOOL HTLog_addReferer (HTLog * log, HTRequest * request, int status);

/*

.Log the following line.

A generic logger - logs whatever you put in as the line. The caller
is responsible for adding a line feed if desired.

*/

extern BOOL HTLog_addLine (HTLog * log, const char * line);

/*

.Log the Following Variable Arguments.

A generic logger with variable arguments

*/

extern BOOL HTLog_addText (HTLog * log, const char * fmt, ...);

/*

*/

#endif

/*



@(#) $Id: HTLog.html,v 1.1.1.1 1998/08/14 21:54:37 cvs Exp $


*/
::::::::::::::
HTMemLog.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Generic String Management


!
  Memory Buffered Logging
!
*/

/*
**	(c) COPYRIGHT MIT 199G.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

These functions provide functionality for memory buffered
logging. This is usefull for tracking data read and written without
affecting the timing of the network traffic.

This module is implemented by HTMemLog.c, and it
is a part of the W3C
Sample Code Library.
*/

#ifndef HTMEMLOG_H
#define HTMEMLOG_H

/*
.
  The Whole Deal
.
Too much to do right now.

*/

extern int HTMemLog_open (char * logName, size_t size, BOOL keepOpen);
extern int HTMemLog_add (char * buf, size_t len);
extern int HTMemLog_flush (void);
extern void HTMemLog_close (void);
extern HTTraceDataCallback HTMemLog_callback;

/*
*/

#endif /* !HTMEMLOG_H */

/*

  

  @(#) $Id: HTMemLog.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTMemory.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Dynamic Memory Handlers


!
  Dynamic Memory Handlers
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module defines any memory handler to be used by libwww for allocating
and de-allocating dynamic memory. As dynamic memory may be a scarce resource,
it is required that an application can handle memory exhaustion gracefully.
This module provides an interface that covers the following situations:

	 
	   o 
	     Handling of allocation, reallocation and de-allocation
    of dynamic memory
  o 
	     Recovering from temporary lack of available memory
  o 
	     Panic handling in case a new allocation fails

	 
Note: The Library core provides a default set of memory handlers
for allocating and de-allocating dynamic memory. In order to maintain a
reasonable performance, they are not registered dynamically but assigned
using C style macros. Hence, it is not possible to swap memory handler
at run time but this was considered to be a reasonable trade-off.

This module is implemented by HTMemory.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTMEMORY_H
#define HTMEMORY_H

#include "HTUtils.h"

/*
.
  Allocation, Reallocation and De-allocation
.

The Library provides a default set of methods for handling dynamic memory.
They are very basic and essentially identical to the C style
malloc, calloc, realloc, and
free:
*/
extern void* HTMemory_malloc(size_t size);
extern void* HTMemory_calloc(size_t count, size_t size);
extern void* HTMemory_realloc(void * ptr, size_t size);
extern void HTMemory_free(void* ptr);

/*
(
  Memory Macros
)

The methods above are not referred directly in the Library. Instead we use
a set of C style macros. If you don't wany any memory management beyond normal
malloc and alloc then you can just use that instead of the HTMemory_* function.
You can of course also provide your own methods as well.
*/

#define HT_MALLOC(size)		HTMemory_malloc((size))
#define HT_CALLOC(count, size)	HTMemory_calloc((count), (size))
#define HT_REALLOC(ptr, size)	HTMemory_realloc((ptr), (size))
#define HT_FREE(pointer)	{HTMemory_free((pointer));((pointer))=NULL;}

/*
.
  Memory Freer Functions
.

The dynamic memory freer functions are typically functions that are capable
of freeing large chunks of memory. In case a new allocation fails, the allocation
method looks for any registered freer functions to call. There can be multiple
freer functions and after each call, the allocation method tries again to
allocate the desired amount of dynamic memory. The freer functions are called
in reverse order meaning that the last one registered gets
called first. That way, it is easy to add temporary freer functions
which then are guaranteed to be called first if a methods fails.
(
  Add a Freer Function
)

You can add a freer function by using the following method. The Library may
itself register a set of free functions during initialization. If the application
does not register any freer functions then the Library looks how it can free
internal memory. The freer function is passed the total number of
bytes requested by the allocation.
*/
typedef void HTMemoryCallback(size_t size);

extern BOOL HTMemoryCall_add (HTMemoryCallback * cbf);

/*
(
  Delete a Freer Function
)

Freer functions can be deleted at any time in which case they are not called
anymore.
*/

extern BOOL HTMemoryCall_delete (HTMemoryCallback * cbf);
extern BOOL HTMemoryCall_deleteAll (void);

/*
.
  Panic Handling
.

If the freer functions are not capable of de-allocation enough memory then
the application must have an organized way of closing down. This is done
using the panic handler. In the libwww, each allocation is tested and
HT_OUTOFMEM is called if a NULL was returned.
HT_OUTOFMEM is a macro which by default calls
HTMemory_outofmem() but of course can point to any method. The
default handler calls an exit function defined by the application in a call
to HTMemory_setExit(). If the application has not defined
an exit function, HTMemory_outofmem() prints an error message
and calls exit(1).
*/

typedef void HTMemory_exitCallback(char *name, char *file, unsigned long line);

extern void HTMemory_setExit(HTMemory_exitCallback * pExit);
extern HTMemory_exitCallback * HTMemory_exit(void);

/*
(
  Call the Exit Handler
)

If an allocation fails then this function is called. If the application has
registered its own panic handler then this is called directly from this function.
Otherwise, the default behavior is to write a small message to stderr and
then exit.
*/

#define outofmem(file, name)	HT_OUTOFMEM(name)
#define HT_OUTOFMEM(name)	HTMemory_outofmem((name), __FILE__, __LINE__)

extern void HTMemory_outofmem(char * name, char * file, unsigned long line);

/*
*/

#endif /* HTMEMORY_H */

/*

  

  @(#) $Id: HTMemory.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTMerge.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Merge Stream


!
  Merge stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Merge stream can be used to merge multiple streams into a single
target stream. The Merge stream does not prevent any of the streams from
writing and no ordering is imposed. The main feature is basically that the
free and abort methods can be called n times where n equals the number of
feeds that put data to the stream.

This module is implemented by HTMerge.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef _HTMERGE_H
#define _HTMERGE_H

#include "HTStream.h"

extern HTStream * HTMerge (HTStream * target, int feeds);

#endif /* HTMERGE_H */

/*

  

  @(#) $Id: HTMerge.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTMethod.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Request Access Methods


!
  Request Access Methods
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module keeps a list of valid methods to be performed on a
request object, for example GET, HEAD,
PUT, POST, DELETE, etc.&nbsp;You can assign which method
to be performed on the request object directly or
you can go through the Access module for higher
level functions.

This module is implemented by HTMethod.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTMETHOD_H
#define HTMETHOD_H


/*

NOTE: The anchor list of allowed methods is a bitflag, not at list!
*/

typedef enum {
    METHOD_INVALID	= 0x0,
    METHOD_GET		= 0x1,
    METHOD_HEAD		= 0x2,    
    METHOD_POST		= 0x4,    
    METHOD_PUT		= 0x8,
    METHOD_PATCH	= 0x10,
    METHOD_DELETE	= 0x20,
    METHOD_TRACE	= 0x40,
    METHOD_OPTIONS	= 0x80,
    METHOD_LINK		= 0x100,

#ifdef HT_DAV
    METHOD_LOCK         = 0x400,              /* WebDAV Methods */
    METHOD_UNLOCK       = 0x800,

    METHOD_PROPFIND     = 0x1000,
    METHOD_PROPPATCH    = 0x2000,
    METHOD_MKCOL        = 0x4000,
    METHOD_COPY         = 0x8000,
    METHOD_MOVE         = 0x10000,
#endif

#ifdef HT_EXT
    METHOD_EXT_0        = 0x20000,            /* Extension methods */
    METHOD_EXT_1        = 0x40000,    
    METHOD_EXT_2        = 0x80000,
    METHOD_EXT_3        = 0x100000,
    METHOD_EXT_4        = 0x200000,
    METHOD_EXT_5        = 0x400000,
    METHOD_EXT_6        = 0x800000,
#endif

    METHOD_UNLINK	= 0x200
} HTMethod;

/*
(
  Get Method Enumeration
)

Gives the enumeration value of the method as a function of the (char *) name.
*/

extern HTMethod HTMethod_enum (const char * name);

/*
(
  Get Method String
)

The reverse of HTMethod_enum()
*/

extern const char * HTMethod_name (HTMethod method);

/*
(
  Is Method "Safe"?
)

If a method is safe, it doesn't produce any side effects on the server
*/

#define HTMethod_isSafe(me)	((me) & (METHOD_GET|METHOD_HEAD))

/*
(
  Does the Method Replace or Add to Metainformation
)

Most methods override the current set of metainformation stored in an
anchor. However, a few methods actually only
add to the anchor metainformation. We have a small macro to make the distinction.
*/

#define HTMethod_addMeta(me)  ((me) & (METHOD_TRACE | METHOD_OPTIONS))

/*
(
  Does a Method include Entity?
)

Does a method include an entity to be sent from the client to the server?

If not using WebDAV functions, neither extension methods, the
HTMethod_hasEntity is not changed, because a macro is much more performant
than a function. The function is interesting only when using WebDAV (many
methods) or extension methods (in this case, a dynamic structure is
needed).
*/

extern BOOL HTMethod_hasEntity(HTMethod me);

/*
(
Extension Methods
)


These methods have been introduced in Libwww for extension purposes.
Through these methods, application may register new methods, even libwww
unknown methods, and use them. It's recomended for applications that need
only a few new methods, that aren't yet in the libwww. The application should
register the desired methos, an before finish, it must unregister these
methods.
*/

extern BOOL HTMethod_setExtensionMethod (HTMethod method, const char * name, BOOL hasEntity);
extern BOOL HTMethod_deleteExtensionMethod (HTMethod method);

/*

*/

#endif /* HTMETHOD_H */

/*

  

  @(#) $Id: HTMethod.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTMIME.h
::::::::::::::
/*

  					W3C Sample Code Library libwww MIME Parsers


!
  Libwww MIME Parsers
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The MIME parser stream presents a MIME document with a header and possibly
a footer. It recursively invokes the format manager to handle embedded formats
like MIME multipart. As well as stripping off and parsing the headers, the
MIME parser has to parse any weird MIME encodings it may meet within the
body parts of messages, and must deal with multipart
messages (see HTBound.h).

This module is implemented to the level necessary for operation with WWW,
but is not currently complete for any arbitrary MIME message.

This module is implemented by HTMIME.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTMIME_H
#define HTMIME_H

#include "HTStream.h"
#include "HTFormat.h"

/*
.
  How to Deal with Unknown Data
.

When the MIME parser can't find a target stream, for example because the
media type is unknown, or it has a content encoding or transfer encoding
that it doesn't know about then it has to get rid of the data in some other
fashion, for example by dumping it to local disk (but it could also be dumping
it to a black hole). The following two functions allow you to set and get
the stream to use in this situation. By default, libwww provides an
implementation of a save stream as HTSaveLocally
which you may want to use - this is for example used by the
current profiles.
*/

extern void HTMIME_setSaveStream (HTConverter * save_stream);
extern HTConverter * HTMIME_saveStream (void);

/*
.
  MIME Parse Stream
.

This stream parses a complete MIME message and if a media type header is
found then the stream stack is called to create the nest stream instance
in the stream pipe. Any piece of the MIME body is pumped right through the
stream.
*/

extern HTConverter HTMIMEConvert;

/*
.
  MIME Header ONLY Parse Stream
.

This stream parses a complete MIME header and then returnes
HT_LOADED. It does not set up any streams and resting data stays
in the buffer. This can be used if you only want to parse the headers before
you decide what to do next. This is for example the case with HTTP HEAD requests.
*/

extern HTConverter HTMIMEHeader;

/*
.
  MIME Footer ONLY Parse Stream
.

Parse only a footer, for example after a chunked encoding.
*/

extern HTConverter HTMIMEFooter;

/*
.
  HTTP 100 Continue Parse Stream
.

The 100 continue status codes can come at any time - we take them and put
the data down a temporary stream. When the 100 continue message has been
parsed, the stream returns HT_CONTINUE
*/

extern HTConverter HTMIMEContinue;

/*
.
  HTTP 101 Switching Protocol Parse Stream
.

The 101 Switching Protocol status code indicates that the rest of the stream
is using another format, protocol, what ever. The result is the same - we
are done parsing here and must leave the rest to the next stream which hopefully
knows more about how to parse the rest of the stream. The stream stack is
called to look for a stream registered for handling
WWW_MIME_UPGRADE. This steam should
return HT_LOADED when it is done, HT_ERROR if an
error occurred and HT_OK as long as it just reads more data.
*/

extern HTConverter HTMIMEUpgrade;

/*
.
  HTTP 206 Partial Data MIME Parse Stream
.

In case we sent a Range conditional GET we may get back a 206 Partial
Response. This response must be appended to the already existing cache entry
before presented to the user. That is, first we load the
cached object and pump it down the pipe and then
the new data follows. Only the latter part gets appended to the cache, of
course.
*/

extern HTConverter HTMIMEPartial;

/*
.
 HTMIME_anchor2response
.

Copies the anchor HTTP headers into a response object by means
of the generic _dispatchParsers function. Written so that we can
copy the HTTP headers stored in the cache to the response object.
*/

#ifndef NO_CACHE
extern HTConverter HTCacheCopyHeaders;
#endif

/*
*/

#endif

/*

  

  @(#) $Id: HTMIME.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTMIMERq.h
::::::::::::::
/*

					W3C Sample Code Library libwww MIME REQUEST STREAM




!MIME Request Stream!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The MIME Request stream generates a MIME request header and writes it
to the target which is normally a HTWriter stream.

This module is implemented by HTMIMERq.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTMIMERQ_H
#define HTMIMERQ_H

#include "HTStream.h"
#include "HTReq.h"

/*

(Streams Definition)

This stream makes a MIME header before it goes into transparent
mode. If endHeader is YES then we send an empty
CRLF in order to end the header.

*/

extern HTStream * HTMIMERequest_new    (HTRequest * request, HTStream * target,
					BOOL endHeader);

#endif

/*



@(#) $Id: HTMIMERq.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $


*/
::::::::::::::
HTMIMImp.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Default MIME/RFC822 Header Parsers


!
  Default MIME/RFC822 Header Parsers
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Library's MIME parser is divided into two parts: A generic MIME parser
that knows how to unwrap all RFC822 headers and specialized header parsers
that knows how to parse Content-Length, for example. This is
the default set of the specialized MIME header parsers that can be registered
as part of the generic MIME. Note that these functions are not registered
by default - they must be registered by the application. This can be done
using the HTMIMEInit() function in the
WWWInit interface. Of course this can also be
used to register new headers that are not represented below - or if you want
to replace a default parser then this is also very easy.

This module is implemented by HTMIMImp.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTMIMIMP_H
#define HTMIMIMP_H

#include "HTReq.h"
#include "HTHeader.h"

/*
*/

extern HTParserCallback 
	HTMIME_accept, 
	HTMIME_acceptCharset, 
	HTMIME_acceptEncoding, 
	HTMIME_acceptLanguage, 
	HTMIME_acceptRanges, 
	HTMIME_authenticate,
	HTMIME_authenticationInfo,
	HTMIME_authorization,
	HTMIME_cacheControl,
	HTMIME_connection, 
	HTMIME_contentEncoding, 
	HTMIME_contentLength,
	HTMIME_contentRange,
	HTMIME_contentTransferEncoding, 
	HTMIME_contentType,
	HTMIME_keepAlive,
	HTMIME_link,
	HTMIME_location,
	HTMIME_maxForwards, 
	HTMIME_messageDigest,
	HTMIME_pragma,
	HTMIME_protocol,
	HTMIME_protocolInfo,
	HTMIME_protocolRequest,
	HTMIME_proxyAuthorization,
	HTMIME_proxyAuthenticationInfo,
	HTMIME_public,
	HTMIME_range,
	HTMIME_referer,
	HTMIME_retryAfter, 
	HTMIME_server, 
        HTMIME_trailer,
	HTMIME_transferEncoding,
	HTMIME_upgrade,
	HTMIME_userAgent,
	HTMIME_vary,
	HTMIME_via,
	HTMIME_warning;

/*
*/

#endif

/*

  

  @(#) $Id: HTMIMImp.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTMIMPrs.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww MIME header parser managment


!
  MIMEParseSet
!
*/

/*
**	(c) COPYRIGHT MIT 1996.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

A MIMEParseSet associates simple and regex MIME header tokens
with parsers. Regex tokens are stored in a list,
while simple tokens are stored in a hashed list for quick access.

This module is implemented by HTMIMPrs.c, and it
is a part of the  W3C Sample Code
Library.

*/

#ifndef HTMIMPRS_H
#define HTMIMPRS_H

#include "HTHeader.h"


/*
.
  Data Types
.

The HTMIMEParseSet contains all registered MIME parses. There are regex parsers,
which are stored in a list of HTMIMEParseEl, and simple (no wildcards) parsers
stored in a hashed array of lists of HTMIMEParseEl.
*/

typedef struct _HTMIMEParseEl HTMIMEParseEl;

struct _HTMIMEParseSet {
    int size;
    HTMIMEParseEl ** parsers;
    HTMIMEParseEl * regexParsers;
};

#define MIMEParseSet_NULL {0, NULL, NULL}

/*
.
  Public Functions
.

The following methods are available for this HTMIMEParseSets:
(
  Create and destroyHashLists
)
*/

extern HTMIMEParseSet * HTMIMEParseSet_new(int hashSize);
extern int HTMIMEParseSet_deleteAll (HTMIMEParseSet * me);

/*
(
  Add and remove parsers
)

Register a Header parser to be called if we encounter the token in the protocol
response. Tokens can contain a wildcard '*' which will match zero or more
arbritary chars.

*/

extern HTMIMEParseEl * HTMIMEParseSet_add (HTMIMEParseSet * me, 
					   const char * token, 
					   BOOL caseSensitive, 
					   HTParserCallback * callback);
extern HTMIMEParseEl * HTMIMEParseSet_addRegex (HTMIMEParseSet * me, 
						const char * token, 
						BOOL caseSensitive, 
						HTParserCallback * callback);
extern int HTMIMEParseSet_delete (HTMIMEParseSet * me, const char * token);

/*
(
  Execute these parsers
)

Find HTParserCallback which matches the string.
*/

extern int HTMIMEParseSet_dispatch (HTMIMEParseSet * me, HTRequest * request, 
				    char * token, char * value, BOOL * pFound);

/*
*/

#endif /* HTMIMPRS_H */

/*

  

  @(#) $Id: HTMIMPrs.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTMLGen.h
::::::::::::::
/*

					W3C Sample Code Library libwww HTML GENERATOR




!HTML generator!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module converts structed stream into stream.  That is, given a
stream to write to, it will give you a structured stream to. 

This module is implemented by HTMLGen.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTMLGEN_H
#define HTMLGEN_H

#include "HTStruct.h"
#include "HTFormat.h"

/*

The HTML generator stream is almost a converter stream but it returns
a structured stream instead of a generic stream. The difference is
that a structured stream has methods for starting and ending mark up
elements and for HTML/SGML entities.

*/

extern HTStructured* HTMLGenerator (HTRequest *	request,
				   void *	param,
				   HTFormat	input_format,
				   HTFormat	output_format,
				   HTStream *	output_stream);


extern HTConverter HTPlainToHTML;

#endif

/*



@(#) $Id: HTMLGen.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $


*/
::::::::::::::
HTML.h
::::::::::::::
/*

  					W3C Sample Code Library libwww HTML Parser With Text Object Converter


!
  Simple HTML Parser With Text Object Converter
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This interprets the HTML
semantics passed to it by the SGML parser. It then
creates a HText object which the application can
use to render an HTML object as text comes in over the wire. The
stylesheet manager can be used to ensure that
the rendering is done according to whatever style information is present.

This module is implemented by HTML.c, and it is a part
of the  W3C Sample Code Library.
*/

#ifndef HTML_H
#define HTML_H

#include "HTFormat.h"
#include "HTMLPDTD.h"

/*
.
  Converters
.

These are the converters implemented in this module. The first converts from
HTML to presentation or plain text.
*/

extern HTConverter HTMLToPlain;

/*

The next converts from HTML to a simple C like representation. It puts everything
not in PRE within C style comments. This is the way that the line mode browser
is used to convert the libwww HTML files to C style .h files
*/

extern HTConverter HTMLToC;

/*

This one converts the HTML stream to a rendered object using the
HText interface.
*/

extern HTConverter HTMLPresent;

/*
.
  Selecting Internal Character Set Representation
.

Only ISO_LATIN1 is currently supported.
*/

typedef enum _HTMLCharacterSet {
	HTML_ISO_LATIN1,
	HTML_NEXT_CHARS,
	HTML_PC_CP950
} HTMLCharacterSet;

extern BOOL HTMLUseCharacterSet (HTMLCharacterSet charset);

/*
*/

#endif		/* end HTML_H */

/*

  

  @(#) $Id: HTML.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTMLPDTD.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww HTML DTD


!
  HTML Plus DTD - Software Interface
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

SGML purists should excuse the use of the term "DTD" in this file to represent
DTD-related information which is not exactly a DTD itself. The C modular
structure doesn't work very well here, as the dtd is partly in the .h and
partly in the .c which are not very independent. Tant pis! There
are a couple of HTML-specific utility routines also defined.

This module is a part of the  W3C Sample
Code Library.
*/

#ifndef HTMLDTD_H
#define HTMLDTD_H

#include "HTStruct.h"
#include "SGML.h"

/*
.
  Number of HTML Entities
.

The entity names are defined in the C file. This gives the number of them.
Must Match all tables by element!
*/

#define HTML_ENTITIES 100

/*
.
  HTML Element Enumeration
.

These include tables in HTMLPDTD.c and
code in HTML.c. Note that not everything from
HTML 4.0 is there!
*/

typedef enum _HTMLElement {
	HTML_A = 0,
	HTML_ABBR,
	HTML_ACRONYM,
	HTML_ADDRESS,
	HTML_APPLET,
	HTML_AREA,
	HTML_B,
	HTML_BASE,
	HTML_BASEFONT,
	HTML_BDO,
	HTML_BIG,
	HTML_BLOCKQUOTE,
	HTML_BODY,
	HTML_BR,
	HTML_BUTTON,
	HTML_CAPTION,
	HTML_CENTER,
	HTML_CITE,
	HTML_CODE,
	HTML_COL,
	HTML_COLGROUP,
	HTML_DD,
	HTML_DEL,
 	HTML_DFN,
	HTML_DIR,
	HTML_DIV,
 	HTML_DL,
 	HTML_DT,
	HTML_EM,
	HTML_FIELDSET,
	HTML_FONT,
	HTML_FORM,
	HTML_FRAME,
	HTML_FRAMESET,
	HTML_H1,
 	HTML_H2,
 	HTML_H3,
	HTML_H4,
	HTML_H5,
 	HTML_H6, 
	HTML_HEAD,
 	HTML_HR,
	HTML_HTML,
	HTML_I,
	HTML_IFRAME,
	HTML_IMG,
	HTML_INPUT,
	HTML_INS,
	HTML_ISINDEX,
 	HTML_KBD,
	HTML_LABEL,
	HTML_LEGEND,
 	HTML_LI,
 	HTML_LINK,
	HTML_MAP,
	HTML_MENU,
	HTML_META,
	HTML_NEXTID,	/* !!! */
	HTML_NOFRAMES,
	HTML_NOSCRIPT,
	HTML_OBJECT,
	HTML_OL,
	HTML_OPTGROUP,
	HTML_OPTION,
	HTML_P,
	HTML_PARAM,
	HTML_PRE,
	HTML_Q,
	HTML_S,
	HTML_SAMP,
	HTML_SCRIPT,
	HTML_SELECT,
	HTML_SMALL,
	HTML_SPAN,
	HTML_STRIKE,
	HTML_STRONG,
	HTML_STYLE,
	HTML_SUB,
	HTML_SUP,
	HTML_TABLE,
	HTML_TBODY,
	HTML_TD,
	HTML_TEXTAREA,
	HTML_TFOOT,
	HTML_TH,
	HTML_THEAD,
	HTML_TITLE,
	HTML_TR,
	HTML_TT,
	HTML_U,
	HTML_UL,
	HTML_VAR,
	HTML_ELEMENTS		/* This must be the last entry */
} HTMLElement;

/*
.
  Element Attribute Enumerations
.

Identifier is HTML_<element>_<attribute>. These
must match the tables in
HTMLPDTD.c!
(
  Attributes definition Macros
)
*/

/* Define an attribute as HTML__ */
#define	HTML_ATTR(t,a)		HTML_##t##_##a
#define	HTML_ATTRIBUTES(t)	HTML_##t##_ATTRIBUTES

/*
(
  A
)
*/

enum _HTML_A_Attributes {
	HTML_ATTR(A,ACCESSKEY) = 0,
	HTML_ATTR(A,CHARSET),
	HTML_ATTR(A,CLASS),
	HTML_ATTR(A,COORDS),
	HTML_ATTR(A,DIR),
	HTML_ATTR(A,HREF),
	HTML_ATTR(A,HREFLANG),
	HTML_ATTR(A,ID),
	HTML_ATTR(A,NAME),
	HTML_ATTR(A,REL),
	HTML_ATTR(A,REV),
	HTML_ATTR(A,SHAPE),
	HTML_ATTR(A,STYLE),
	HTML_ATTR(A,TABINDEX),
	HTML_ATTR(A,TARGET),
	HTML_ATTR(A,TYPE),
	HTML_ATTR(A,TITLE),
	HTML_ATTRIBUTES(A)
};

/*
(
  APPLET - Deprecated
)
*/

enum _HTML_APPLET_Attributes {
	HTML_ATTR(APPLET,ALIGN) = 0,
	HTML_ATTR(APPLET,ALT),
	HTML_ATTR(APPLET,ARCHIVE),
	HTML_ATTR(APPLET,CLASS),
	HTML_ATTR(APPLET,CODE),
	HTML_ATTR(APPLET,CODEBASE),
	HTML_ATTR(APPLET,HEIGHT),
	HTML_ATTR(APPLET,HSPACE),
	HTML_ATTR(APPLET,ID),
	HTML_ATTR(APPLET,NAME),
	HTML_ATTR(APPLET,OBJECT),
	HTML_ATTR(APPLET,STYLE),
	HTML_ATTR(APPLET,TITLE),
	HTML_ATTR(APPLET,VSPACE),
	HTML_ATTR(APPLET,WIDTH),
	HTML_ATTRIBUTES(APPLET)
};

/*
(
  AREA
)
*/

enum _HTML_AREA_Attributes {
	HTML_ATTR(AREA,ACCESSKEY) = 0,
	HTML_ATTR(AREA,ALT),
	HTML_ATTR(AREA,CLASS),
	HTML_ATTR(AREA,COORDS),
	HTML_ATTR(AREA,DIR),
	HTML_ATTR(AREA,HREF),
	HTML_ATTR(AREA,ID),
	HTML_ATTR(AREA,NAME),
	HTML_ATTR(AREA,NOHREF),
	HTML_ATTR(AREA,LANG),
	HTML_ATTR(AREA,SHAPE),
	HTML_ATTR(AREA,STYLE),
	HTML_ATTR(AREA,TABINDEX),
	HTML_ATTR(AREA,TARGET),
	HTML_ATTR(AREA,TITLE),
	HTML_ATTRIBUTES(AREA)
};


/*
(
  BASE
)
*/

enum _HTML_BASE_Attributes {
	HTML_ATTR(BASE,HREF) = 0,
	HTML_ATTR(BASE,TARGET),
	HTML_ATTRIBUTES(BASE)
};

/*
(
  BDO
)
*/

enum _HTML_BDO_Attributes {
	HTML_ATTR(BDO,CLASS) = 0,
	HTML_ATTR(BDO,DIR),
	HTML_ATTR(BDO,ID),
	HTML_ATTR(BDO,LANG),
	HTML_ATTR(BDO,STYLE),
	HTML_ATTR(BDO,TITLE),
	HTML_ATTRIBUTES(BDO)
};

/*
(
  BLOCKQUOTE
)
*/

enum _HTML_BQ_Attributes {
	HTML_ATTR(BQ,CITE) = 0,
	HTML_ATTR(BQ,CLASS),
	HTML_ATTR(BQ,DIR),
	HTML_ATTR(BQ,ID),
	HTML_ATTR(BQ,LANG),
	HTML_ATTR(BQ,STYLE),
	HTML_ATTR(BQ,TITLE),
	HTML_ATTRIBUTES(BQ)
};

/*
(
  BODY
)
*/

enum _HTML_BODY_Attributes {
	HTML_ATTR(BODY,ALINK) = 0,
	HTML_ATTR(BODY,BACKGROUND),
	HTML_ATTR(BODY,BGCOLOR),
	HTML_ATTR(BODY,CLASS),
	HTML_ATTR(BODY,DIR),
	HTML_ATTR(BODY,ID),
	HTML_ATTR(BODY,LANG),
	HTML_ATTR(BODY,LINK),
	HTML_ATTR(BODY,STYLE),
	HTML_ATTR(BODY,TEXT),
	HTML_ATTR(BODY,TITLE),
	HTML_ATTR(BODY,VLINK),
	HTML_ATTRIBUTES(BODY)
};

/*
(
  BR
)
*/

enum _HTML_BR_Attributes {
	HTML_ATTR(BR,CLASS) = 0,
	HTML_ATTR(BR,CLEAR),
	HTML_ATTR(BR,ID),
	HTML_ATTR(BR,STYLE),
	HTML_ATTR(BR,TITLE),
	HTML_ATTRIBUTES(BR)
};

/*
(
  BUTTON
)
*/

enum _HTML_BUTTON_Attributes {
	HTML_ATTR(BUTTON,ACCESSKEY) = 0,
	HTML_ATTR(BUTTON,CLASS),
	HTML_ATTR(BUTTON,DIR),
	HTML_ATTR(BUTTON,DISABLED),
	HTML_ATTR(BUTTON,ID),
	HTML_ATTR(BUTTON,LANG),
	HTML_ATTR(BUTTON,NAME),
	HTML_ATTR(BUTTON,STYLE),
	HTML_ATTR(BUTTON,TABINDEX),
	HTML_ATTR(BUTTON,TITLE),
	HTML_ATTR(BUTTON,TYPE),
	HTML_ATTR(BUTTON,VALUE),
	HTML_ATTRIBUTES(BUTTON)
};

/*
(
  COL
)
*/

enum _HTML_COL_Attributes {
	HTML_ATTR(COL,CLASS) = 0,
	HTML_ATTR(COL,DIR),
	HTML_ATTR(COL,ID),
	HTML_ATTR(COL,LANG),
	HTML_ATTR(COL,SPAN),
	HTML_ATTR(COL,STYLE),
	HTML_ATTR(COL,TITLE),
	HTML_ATTR(COL,WIDTH),
	HTML_ATTRIBUTES(COL)
};

/*
(
  DEL, INS
)
*/

enum _HTML_CHANGES_Attributes {
	HTML_ATTR(CHANGES,CITE) = 0,
	HTML_ATTR(CHANGES,CLASS),
	HTML_ATTR(CHANGES,DATETIME),
	HTML_ATTR(CHANGES,DIR),
	HTML_ATTR(CHANGES,ID),
	HTML_ATTR(CHANGES,LANG),
	HTML_ATTR(CHANGES,STYLE),
	HTML_ATTR(CHANGES,TITLE),
	HTML_ATTRIBUTES(CHANGES)
};

/*
(
  FONT - Deprecated
)
*/

enum _HTML_FONT_Attributes {
	HTML_ATTR(FONT,CLASS) = 0,
	HTML_ATTR(FONT,COLOR),
	HTML_ATTR(FONT,DIR),
	HTML_ATTR(FONT,FACE),
	HTML_ATTR(FONT,ID),
	HTML_ATTR(FONT,LANG),
	HTML_ATTR(FONT,SIZE),
	HTML_ATTR(FONT,STYLE),
	HTML_ATTR(FONT,TITLE),
	HTML_ATTRIBUTES(FONT)
};

/*
(
  FORM
)
*/

enum _HTML_FORM_Attributes {
	HTML_ATTR(FORM,ACCEPT) = 0,
	HTML_ATTR(FORM,ACCEPT_CHARSET), /* { "ACCEPT-CHARSET" } */
	HTML_ATTR(FORM,ACTION),
	HTML_ATTR(FORM,CLASS),
	HTML_ATTR(FORM,DIR),
	HTML_ATTR(FORM,ENCTYPE),
	HTML_ATTR(FORM,ID),
	HTML_ATTR(FORM,LANG),
	HTML_ATTR(FORM,METHOD),
	HTML_ATTR(FORM,STYLE),
	HTML_ATTR(FORM,TARGET),
	HTML_ATTR(FORM,TITLE),
	HTML_ATTRIBUTES(FORM)
};

/*
(
  FRAME
)
*/

enum _HTML_FRAME_Attributes {
	HTML_ATTR(FRAME,CLASS) = 0,
	HTML_ATTR(FRAME,FRAMEBORDER),
	HTML_ATTR(FRAME,ID),
	HTML_ATTR(FRAME,NAME),
	HTML_ATTR(FRAME,MARGINHEIGHT),
	HTML_ATTR(FRAME,MARGINWIDTH),
	HTML_ATTR(FRAME,NORESIZE),
	HTML_ATTR(FRAME,LONGDESC),
	HTML_ATTR(FRAME,SCROLLING),
	HTML_ATTR(FRAME,SRC),
	HTML_ATTR(FRAME,STYLE),
	HTML_ATTR(FRAME,TARGET),
	HTML_ATTR(FRAME,TITLE),
	HTML_ATTRIBUTES(FRAME)
};

/*
(
  FRAMESET
)
*/

enum _HTML_FRAMESET_Attributes {
	HTML_ATTR(FRAMESET,CLASS) = 0,
	HTML_ATTR(FRAMESET,COLS),
	HTML_ATTR(FRAMESET,ID),
	HTML_ATTR(FRAMESET,ROWS),
	HTML_ATTR(FRAMESET,STYLE),
	HTML_ATTR(FRAMESET,TITLE),
	HTML_ATTRIBUTES(FRAMESET)
};

/*
(
  Generic attributes
)
*/

enum _HTML_GEN_Attributes {
	HTML_ATTR(GEN,CLASS) = 0,
	HTML_ATTR(GEN,DIR),
	HTML_ATTR(GEN,ID),
	HTML_ATTR(GEN,LANG),
	HTML_ATTR(GEN,STYLE),
	HTML_ATTR(GEN,TITLE),
	HTML_ATTRIBUTES(GEN)
};

/*
(
  BLOCK
)
*/

enum _HTML_BLOCK_Attributes {
	HTML_ATTR(BLOCK,ALIGN) = 0,
	HTML_ATTR(BLOCK,CLASS),
	HTML_ATTR(BLOCK,DIR),
	HTML_ATTR(BLOCK,ID),
	HTML_ATTR(BLOCK,LANG),
	HTML_ATTR(BLOCK,STYLE),
	HTML_ATTR(BLOCK,TITLE),
	HTML_ATTRIBUTES(BLOCK)
};

/*
(
  HEAD
)
*/

enum _HTML_HEAD_Attributes {
	HTML_ATTR(HEAD,DIR) = 0,
	HTML_ATTR(HEAD,LANG),
	HTML_ATTR(HEAD,PROFILE),
	HTML_ATTRIBUTES(HEAD)
};

/*
(
  HR
)
*/

enum _HTML_HR_Attributes {
	HTML_ATTR(HR,ALIGN) = 0,
	HTML_ATTR(HR,CLASS),
	HTML_ATTR(HR,DIR),
	HTML_ATTR(HR,ID),
	HTML_ATTR(HR,LANG),
	HTML_ATTR(HR,NOSHADE),
	HTML_ATTR(HR,SIZE),
	HTML_ATTR(HR,STYLE),
	HTML_ATTR(HR,TITLE),
	HTML_ATTR(HR,WIDTH),
	HTML_ATTRIBUTES(HR)
};

/*
(
  HTML
)
*/

enum _HTML_HTML_Attributes {
	HTML_ATTR(HTML,DIR) = 0,
	HTML_ATTR(HTML,LANG),
	HTML_ATTR(HTML,VERSION),
	HTML_ATTRIBUTES(HTML)
};

/*
(
  IFRAME
)
*/

enum _HTML_IFRAME_Attributes {
	HTML_ATTR(IFRAME,ALIGN) = 0,
	HTML_ATTR(IFRAME,CLASS),
	HTML_ATTR(IFRAME,FRAMEBORDER),
	HTML_ATTR(IFRAME,HEIGHT),
	HTML_ATTR(IFRAME,ID),
	HTML_ATTR(IFRAME,LONGDESC),
	HTML_ATTR(IFRAME,MARGINHEIGHT),
	HTML_ATTR(IFRAME,MARGINWIDTH),
	HTML_ATTR(IFRAME,NAME),
	HTML_ATTR(IFRAME,SCROLLING),
	HTML_ATTR(IFRAME,SRC),
	HTML_ATTR(IFRAME,STYLE),
	HTML_ATTR(IFRAME,TARGET),
	HTML_ATTR(IFRAME,TITLE),
	HTML_ATTR(IFRAME,WIDTH),
	HTML_ATTRIBUTES(IFRAME)
};

/*
(
  IMG
)
*/

enum _HTML_IMG_Attributes {
	HTML_ATTR(IMG,ALIGN) = 0,
	HTML_ATTR(IMG,ALT),
	HTML_ATTR(IMG,BORDER),
	HTML_ATTR(IMG,CLASS),
	HTML_ATTR(IMG,DIR),
	HTML_ATTR(IMG,HEIGHT),
	HTML_ATTR(IMG,HSPACE),
	HTML_ATTR(IMG,ID),
	HTML_ATTR(IMG,ISMAP),
	HTML_ATTR(IMG,LANG),
	HTML_ATTR(IMG,LONGDESC),
	HTML_ATTR(IMG,SRC),
	HTML_ATTR(IMG,STYLE),
	HTML_ATTR(IMG,TITLE),
	HTML_ATTR(IMG,USEMAP),
	HTML_ATTR(IMG,VSPACE),
	HTML_ATTR(IMG,WIDTH),
	HTML_ATTRIBUTES(IMG)
};

/*
(
  INPUT
)
*/

enum _HTML_INPUT_Attributes {
	HTML_ATTR(INPUT,ACCEPT) = 0,
	HTML_ATTR(INPUT,ACCESSKEY),
	HTML_ATTR(INPUT,ALIGN),
	HTML_ATTR(INPUT,ALT),
	HTML_ATTR(INPUT,CHECKED),
	HTML_ATTR(INPUT,CLASS),
	HTML_ATTR(INPUT,DIR),
	HTML_ATTR(INPUT,DISABLED),
	HTML_ATTR(INPUT,ID),
	HTML_ATTR(INPUT,LANG),
	HTML_ATTR(INPUT,MAXLENGTH),
	HTML_ATTR(INPUT,NAME),
	HTML_ATTR(INPUT,READONLY),
	HTML_ATTR(INPUT,SIZE),
	HTML_ATTR(INPUT,SRC),
	HTML_ATTR(INPUT,STYLE),
	HTML_ATTR(INPUT,TABINDEX),
	HTML_ATTR(INPUT,TITLE),
	HTML_ATTR(INPUT,TYPE),
	HTML_ATTR(INPUT,USEMAP),
	HTML_ATTR(INPUT,VALUE),
	HTML_ATTRIBUTES(INPUT)
};

/*
(
)
*/

enum _HTML_ISINDEX_Attributes {
	HTML_ATTR(ISINDEX,CLASS) = 0,
	HTML_ATTR(ISINDEX,DIR),
	HTML_ATTR(ISINDEX,ID),
	HTML_ATTR(ISINDEX,LANG),
	HTML_ATTR(ISINDEX,PROMPT),
	HTML_ATTR(ISINDEX,STYLE),
	HTML_ATTR(ISINDEX,TITLE),
	HTML_ATTRIBUTES(ISINDEX)
};

/*
(
)
*/

enum _HTML_LABEL_Attributes {
	HTML_ATTR(LABEL,ACCESSKEY) = 0,
	HTML_ATTR(LABEL,CLASS),
	HTML_ATTR(LABEL,DIR),
	HTML_ATTR(LABEL,FOR),
	HTML_ATTR(LABEL,ID),
	HTML_ATTR(LABEL,LANG),
	HTML_ATTR(LABEL,STYLE),
	HTML_ATTR(LABEL,TITLE),
	HTML_ATTRIBUTES(LABEL)
};

/*
(
)
*/

enum _HTML_LEGEND_Attributes {
    HTML_ATTR(LEGEND,ACCESSKEY) = 0,
    HTML_ATTR(LEGEND,ALIGN),
	HTML_ATTR(LEGEND,CLASS),
	HTML_ATTR(LEGEND,DIR),
	HTML_ATTR(LEGEND,ID),
	HTML_ATTR(LEGEND,LANG),
	HTML_ATTR(LEGEND,STYLE),
	HTML_ATTR(LEGEND,TITLE),
	HTML_ATTRIBUTES(LEGEND)
};

/*
(
  LI
)
*/

enum _HTML_LI_Attributes {
	HTML_ATTR(LI,CLASS) = 0,
	HTML_ATTR(LI,COMPACT),
	HTML_ATTR(LI,DIR),
	HTML_ATTR(LI,ID),
	HTML_ATTR(LI,LANG),
	HTML_ATTR(LI,STYLE),
	HTML_ATTR(LI,TITLE),
	HTML_ATTR(LI,TYPE),
	HTML_ATTR(LI,VALUE),
	HTML_ATTRIBUTES(LI)
};

/*
(
  LINK
)
*/

enum _HTML_LINK_Attributes {
	HTML_ATTR(LINK,CHARSET) = 0,
	HTML_ATTR(LINK,CLASS),
	HTML_ATTR(LINK,DIR),
	HTML_ATTR(LINK,HREF),
	HTML_ATTR(LINK,HREFLANG),
	HTML_ATTR(LINK,ID),
	HTML_ATTR(LINK,LANG),
	HTML_ATTR(LINK,MEDIA),
	HTML_ATTR(LINK,REL),
	HTML_ATTR(LINK,REV),
	HTML_ATTR(LINK,STYLE),
	HTML_ATTR(LINK,TARGET),
	HTML_ATTR(LINK,TITLE),
	HTML_ATTR(LINK,TYPE),
	HTML_ATTRIBUTES(LINK)
};

/*
(
  MAP
)
*/

enum _HTML_MAP_Attributes {
	HTML_ATTR(MAP,CLASS) = 0,
	HTML_ATTR(MAP,DIR),
	HTML_ATTR(MAP,ID),
	HTML_ATTR(MAP,LANG),
	HTML_ATTR(MAP,NAME),
	HTML_ATTR(MAP,STYLE),
	HTML_ATTR(MAP,TITLE),
	HTML_ATTRIBUTES(MAP)
};

/*
(
  META
)
*/

enum _HTML_META_Attributes {
	HTML_ATTR(META,CONTENT) = 0,
	HTML_ATTR(META,DIR),
	HTML_ATTR(META,HTTP_EQUIV),    /* { "HTTP-EQUIV" ) */
	HTML_ATTR(META,LANG),
	HTML_ATTR(META,NAME),
	HTML_ATTR(META,SCHEME),
	HTML_ATTRIBUTES(META)
};	

/*
(
  NEXTID
)
*/

#define HTML_NEXTID_ATTRIBUTES  1
#define HTML_NEXTID_N 0

/*
(
  OBJECT
)
*/

enum _HTML_OBJECT_Attributes {
	HTML_ATTR(OBJECT,ALIGN) = 0,
	HTML_ATTR(OBJECT,ARCHIVE),
	HTML_ATTR(OBJECT,BORDER),
	HTML_ATTR(OBJECT,CLASS),
	HTML_ATTR(OBJECT,CLASSID),
	HTML_ATTR(OBJECT,CODEBASE),
	HTML_ATTR(OBJECT,CODETYPE),
	HTML_ATTR(OBJECT,DATA),
	HTML_ATTR(OBJECT,DECLARE),
	HTML_ATTR(OBJECT,DIR),
	HTML_ATTR(OBJECT,HEIGHT),
	HTML_ATTR(OBJECT,HSPACE),
	HTML_ATTR(OBJECT,ID),
	HTML_ATTR(OBJECT,LANG),
	HTML_ATTR(OBJECT,NAME),
	HTML_ATTR(OBJECT,STANDBY),
	HTML_ATTR(OBJECT,STYLE),
	HTML_ATTR(OBJECT,TABINDEX),
	HTML_ATTR(OBJECT,TITLE),
	HTML_ATTR(OBJECT,TYPE),
	HTML_ATTR(OBJECT,USEMAP),
	HTML_ATTR(OBJECT,VSPACE),
	HTML_ATTR(OBJECT,WIDTH),
	HTML_ATTRIBUTES(OBJECT)
};

/*
(
  OL
)
*/

enum _HTML_OL_Attributes {
	HTML_ATTR(OL,CLASS) = 0,
	HTML_ATTR(OL,COMPACT),
	HTML_ATTR(OL,DIR),
	HTML_ATTR(OL,ID),
	HTML_ATTR(OL,LANG),
	HTML_ATTR(OL,START),
	HTML_ATTR(OL,STYLE),
	HTML_ATTR(OL,TITLE),
	HTML_ATTR(OL,TYPE),
	HTML_ATTRIBUTES(OL)
};

/*
(
  OPTGROUP
)
*/

enum _HTML_OPTGROUP_Attributes {
	HTML_ATTR(OPTGROUP,CLASS) = 0,
	HTML_ATTR(OPTGROUP,DISABLED),
	HTML_ATTR(OPTGROUP,DIR),
	HTML_ATTR(OPTGROUP,ID),
	HTML_ATTR(OPTGROUP,LABEL),
	HTML_ATTR(OPTGROUP,LANG),
	HTML_ATTR(OPTGROUP,STYLE),
	HTML_ATTR(OPTGROUP,TITLE),
	HTML_ATTRIBUTES(OPTGROUP)
};

/*
(
  OPTION
)
*/

enum _HTML_OPTION_Attributes {
	HTML_ATTR(OPTION,CLASS) = 0,
	HTML_ATTR(OPTION,DISABLED),
	HTML_ATTR(OPTION,DIR),
	HTML_ATTR(OPTION,ID),
	HTML_ATTR(OPTION,LABEL),
	HTML_ATTR(OPTION,LANG),
	HTML_ATTR(OPTION,SELECTED),
	HTML_ATTR(OPTION,STYLE),
	HTML_ATTR(OPTION,TITLE),
	HTML_ATTR(OPTION,VALUE),
	HTML_ATTRIBUTES(OPTION)
};

/*
(
  PARAM
)
*/

enum _HTML_PARAM_Attributes {
	HTML_ATTR(PARAM,ID) = 0,
	HTML_ATTR(PARAM,NAME),
	HTML_ATTR(PARAM,TYPE),
	HTML_ATTR(PARAM,VALUE),
	HTML_ATTR(PARAM,VALUETYPE),
	HTML_ATTRIBUTES(PARAM)
};

/*
(
  PRE
)
*/

enum _HTML_PRE_Attributes {
	HTML_ATTR(PRE,CLASS) = 0,
	HTML_ATTR(PRE,DIR),
	HTML_ATTR(PRE,ID),
	HTML_ATTR(PRE,LANG),
	HTML_ATTR(PRE,STYLE),
	HTML_ATTR(PRE,TITLE),
	HTML_ATTR(PRE,WIDTH),
	HTML_ATTRIBUTES(PRE)
};

/*
(
  SCRIPT
)
*/

enum _HTML_SCRIPT_Attributes {
	HTML_ATTR(SCRIPT,CHARSET) = 0,
	HTML_ATTR(SCRIPT,DEFER),
	HTML_ATTR(SCRIPT,LANGUAGE),
	HTML_ATTR(SCRIPT,SRC),
	HTML_ATTR(SCRIPT,TYPE),
	HTML_ATTRIBUTES(SCRIPT)
};

/*
(
  SELECT
)
*/

enum _HTML_SELECT_Attributes {
	HTML_ATTR(SELECT,CLASS) = 0,
	HTML_ATTR(SELECT,DIR),
	HTML_ATTR(SELECT,DISABLED),
	HTML_ATTR(SELECT,ID),
	HTML_ATTR(SELECT,LANG),
	HTML_ATTR(SELECT,MULTIPLE),
	HTML_ATTR(SELECT,NAME),
	HTML_ATTR(SELECT,SIZE),
	HTML_ATTR(SELECT,STYLE),
	HTML_ATTR(SELECT,TABINDEX),
	HTML_ATTR(SELECT,TITLE),
	HTML_ATTRIBUTES(SELECT)
};

/*
(
  STYLE
)
*/

enum _HTML_STYLE_Attributes {
	HTML_ATTR(STYLE,DIR) = 0,
	HTML_ATTR(STYLE,LANG),
	HTML_ATTR(STYLE,MEDIA),
	HTML_ATTR(STYLE,TITLE),
	HTML_ATTR(STYLE,TYPE),
	HTML_ATTRIBUTES(STYLE)
};

/*
(
  TABLE
)
*/

enum _HTML_TABLE_Attributes {
	HTML_ATTR(TABLE,ALIGN) = 0,
	HTML_ATTR(TABLE,BGCOLOR),
	HTML_ATTR(TABLE,BORDER),
	HTML_ATTR(TABLE,CELLPADDING),
	HTML_ATTR(TABLE,CELLSPACING),
	HTML_ATTR(TABLE,CLASS),
	HTML_ATTR(TABLE,DIR),
	HTML_ATTR(TABLE,FRAME),
	HTML_ATTR(TABLE,ID),
	HTML_ATTR(TABLE,LANG),
	HTML_ATTR(TABLE,RULES),
	HTML_ATTR(TABLE,SUMMARY),
	HTML_ATTR(TABLE,STYLE),
	HTML_ATTR(TABLE,TITLE),
	HTML_ATTR(TABLE,WIDTH),
	HTML_ATTRIBUTES(TABLE)
};

/*
(
  TABLE Elements
)
*/

enum _HTML_TELE_Attributes {
	HTML_ATTR(TELE,ALIGN) = 0,
	HTML_ATTR(TELE,CHAR),
	HTML_ATTR(TELE,CHAROFF),
	HTML_ATTR(TELE,CLASS),
	HTML_ATTR(TELE,DIR),
	HTML_ATTR(TELE,ID),
	HTML_ATTR(TELE,LANG),
	HTML_ATTR(TELE,STYLE),
	HTML_ATTR(TELE,TITLE),
	HTML_ATTR(TELE,VALIGN),
	HTML_ATTRIBUTES(TELE)
};

/*
(
  TD
)
*/

enum _HTML_TD_Attributes {
	HTML_ATTR(TD,ABBR) = 0,
	HTML_ATTR(TD,ALIGN),
	HTML_ATTR(TD,AXIS),
	HTML_ATTR(TD,BGCOLOR),
	HTML_ATTR(TD,CHAR),
	HTML_ATTR(TD,CHAROFF),
	HTML_ATTR(TD,CLASS),
	HTML_ATTR(TD,COLSPAN),
	HTML_ATTR(TD,DIR),
	HTML_ATTR(TD,ID),
	HTML_ATTR(TD,HEADERS),
	HTML_ATTR(TD,HEIGHT),
	HTML_ATTR(TD,LANG),
	HTML_ATTR(TD,NOWRAP),
	HTML_ATTR(TD,ROWSPAN),
	HTML_ATTR(TD,SCOPE),
	HTML_ATTR(TD,STYLE),
	HTML_ATTR(TD,TITLE),
	HTML_ATTR(TD,VALIGN),
	HTML_ATTR(TD,WIDTH),
	HTML_ATTRIBUTES(TD)
};

/*
(
  TEXTAREA
)
*/

enum _HTML_TEXTAREA_Attributes {
	HTML_ATTR(TEXTAREA,CLASS) = 0,
	HTML_ATTR(TEXTAREA,COLS),
	HTML_ATTR(TEXTAREA,DIR),
	HTML_ATTR(TEXTAREA,DISABLED),
	HTML_ATTR(TEXTAREA,ID),
	HTML_ATTR(TEXTAREA,LANG),
	HTML_ATTR(TEXTAREA,NAME),
	HTML_ATTR(TEXTAREA,READONLY),
	HTML_ATTR(TEXTAREA,ROWS),
	HTML_ATTR(TEXTAREA,STYLE),
	HTML_ATTR(TEXTAREA,TABINDEX),
	HTML_ATTR(TEXTAREA,TITLE),
	HTML_ATTRIBUTES(TEXTAREA)
};

/*
(
  TITLE
)
*/

enum _HTML_TITLE_Attributes {
	HTML_ATTR(TITLE,DIR) = 0,
	HTML_ATTR(TITLE,LANG),
	HTML_ATTRIBUTES(TITLE)
};

/*
(
  UL
)
*/

enum _HTML_UL_Attributes {
	HTML_ATTR(UL,CLASS) = 0,
	HTML_ATTR(UL,COMPACT),
	HTML_ATTR(UL,DIR),
	HTML_ATTR(UL,ID),
	HTML_ATTR(UL,LANG),
	HTML_ATTR(UL,STYLE),
	HTML_ATTR(UL,TITLE),
	HTML_ATTR(UL,TYPE),
	HTML_ATTRIBUTES(UL)
};

/*
.
  The C Representation of the SGML DTD
.
*/

extern SGML_dtd * HTML_dtd (void);
extern BOOL HTML_setDtd (const SGML_dtd * dtd);

/*
.
  Utitity Functions
.
(
  Start anchor element
)

It is kinda convenient to have a particular routine for starting an anchor
element, as everything else for HTML is simple anyway.
*/

extern void HTStartAnchor (
		HTStructured * targetstream,
		const char *  	name,
		const char *  	href);

/*
(
  Put image element
)

This is the same idea but for images
*/

extern void HTMLPutImg (HTStructured *obj,
		 	       const char *src,
			       const char *alt,
			       const char *align);


/*
(
  Specify next ID to be used
)

This is another convenience routine, for specifying the next ID to be used
by an editor in the series z1. z2,...
*/

extern void HTNextID (HTStructured * targetStream, const char * s);

/*
*/

#endif /* HTMLDTD_H */

/*

  

  @(#) $Id: HTMLPDTD.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTMulpar.h
::::::::::::::
/*

					W3C Sample Code Library libwww MIME MULTIPART STREAM




!MIME Multipart Stream Definition!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is a part of the  W3C Sample Code Library.

*/

#ifndef HTMULPAR_H
#define HTMULPAR_H

#include "HTStream.h"
#include "HTList.h"

/*

The MIME multipart stream is used to parse MIME multipart messages. It
works a bit like a structured stream in that it has some methods to
begin and end MIME body just as a structured stream has methods for
beginning and ending tags. 

The HTMultipart stream is a subclass of a Generic Stream Object. As always, we don't
have classes in basic C so we have to do this by hand! 

*/

typedef struct _HTMultipart HTMultipart;

typedef struct _HTMultipartClass {

    char * name;

    int (*flush)	(HTMultipart *	me);

    int (*_free)	(HTMultipart *	me);

    int (*abort)	(HTMultipart *	me, HTList * errorlist);

    int (*put_character)(HTMultipart *	me, char ch);

    int (*put_string)	(HTMultipart *	me, const char * str);

    int (*put_block)	(HTMultipart *	me, const char * str, int len);

/*

See the Generic Stream Definition for an
explanation of these methods. Note that they all have a
HTMultipart object a the parameter, not a generic
stream. This is to avoid incompatible pointer warnings

*/

    int (*begin_part)	(HTMultipart *	me, const char * boundary);

    int (*end_part)	(HTMultipart *	me);

    int (*preamble)	(HTMultipart *	me, const char * pre);

    int (*epilogue)	(HTMultipart *	me, const char * epi);
		
} HTMultipartClass;

#endif

/*



@(#) $Id: HTMulpar.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $


*/
::::::::::::::
HTMulti.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Content Negotiation


!
  Content Negotation
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

As part of the HTTP content negotiation, a server must be able to match the
preferences sent by the client in an HTTP request with the possible set of
documents that it has avaiable for this URL. For example , it may have an
English and a Danish version in which case it looks at the
Accept-Language header and sees what the client prefers. The
Library has a simple "Match" algorithm for finding the best as specified
by the HTTP specification. As the content algorithm is part of the File Interface
then all file access regardless of whether it is from a server or a client
application will be able to content negotiotion.

This module is implemented by HTMulti.c, and it is
a part of the  W3C Sample Code
Library
*/

#ifndef HTMULTI_H
#define HTMULTI_H

#include "HTReq.h"

/*

This function is used when the best match among several possible documents
is to be found as a function of the accept headers sent in the client request.
.
  Set the default Welcome page
.

Set default file name for welcome page on each directory.
*/
extern void HTAddWelcome (char * welcome_name);

/*
.
  Content Negotiation Algorithm
.

This function looks for a set of bindings between
a set of possible objects to be served on a request on the local file system.
*/

extern char * HTMulti (HTRequest *	req,
		      char *		path,
		      struct stat *	stat_info);

/*
*/

#endif /* HTMULTI_H */

/*

  

  @(#) $Id: HTMulti.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTMuxCh.h
::::::::::::::
/*

  					W3C Sample Code Library libwww MUX Protocol


!
  The MUX Protocol
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module defines the read and write functions to and from the network.
As we are having reentrant function and a smarter network I/O this will get
very small :-)

This module is implemented by HTMux.c, and it is a
part of the  W3C Sample Code
Library.
*/

#ifndef HTMUXCHANNEL_H
#define HTMUXCHANNEL_H

typedef struct _HTMuxChannel     HTMuxChannel;
typedef struct _HTMuxSession     HTMuxSession;
typedef struct _HTMuxProtocol    HTMuxProtocol;

typedef unsigned char            HTMuxSessionId;

#include "HTMuxHeader.h"
#include "HTChannl.h"
#include "HTHost.h"

#define INVSID		0		/* Invalid session id */
#define INVPID          0               /* Invalid protocol id */

/*
.
  Mux Channel
.
*/

extern HTMuxChannel * HTMuxChannel_new (HTHost * host);

extern HTMuxChannel * HTMuxChannel_find (HTHost * host);

extern BOOL HTMuxChannel_delete (HTMuxChannel * me);

extern BOOL HTMuxChannel_deleteAll (void);

extern HTNet * HTMuxChannel_net (HTMuxChannel * me);

extern HTMuxSession * HTMuxChannel_findSession (HTMuxChannel * me, HTMuxSessionId sid);

extern HTMuxSession * HTMuxChannel_findSessionFromNet (HTMuxChannel * me,
						       HTNet * net);

extern HTHost * HTMuxChannel_host (HTMuxChannel * muxch);

extern int HTMuxChannel_sendControl (HTMuxChannel * muxch, HTMuxSessionId sid,
				     HTMuxHeader opcode, int value,
				     const void * param, int param_size);


/*
.
  Mux Session
.
*/

typedef enum _HTMuxClose {
    MUX_S_END_READ     = 0x1,
    MUX_S_END_WRITE    = 0x2,
    MUX_S_END          = 0x3
} HTMuxClose;

extern HTMuxSessionId HTMuxSession_accept (HTMuxChannel * muxch, HTNet * net,
					   HTProtocolId pid);

extern HTMuxSessionId HTMuxSession_connect (HTMuxChannel * muxch, HTNet * net,
					    HTProtocolId pid);

extern int HTMuxSession_close (HTMuxChannel * muxch, HTMuxSessionId sid);

extern HTMuxSession * HTMuxSession_register (HTMuxChannel * muxch,
				             HTMuxSessionId sid,
                                             HTProtocolId pid);

extern HTMuxSessionId HTMuxSession_id (HTMuxSession * session);

extern HTProtocolId HTMuxSession_pid (HTMuxSession * session);

extern HTNet * HTMuxSession_net (HTMuxSession * session);

extern BOOL HTMuxSession_setClose (HTMuxChannel * muxch,
				   HTMuxSession * session, HTMuxClose close);

extern int  HTMuxSession_credit (HTMuxSession * session);

extern BOOL HTMuxSession_setCredit (HTMuxChannel * muxch,
				    HTMuxSessionId sid, int credit);

extern int  HTMuxSession_fragment (HTMuxSession * session);

extern BOOL HTMuxSession_setFragment (HTMuxChannel * muxch,
				      HTMuxSessionId sid, int fragment);

extern int HTMuxSession_disposeData (HTMuxSession * me,
				     const char * buf, int len);

/*
.
  Mux Protocol
.
*/

extern BOOL HTMuxProtocol_add (HTMuxChannel * muxch,
			       HTProtocolId pid, const char * protocol);

extern BOOL HTMuxProtocol_delete (HTMuxChannel * muxch, HTProtocolId pid);

/*
*/

#endif

/*

  

  @(#) $Id: HTMuxCh.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTMuxHeader.h
::::::::::::::
/*

  					W3C Sample Code Library libwww MUX Header Definition


!
  MUX Header Definition
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Define the parts of a mux header as defined by the MUX draft specification.
This is not finalized so be warned!

This module is does not contain a .c file. It is a part of the
 W3C Sample Code Library.
*/

#ifndef HTMUXHEADER_H
#define HTMUXHEADER_H

/*
.
  Byte Swapping
.

MUX is currently using little endian headers.
*/

#ifdef WORDS_BIGENDIAN
#define HT_WORDSWAP(a) ( ((a) << 24) | \
		         (((a) << 8) & 0x00ff0000) | \
		         (((a) >> 8) & 0x0000ff00) | \
	                 ((unsigned int)(a) >> 24) )
#else
#define HT_WORDSWAP(a) ((a))
#endif

/*
.
  The MUX Header
.

Simple, huh?
*/

typedef unsigned int  HTMuxHeader;

/*
(
  Generic Header flags
)
*/

#define MUX_LONG_LENGTH	0x80000000
#define MUX_CONTROL	0x40000000

/*
(
  Data Header Flags
)
*/

#define MUX_FLAGS       0x3C000000
#define MUX_SYN		0x20000000
#define MUX_FIN		0x10000000
#define MUX_RST		0x08000000
#define MUX_PUSH 	0x04000000

/*
(
  Control Header Opcodes
)
*/

#define MUX_OPCODES     0x3C000000
#define MUX_STRING	0x00000000
#define MUX_STACK	0x04000000
#define MUX_FRAGMENT	0x08000000
#define MUX_CREDIT	0x0C000000

/*
(
  Length and Session ID
)
*/

#define MUX_SESSION	0x03FC0000
#define MUX_LENGTH	0x0003FFFF

/*
.
  Macros for Byte Shifting
.
*/

#define MUX_SET_SID(sid)	((sid) << 18)
#define MUX_SET_LEN(len)	((len))
#define MUX_SET_PID             MUX_SET_LEN
#define MUX_SET_OPCODE(op)      ((op) << 26)

#define MUX_GET_SID(sid)	(((sid) & MUX_SESSION) >> 18)
#define MUX_GET_LEN(len)	((len) & MUX_LENGTH)
#define MUX_GET_PID             MUX_GET_LEN
#define MUX_GET_OPCODE(op)      ((op) & MUX_OPCODES >> 26)

/*
.
  Header Alignment
.

You can force 8 byte alignment by defining this to 1. Normally, we decide
pr MUX segment whether we have to use a long header or not.
*/

#define LONG_LENGTH	0			     /* 4 or 8 bytes header? */
#define MUX_IS_LONG(hdr)     ((hdr) & MUX_LONG_LENGTH)

#define MUX_ALIGN(len)       ((len) + ((4-(len)%4) % 4))
#define MUX_LONG_ALIGN(len)  ((len) + ((8-(len)%8) % 8))

/*

.
Default Values
.

*/

#define DEFAULT_CREDIT          4096

/*

*/

#endif

/*

  

  @(#) $Id: HTMuxHeader.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTMuxTx.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Buffered MUX Writer Stream


!
  Buffered MUX Writer Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The MUX Writer Stream is an output stream
&nbsp;which knows how to write to a MUX channel. It is part of the
Transport interface and may be registered as
part of a Transport Object. In the
default initialization module, you can find the
HTTransportInit() function which sets up this stream as a default
transport for handling unbuffered socket write operations. 

This module is implemented by HTMuxTx.c, and it is
a part of the W3C Sample Code
Library.
*/

#ifndef HTMUXWRITE_H
#define HTMUXWRITE_H

/*

*/

#define MUX_BUFFER_SIZE    2048

extern HTOutput_new HTMuxBuffer_new;

/*
*/
#endif

/*

  

  @(#) $Id: HTMuxTx.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTNDir.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww News/NNTP Browsing


!
  Generic News/NNTP Browsing
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This news browser generates listings for NNTP reponses. This module contains
the protocol independent code and it produces the HTML object. It is only
included if the NNTP.

This module is implemented by HTNDir.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTNDIR_H
#define HTNDIR_H
#include "HTReq.h"

/*
.
  What Should the Listings Look Like?
.

You can set how the listings are to be sorted using the following flags.
*/

typedef enum _HTNewsDirKey {
    HT_NDK_NONE		= 0,			/* Unsorted */
    HT_NDK_INDEX  	= 1,			/* Sort by Message Number */
    HT_NDK_DATE   	= 2,			/* Sort by date */
    HT_NDK_SUBJECT	= 3,			/* Sort by Subject */
    HT_NDK_FROM		= 4,			/* Sort by Sender */
    HT_NDK_GROUP	= 5,			/* Sort group listing */
    HT_NDK_REFTHREAD    = 6  /* Sort messages by date and thread Added by MP */
} HTNewsDirKey;

/*
.
  The News Listing Object
.

The news listing object handles the generation of a news listing. It is a
bit like a stream in that it accept data, but it must be formatted in a special
way which makes the normal stream architecture inadequate.
(
  Create a News Listing Object
)

Creates a structured stream object and sets up the initial HTML stuff Returns
the dir object if OK, else NULL
*/

typedef struct _HTNewsDir HTNewsDir;
extern HTNewsDir * HTNewsDir_new (HTRequest * request, const char * title,
				  HTNewsDirKey key, BOOL cache);

/*
(
  Add a Line to the List
)

This function accepts a news line. Everything except dir and nama can can
be 0 or NULL. Returns YES if OK, else NO
*/

typedef struct _HTNewsNode HTNewsNode;
extern HTNewsNode * HTNewsDir_addElement (HTNewsDir * dir, int index,
                                          char * subject,
				          char * from, time_t date,
                                          char * name,
				          int refs, HTList * refNames);
extern HTNewsNode * HTNewsDir_addGroupElement (HTNewsDir * dir, char * group,
                                               BOOL tmplate);

/*
(
  Check Whether Group Belongs to the Group Set
)

Returns TRUE if group belongs to set, e.g. group "soc.rec.jokes" belongs
to the set "soc.rec.*". Added by MP
*/
extern BOOL HTNewsDir_belongsToSet (HTNewsDir* dir, char* group);

/*
(
  Free a News Listing Object
)

If we are sorting then do the sorting and put out the list, else just append
the end of the list.
*/

extern BOOL HTNewsDir_free (HTNewsDir * dir);

/*
*/

#endif /* HTNDIR */

/*

  

  @(#) $Id: HTNDir.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTNet.h
::::::::::::::
/*

  					W3C Sample Code Library libwww HTNet Class


!
  The Net Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Net class manages information related to a "thread" in libwww. As libwww
threads are not really threads but a notion of using interleaved, non-blocking
I/O for accessing data objects from the network (or local file system), they
can be used on any platform with or without support for native threads. In
the case where you have an application using real threads the Net class is
simply a object maintaining links to all other objects involved in serving
the request. If you are using the libwww pseudo threads then the Net object
contains enough information to stop and start a request based on which BSD
sockets are ready. In practise this is of course transparent to the application
- this is just to explain the difference.

When a Request object is passed to the Library ,
the core creates a new HTNet object per channel
used by the request. In many cases a request only uses a single
channel object but, for example, FTP requests use
at least two - one for the control connection and one for the data connection.

You can find more information about the libwww pseudo thread model in the
 Multithread Specifications.

This module is implemented by HTNet.c, and it is a
part of the W3C Sample Code Library.
*/

#ifndef HTNET_H
#define HTNET_H

/*

The HTNet object is the core of the request queue management.
This object contains information about the socket descriptor, the input read
buffer etc. required to identify and service a request.
*/

typedef struct _HTNet HTNet;

#include "HTEvent.h"
#include "HTReq.h"
#include "HTResponse.h"
#include "HTTrans.h"
#include "HTHost.h"
#include "HTProt.h"
#include "HTChannl.h"
#include "HTDNS.h"

/*
.
  Generic BEFORE and AFTER Filter Management
.

Filter functions can be registered to be called before and
after a request has either been started or has terminated. The
conditions for BEFORE and AFTER filters are not the same, and so
we maintain them independently. Filters can be registered globally or locally.
The global filters are registered directly by the Net Object (this module)
and the local filters are registered by the
HTRequest Object. However, both &nbsp;local and
global filters use the same regisration mechanism which we provide here.
(
  Filter Ordering
)

Filters can be registered by anyone and as they are an often used mechanism
for introducing extensions in libwww, they are videly used to handle
authentication, redirection, etc. Many filters can be registered at once
and not all of the filters may know about the other filters. Therefore, it
is difficult to specify an absolute ordering by which the filters should
be called. Instead you can decide a relative order by which the filters should
be called. The order works pretty much like the Unix priority mechanism running
from HT_FILTER_FIRST to HT_FILTER_LAST having
HT_FILTER_MIDDLE being the "normal" case.
*/

typedef enum _HTFilterOrder {
    HT_FILTER_FIRST	= 0x0,		/*     0 */
    HT_FILTER_EARLY	= 0x3FFF,	/* 16383 */
    HT_FILTER_MIDDLE	= 0x7FFF,	/* 32767 */
    HT_FILTER_LATE	= 0xBFFE,	/* 49150 */
    HT_FILTER_LAST	= 0xFFFF	/* 65535 */
} HTFilterOrder;

/*

In case multiple filters are registered with the same order then they are
called in the inverse order they were registered.&nbsp;
(
  Filter URL Templates
)

Both BEFORE and AFTER filters can be registered with a URL
template in which case they are only called when the Request URL
matches the template. A template is simply a string which is matched against
the Request URL. The string can be terminated by a&nbsp;single
"*" in which case all strings matching the template up til the
"*" is considered a match. A template can be as short as the access scheme
which enmables a filter for a specific access method only, for example
"http//<star>".
(
  BEFORE Filters
)

A BEFORE filter is called whenever we issue a request and they have
been selected by the execution procedure. BEFORE filters are registered
with a context and a filter order by which they are to be called
and a URL template which may be NULL. In this case, the filter is
called on every request. The mode can be used by anybody to pass an extra
parameter to a filter. This is not really OO thinking - but hey - this is
C ;-)
*/
typedef int HTNetBefore (HTRequest * request, void * param, int mode);

/*

You can add a BEFORE filter in the list provided by the caller. Several
filters can be registered in which case they are called with the filter ordering
in mind.
*/

extern BOOL HTNetCall_addBefore (HTList * list, HTNetBefore * before,
				 const char * tmplate, void * param,
                                 HTFilterOrder order);

/*

You can also unregister all instances of a BEFORE filter from a list using
the following function
*/

extern BOOL HTNetCall_deleteBefore (HTList * list, HTNetBefore * before);

/*

You get rid of all BEFORE filters using this function
*/

extern BOOL HTNetCall_deleteBeforeAll (HTList * list);

/*

The BEFORE filters are expected and called if appropriate every time we issue
a new request. Libwww calls the BEFORE filters in the order specified at
registration time. If a filter returns other than HT_OK then stop and return
immediately. Otherwise return what the last filter returns.
*/

extern int HTNetCall_executeBefore (HTList * list, HTRequest * request);

/*
(
  AFTER Filters
)

An AFTER filter is called whenever we have terminated a request. That
is, on the way out from the protocol module and
back to the application. AFTER filters are registered with a
context, a status, a filter order by which they are
to be called and a URL template which may be NULL. The status of the
request may determine which filter to call. The set of possible values are
given below. An AFTER filter can be registered to handle one or more
of the codes.

  
    HT_ERROR
  
    An error occured
  
    HT_LOADED
  
    The document was loaded
  
    HT_NO_DATA
  
    OK, but no data
  
    HT_NO_ACCESS
  
    The request could not be succeeded due to lack of credentials
  
    HT_NO_PROXY_ACCESS
  
    The request could not be succeeded due to lack of credentials for accessing
    an intermediate proxy
  
    HT_RETRY
  
    Retry request after at a later time
  
    HT_PERM_REDIRECT
  
    The request has been permanently redirected and we send back the new URL
  
    HT_TEMP_REDIRECT
  
    The request has been temporarily redirected and we send back the new URL
  
    HT_ALL
  
    All of above


A Protocol module can also, in certain cases, return a HT_IGNORE
in which case no filters are called
*/

typedef int HTNetAfter (HTRequest * request, HTResponse * response,
                        void * param, int status);

/*

You can register a AFTER filter in the list provided by the caller. Several
filters can be registered in which case they are called with the filter ordering
in mind.
*/

extern BOOL HTNetCall_addAfter (HTList * list, HTNetAfter * after,
				const char * tmplate, void * param,
				int status, HTFilterOrder order);

/*

You can either unregister all filters registered for a given status using
this function or the filter for all status codes.
*/

extern BOOL HTNetCall_deleteAfter (HTList * list, HTNetAfter * after);
extern BOOL HTNetCall_deleteAfterStatus (HTList * list, int status);

/*

You can also delete all AFTER filters in list
*/

extern BOOL HTNetCall_deleteAfterAll (HTList * list);

/*

This function calls all the AFTER filters in the order specified at registration
time and if it has the right status code and it's not HT_IGNORE.
We also check for any template and whether it matches or not. If a filter
returns other than HT_OK then stop and return immediately. Otherwise return
what the last filter returns.
*/

extern int HTNetCall_executeAfter (HTList * list, HTRequest * request,
				   int status);

/*
.
  Global BEFORE and AFTER Filter Management
.

Global filters are inspected on every request (they do not have to be called
- only if the conditions match). You can also register filters locally in
the Request object.

  Global BEFORE Filters


These are the methods to handle global BEFORE Filters.
*/

extern BOOL HTNet_setBefore (HTList * list);

extern HTList * HTNet_before (void);

extern BOOL HTNet_addBefore (HTNetBefore * before, const char * tmplate,
			     void * param, HTFilterOrder order);

extern BOOL HTNet_deleteBefore (HTNetBefore * before);

/*

You can call both the local and the global BEFORE filters (if any)
*/

extern int HTNet_executeBeforeAll (HTRequest * request);

/*

  Global AFTER Filters


These are the methods to handle global AFTER Filters.
*/

extern BOOL HTNet_setAfter (HTList * list);

extern HTList * HTNet_after (void);

extern BOOL HTNet_addAfter (HTNetAfter * after, const char * tmplate,
			    void * param, int status,
                            HTFilterOrder order);

extern BOOL HTNet_deleteAfter (HTNetAfter * after);

extern BOOL HTNet_deleteAfterStatus (int status);

/*

You can call both the local and the global AFTER filters (if any)
*/

extern int HTNet_executeAfterAll (HTRequest * request, int status);

/*
.
  Socket Resource Management
.

The request queue ensures that no more than a fixed number of TCP connections
are open at the same time. If more requests are handed to the Library, they
are put into the pending queue and initiated when sockets become free.
(
  Number of Simultanous open TCP connections
)

Set the max number of simultanous sockets. The default value is HT_MAX_SOCKETS
which is 6. The number of persistent connections depend on this value as
a deadlock can occur if all available sockets a persistent (see the
DNS Manager for more information on setting the
number of persistent connections). The number of persistent connections can
never be more than the max number of sockets-2, so letting newmax=2 prevents
persistent sockets.
*/

extern BOOL HTNet_setMaxSocket (int newmax);
extern int  HTNet_maxSocket (void);

/*
(
  Socket Counters
)
*/

extern void HTNet_increaseSocket (void);
extern void HTNet_decreaseSocket (void);

extern int HTNet_availableSockets (void);

/*
(
  Persistent Socket Counters
)
*/

extern void HTNet_increasePersistentSocket (void);
extern void HTNet_decreasePersistentSocket (void);

extern int HTNet_availablePersistentSockets (void);

/*
(
  Any Ongoing Connections?
)

Returns whether there are active requests. Idle persistent sockets do not
count as active.
*/

extern BOOL HTNet_isIdle (void);

/*
(
  List Active Queue
)

Returns the list of active requests that are currently having an open connection.
Returns list of HTNet objects or NULL if error.
*/

extern HTList *HTNet_activeQueue (void);
extern BOOL HTNet_idle (void);

/*
(
  Are we Active?
)

We have some small functions that tell whether there are registered requests
in the Net manager. There are tree queues: The active, the
pending, and the persistent. The active queue
is the set of requests that are actively sending or receiving data. The
pending is the requests that we have registered but which are waiting
for a free socket. The Persistent queue are requets that are waiting
to use the same socket in order to save network resoures (if the server
understands persistent connections).

  Active Requests?


Returns whether there are requests in the active queue or not
*/

extern BOOL HTNet_idle (void);

/*

  Registered Requests?


Returns whether there are requests registered in any of the lists or not
*/

extern BOOL HTNet_isEmpty (void);
extern int HTNet_count (void);

/*
(
  List Pending Queue
)

Returns the list of pending requests that are waiting to become active. Returns
list of HTNet objects or NULL if error
*/

extern HTList *HTNet_pendingQueue (void);

/*
.
  Creation and Deletion Methods
.

The Net object is intended to live as long as the request is still active.
In that regard it is very similar to the Request Object
. However, the main difference is that a Net object represents a "thread"
in the Library and a request may have multiple "threads" - an example is
a FTP request which has a thread to handle the control connection and one
to handle the data connections.
(
  Create a new Object
)

If we have more than HTMaxActive connections already then put this into the
pending queue, else start the request by calling the call back function
registered with this access method. Returns YES if OK, else NO
*/

extern BOOL HTNet_newClient (HTRequest * request);

/*

You can create a new HTNet object as a new request to be handled. If we have
more than HTMaxActive connections already then return NO. Returns YES if
OK, else NO
*/

extern BOOL HTNet_newServer (HTRequest * request);

/*

And you can create a plain new HTNet object using the following method:
*/

extern HTNet * HTNet_new (HTHost * host);

/*
(
  Duplicate an existing Object
)

Creates a new HTNet object as a duplicate of the same request. Returns YES
if OK, else NO.
*/

extern HTNet * HTNet_dup (HTNet * src);
extern BOOL HTNet_deleteDup (HTNet * dup);

/*
(
  Launch a Net Object
)

Start a Net obejct by calling the protocol module.
*/
extern BOOL HTNet_start (HTNet * net);

/*
(
  Call a Net Event Handler
)

This functions lets the caller play event manager as it can calls any event
handler with the event type and context passed to the function
*/

extern BOOL HTNet_execute (HTNet * net, HTEventType type);

extern HTEvent * HTNet_event (HTNet * net);
extern BOOL HTNet_setEventParam (HTNet * net, void * eventParam);
extern void * HTNet_eventParam (HTNet * net);
extern BOOL HTNet_setEventCallback(HTNet * net, HTEventCallback * cbf);
extern HTEventCallback * HTNet_eventCallback(HTNet * net);

/*
(
  Delete an Object
)

Deletes the HTNet object from the list of active requests and calls any
registered call back functions IF not the status is HT_IGNORE. This is used
if we have internal requests that the app doesn't know about. We also see
if we have pending requests that can be started up now when we have a socket
free. The filters are called in the reverse order of which they were registered
(last one first);
*/

extern BOOL HTNet_delete (HTNet * me, int status);

/*
(
  Delete ALL HTNet Objects
)

Deletes all HTNet object that might either be active or pending We DO NOT
call the call back functions - A crude way of saying goodbye!
*/

extern BOOL HTNet_deleteAll (void);

/*
.
  Net Class Methods
.
(
  Make an Object Wait
)

Let a net object wait for a persistent socket. It will be launched from the
HTNet_delete() function when the socket gets free.
*/

extern BOOL HTNet_wait (HTNet *net);

/*
(
  Priority Management
)

Each HTNet object is created with a priority which it inherits from the
Request manager. However, in some stuations it is
useful to be to change the current priority after the request has been started.
These two functions allow you to do this. The effect will show up the first
time (which might be imidiately) the socket blocks and control returns to
the event loop. Also have a look at how you can do this before the request
is issued in the request manager.
*/

extern HTPriority HTNet_priority (HTNet * net);
extern BOOL HTNet_setPriority (HTNet * net, HTPriority priority);

/*
(
  Persistent Connections
)

You can set a Net object to handle persistent connections for example using
HTTP, NNTP, or FTP. You can control whether a Net object supports persistent
connections or not using this function.
*/

extern BOOL HTNet_persistent (HTNet * net);

/*

You can set or disable a Net object supporting persistent connections using
this function:
*/

extern BOOL HTNet_setPersistent (HTNet *           net,
                                 BOOL              persistent,
                                 HTTransportMode   mode);

/*
(
  Kill one or more Requests
)

  Kill this request and all requests in the Pipeline


When pipelining, it is not possible to kill a single request as we then loose
track of where we are in the pipe. It is therefore necessary to kill the
whole pipeline.
*/

extern BOOL HTNet_killPipe (HTNet * net);

/*

  Kill a single Request


This is not often used anymore, consider using the pipeline version above.
Kill the request by calling the call back function with a request for closing
the connection. Does not remove the object. This is done by HTNet_delete()
function which is called by the load routine. Returns OK if success, NO on
error.
*/

extern BOOL HTNet_kill (HTNet * me);

/*

  Kill ALL Requests


Kills all registered (active as well as pending) requests by calling
the call back function with a request for closing the connection. We do not
remove the HTNet object as it is done by HTNet_delete(). Returns OK if success,
NO on error
*/

extern BOOL HTNet_killAll (void);

/*
(
  Create Input and Output Streams
)

You create the input stream and bind it to the channel using the following
methods. Please read the description in the
HTIOStream module on the parameters
target, param, and mode. Both methods return YES
if OK, else NO.
*/

#if 0
extern HTInputStream * HTNet_getInput (HTNet * net, HTStream * target,
				       void * param, int mode);
#endif
extern HTOutputStream * HTNet_getOutput (HTNet * me, void * param, int mode);

/*
(
  Net Context Descriptor
)

Just like the request
object, a net object can be assigned a context which keeps track of context
dependent information. The Library does not use this information nor does
it depend on it but it allows the application to customize a net object to
specific uses.
*/
extern BOOL HTNet_setContext (HTNet * net, void * context);
extern void * HTNet_context (HTNet * net);

/*
(
  Socket Descriptor
)
*/

extern BOOL HTNet_setSocket (HTNet * net, SOCKET sockfd);
extern SOCKET HTNet_socket (HTNet * net);

/*
(
  Preemptive or Non-preemptive Access
)

A access scheme is defined with a default for using either preemptive (blocking
I/O) or non-premitve (non-blocking I/O). This is basically a result of the
implementation of the protocol module itself. However, if non-blocking I/O
is the default then some times it is nice to be able to set the mode to blocking
instead. For example when loading the first document (the home page) then
blocking can be used instead of non-blocking.
*/

extern BOOL HTNet_preemptive (HTNet * net);

/*
(
  The Request Object
)

The Request object is normally set up automatically
but can be changed at a later time.
*/

extern BOOL HTNet_setRequest (HTNet * net, HTRequest * request);
extern HTRequest * HTNet_request (HTNet * net);

/*
(
  The Protocol Object
)
*/

extern BOOL HTNet_setProtocol (HTNet * net, HTProtocol * protocol);
extern HTProtocol * HTNet_protocol (HTNet * net);

/*
(
  The Transport Object
)

The transport object is normally set up automatically
but can be changed at a later time.
*/

extern BOOL HTNet_setTransport (HTNet * net, HTTransport * tp);
extern HTTransport * HTNet_transport (HTNet * net);

/*
(
  The Channel Object
)
*/

extern BOOL HTNet_setChannel (HTNet * net, HTChannel * channel);
extern HTChannel * HTNet_channel (HTNet * net);

/*
(
  The Host Object
)
*/

extern BOOL HTNet_setHost (HTNet * net, HTHost * host);
extern HTHost * HTNet_host (HTNet * net);

/*
(
  The DNS Object
)

The DNS object keeps track of the DNS entries that we have already checked
out.
*/

extern BOOL HTNet_setDns (HTNet * net, HTdns * dns);
extern HTdns * HTNet_dns (HTNet * net);

/*
(
  Target for Input Read Stream
)
*/

extern HTStream * HTNet_readStream(HTNet * net);
extern BOOL HTNet_setReadStream (HTNet * net, HTStream * stream);

/*
(
  Should we count Raw bytes?
)

This functions can be used to determine whether bytes count should be managed
at the low level read stream or at a higher level. If the data transfer equals
the lifetime of a single document like for example in FTP or HTTP/1.0 then
this may be a reasonable thing to do.
*/
extern BOOL HTNet_setRawBytesCount (HTNet * net, BOOL mode);
extern BOOL HTNet_rawBytesCount (HTNet * net);

/*
*/

#endif /* HTNET_H */

/*

  

  @(#) $Id: HTNet.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTNetMan.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Private Net Definition


!
  Private Net Definition
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the private definition of the Net Class. Please look in the public
Net Class for more documentation

This module is implemented by HTNet.c, and it is a
part of the W3C Sample Code Library.
*/

#ifndef HTNETMAN_H
#define HTNETMAN_H
#include "HTNet.h"
#include "HTDNS.h"
#include "HTEvent.h"
#include "HTProt.h"

/*

The HTNet object is the core of the request queue management.
This object contains information about the socket descriptor, the input read
buffer etc. required to identify and service a request.
*/

struct _HTNet {
    int                 hash;                                  /* Hash value */

    /* Link to other objects */
    HTRequest *		request;		   /* Link to request object */
    HTHost *		host;	       /* What we know about the remote host */
    HTProtocol *	protocol;		 /* Protocol to this request */
    HTTransport *	transport;	       /* Transport for this request */
    int                 session;

    /* For progress notifications */
    BOOL		countRawBytes;	     /* If we should count raw bytes */
    long		bytesRead;			    /* Bytes in body */
    long		headerBytesRead;	     /* Bytes read in header */
    long		bytesWritten;		 /* Bytes written to network */
    long		headerBytesWritten;	  /* Bytes written in header */

#if 0
    int			retry;		     /* Counting attempts to connect */
    int 		home;			 /* Current home if multiple */
#endif

    time_t		connecttime;		 /* Used on multihomed hosts */
    BOOL		preemptive;  /* Eff result from Request and Protocol */

    HTEvent		event;
    HTStream *		readStream;    /* host's input stream puts data here */

    /* User specific stuff */
    void *		context;		/* Protocol Specific context */

    /* Eric's sleezoid cheat - should go to extra pipeline object */
    HTEventType		registeredFor;
};

extern SOCKET HTNet_socket(HTNet * me);


/*
.
  Bytes Read Stats
.
(
  Total Bytes Read
)
*/

#define HTNet_setBytesRead(me,l)	  ((me) ? (me->bytesRead=(l)) : -1)
#define HTNet_bytesRead(me)		  ((me) ? (me)->bytesRead : -1)
#define HTNet_addBytesRead(me,l)          ((me) ? (me->bytesRead+=(l)) : -1)

/*
(
  Header Bytes Read
)
*/

#define HTNet_setHeaderBytesRead(me,l)	  ((me) ? (me->headerBytesRead=(l)) :-1)
#define HTNet_headerBytesRead(me)	  ((me) ? (me)->headerBytesRead : -1)
#define HTNet_addHeaderBytesRead(me,l)    ((me) ? (me->headerBytesRead+=(l)) : -1)

/*
.
  Bytes Written Stats
.
(
  Total Bytes Written
)
*/

#define HTNet_setBytesWritten(me,l)	  ((me) ? (me->bytesWritten=(l)) :-1)
#define HTNet_bytesWritten(me)		  ((me) ? (me)->bytesWritten : -1)
#define HTNet_addBytesWritten(me,l)       ((me) ? (me->bytesWritten+=(l)) : -1)

/*
(
  Header Bytes Written
)
*/

#define HTNet_setHeaderBytesWritten(me,l) ((me) ? (me->headerBytesWritten=(l)) :-1)
#define HTNet_headerBytesWritten(me)  ((me) ? \
                                       ((me)->headerBytesWritten==0 ? \
                                        HTNet_bytesWritten(me) : \
                                        (me)->headerBytesWritten) : -1)
#define HTNet_addHeaderBytesWritten(me,l) ((me) ? (me->headerBytesWritten+=(l)) : -1)

/*
.
  Event Callbacks
.
*/

extern BOOL HTNet_setEventParam(HTNet * net, void * eventParam);
extern void* HTNet_eventParam(HTNet * net);
extern BOOL HTNet_setEventCallback(HTNet * net, HTEventCallback * cbf);
extern HTEventCallback * HTNet_eventCallback(HTNet * net);
extern BOOL HTNet_setEventPriority(HTNet * net, HTPriority priority);
extern HTPriority HTNet_eventPriority(HTNet * net);

/*
*/

#endif /* HTNETMAN_H */

/*

  

  @(#) $Id: HTNetMan.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTNetTxt.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library libwww CRLF Stripper Stream


!
  Network Telnet To Internal Character Text
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is a filter stream suitable for taking text from a socket and passing
it into a stream which expects text in the local C representation. It does
newline conversion. As usual, pass its output stream to it when creating
it.

This module is implemented by HTNetTxt.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTNETTXT_H
#define HTNETTXT_H

extern HTStream * HTNetToText (HTStream * target);

#endif

/*

  

  @(#) $Id: HTNetTxt.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTNews.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww NNTP State Machine


!
  NNTP State Machine
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the News/NNTP client module that handles all communication with
News/NNTP-servers.

This module is implemented by HTNews.c, and it is
a part of the W3C Sample Code
Library.
*/

#ifndef HTNEWS_H
#define HTNEWS_H
#include "HTProt.h"

/*

We define the max NNTP line as rather long as the result coming from a
XOVER command needs it. If the line is longer then it is chopped,
but we will almost have received the information we're looking for.
*/

#ifndef NEWS_PORT
#define NEWS_PORT		119			       /* See rfc977 */
#endif

#define MAX_NEWS_LINE		4096

extern HTProtCallback HTLoadNews;

/*
(
  Setting Number of Articles to Show
)

You can set the number of news articles to be shown at a time. If you set
the number to none (0) then all articles are shown
at once. This is also the default behavior.
*/
extern BOOL HTNews_setMaxArticles (int new_max);
extern int HTNews_maxArticles (void);

/*
*/

#endif /* HTNEWS_H */

/*

  

  @(#) $Id: HTNews.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTNewsLs.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww News/NNTP Listings


!
  News/NNTP Article and Group Listings
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module converts a generic News group listing
to a HTML object

This module is implemented by HTFTPDir.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTNEWSLS_H
#define HTNEWSLS_H
#include "HTStream.h"
#include "HTFormat.h"
#include "HTNet.h"

extern HTConverter HTNewsList, HTNewsGroup;

/*
(
  Newsgroup List Cache
)


The news list cache uses a URL tree to store the information
*/

HTNetBefore HTNewsCache_before;
HTNetAfter HTNewsCache_after;

/*
*/

#endif /* HTNEWSLS_H */

/*

  

  @(#) $Id: HTNewsLs.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTNewsRq.h
::::::::::::::
/*

					W3C Sample Code Library libwww NNTP REQUEST STREAM




!NNTP Request Stream!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The NNTP Request stream generates a NNTP request header and writes it
to the target which is normally a HTWriter stream.

This module is implemented by HTNewsRq.c, and
it is a part of the W3C
Sample Code Library.

*/

#ifndef HTNEWSREQ_H
#define HTNEWSREQ_H

#include "HTStream.h"
#include "HTAccess.h"

/*

(Streams Definition)

This stream makes a HTNews request header before it goes into
transparent mode.

*/

extern HTStream * HTNewsPost_new (HTRequest * request, HTStream * target);

#endif

/*



@(#) $Id: HTNewsRq.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $


*/
::::::::::::::
HTNoFree.h
::::::::::::::
/*

					W3C Sample Code Library libwww No Free Stream




!No Free Stream!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This stream is a throughline for all methods except FREE and
ABORT. This means that it can be use to put ahead of streams that you
don't want to be freed or aborted until you are redy to do it
yourself.

This module is implemented by HTNoFree.c, and
it is a part of the  W3C Sample
Code Library.

*/

#ifndef _HTNOFREE_H
#define _HTNOFREE_H

#include "HTStream.h"

extern HTStream * HTNoFreeStream_new (HTStream * target);

extern int HTNoFreeStream_delete (HTStream * me);

#endif /* HTNOFREE_H */

/*



@(#) $Id: HTNoFree.html,v 1.1.1.1 2005/07/06 09:34:02 gully Exp $


*/
::::::::::::::
HTParse.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww URI Management


!
  URI Management
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module contains code to parse URIs and various related things such as:
	 
	   o 
	     Parse a URI for tokens
  o 
	     Canonicalization of URIs
  o 
	     Search a URI for illegal characters in order to prevent
    security holes

	 
This module is implemented by HTParse.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTPARSE_H
#define HTPARSE_H

#include "HTEscape.h"

/*
.
  Parsing URIs
.

These functions can be used to get information in a URI.
(
  Parse a URI relative to another URI
)

This returns those parts of a name which are given (and requested) substituting
bits from the related name where necessary. The aName argument
is the (possibly relative) URI to be parsed, the relatedName
is the URI which the aName is to be parsed relative to. Passing
an empty string means that the aName is an absolute URI. The
following are flag bits which may be OR'ed together to form a number to give
the 'wanted' argument to HTParse. As an example we have the URL:
"/TheProject.html#news"
*/

#define PARSE_ACCESS		16	/* Access scheme, e.g. "HTTP" */
#define PARSE_HOST		 8	/* Host name, e.g. "www.w3.org" */
#define PARSE_PATH		 4	/* URL Path, e.g. "pub/WWW/TheProject.html" */

#define PARSE_VIEW               2      /* Fragment identifier, e.g. "news" */
#define PARSE_FRAGMENT           PARSE_VIEW
#define PARSE_ANCHOR		 PARSE_VIEW

#define PARSE_PUNCTUATION	 1	/* Include delimiters, e.g, "/" and ":" */
#define PARSE_ALL		31

/*

where the format of a URI is as follows: "ACCESS :// HOST / PATH #
ANCHOR"

PUNCTUATION means any delimiter like '/', ':', '#' between the
tokens above. The string returned by the function must be freed by the caller.
*/

extern char * HTParse  (const char * aName, const char * relatedName,
			int wanted);

/*
(
  Create a Relative (Partial) URI
)

This function creates and returns a string which gives an expression of one
address as related to another. Where there is no relation, an absolute address
is retured.

  
    On entry,
  
    Both names must be absolute, fully qualified names of nodes (no anchor bits)
  
    On exit,
  
    The return result points to a newly allocated name which, if parsed by HTParse
    relative to relatedName, will yield aName. The caller is responsible for
    freeing the resulting name later.

*/

extern char * HTRelative (const char * aName, const char *relatedName);

/*
.
  Is a URL Relative or Absolute?
.

Search the URL and determine whether it is a relative or absolute URL. We
check to see if there is a ":" before any "/", "?", and "#". If this is the
case then we say it is absolute. Otherwise we say it is relative.
*/

extern BOOL HTURL_isAbsolute (const char * url);

/*
.
  URL Canonicalization
.

Canonicalization of URIs is a difficult job, but it saves a lot of down loads
and double entries in the cache if we do a good job. A URI is allowed to
contain the seqeunce xxx/../ which may be replaced by "" , and the seqeunce
"/./" which may be replaced by "/". Simplification helps us recognize duplicate
URIs. Thus, the following transformations are done:
	 
	   o 
	     /etc/junk/../fred becomes /etc/fred
	   o 
	     /etc/junk/./fred becomes /etc/junk/fred
	 
	 
but we should NOT change
	 
	   o 
	     http://fred.xxx.edu/../.. or
	   o 
	     ../../albert.html
	 
	 
In the same manner, the following prefixed are preserved:
	 
	   o 
	     ./<etc>
	   o 
	     //<etc>
	 
	 
In order to avoid empty URIs the following URIs become:
	 
	   o 
	     /fred/.. becomes /fred/..
	   o 
	     /fred/././.. becomes /fred/..
	   o 
	     /fred/.././junk/.././ becomes /fred/..
	 
	 
If more than one set of `://' is found (several proxies in cascade) then
only the part after the last `://' is simplified.
*/

extern char *HTSimplify (char **filename);

/*
.
  Prevent Security Holes
.

In many telnet like protocols, it can be very dangerous to allow a full ASCII
character set to be in a URI. Therefore we have to strip them out.
HTCleanTelnetString() makes sure that the given string doesn't
contain characters that could cause security holes, such as newlines in ftp,
gopher, news or telnet URLs; more specifically: allows everything between
hexadesimal ASCII 20-7E, and also A0-FE, inclusive.

  
    str
  
    the string that is *modified* if necessary. The string will be truncated
    at the first illegal character that is encountered.
  
    returns
  
    YES, if the string was modified. NO, otherwise.

*/

extern BOOL HTCleanTelnetString (char * str);

/*
*/

#endif	/* HTPARSE_H */

/*

  

  @(#) $Id: HTParse.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTPEP.h
::::::::::::::
/*


  					W3C Sample Code Library libwww PEP Engine


!
  PEP Engine
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The PEP Manager is a registry for PEP Protocols that follow
the generic syntax defined by the HTTP PEP
protocol headers. All PEP Protocols are registered at run-time
in form of a PEP Module. A PEP Module consists of the following:

  
    protocol
  
    The name which is used to identify the protocol.
  
    BEFORE Filter
  
    When a new request is issued, the PEP Manager looks in the URL tree
    to see if we have any PEP information for this particular request. The search
    is based on the realm (if known) in which the request belongs and the URL
    itself. If a record is found then the PEP Manager calls the PEP
    Module in order to generate the PEP protocol headers.
  
    AFTER Filter
  
    After a request has terminated and the result was lack of required PEP protocol
    headers, the request should normally be repeated with a new set of PEP protocol
    headers. The AFTER filter is responsible for extracting the challenge from
    the HTTP response and store it in the URL tree, so that we next time we request
    the same URL we know that it is protected and we can ask the user for the
    appropriate PRP protocol headers.
  
    garbage collection
  
    The PEP information is stored in a URL Tree but
    as it doesn't know the format of the protocol specific parts, you must register
    a garbage collector (gc). The gc is called when node is deleted in the tree.


Note: The PEP Manager itself consists of BEFORE and
an AFTER filter - just like the PEP
Modules. This means that any PEP Module also can be registered
directly as a BEFORE and AFTER
filter by the Net Manager.
The reason for having the two layer model is that the PEP Manager
maintains a single URL tree for storing PEP
information for all PEP Protocols.

A PEP Module has three resources, it can use when creating PEP protocol
headers:
	 
	   o 
	     Handle the PEP protocol headers send from the remote party (typically
    in the form of a HTTP response.
  o 
	     Handle the PEP protocol headers which typically are to part of the
    next request.
  o 
	     Add information to the URL Tree

	 
This module is implemented by HTPEP.c (get it?), and
it is a part of the  W3C Sample Code
Library.
*/

#ifndef HTPEP_H
#define HTPEP_H
#include "HTList.h"
#include "HTReq.h"
#include "HTUTree.h"

typedef struct _HTPEPModule HTPEPModule;

/*
.
  PEP Module Registration
.

A PEP Protocol is registered by registering an PEP Module to
in the PEP Manager.
(
  Add a PEP Module
)

You can add a PEP protocol by using the following method. Each of the callback
function must have the type as defined below.
*/

extern HTPEPModule * HTPEP_newModule(const char *	protocol,
				     HTNetBefore *	before,
			             HTNetAfter *	after,
				     HTUTree_gc *	gc);

/*
(
  Find a PEP Module
)
*/
extern HTPEPModule * HTPEP_findModule (const char * protocol);

/*
(
  Delete a PEP Module
)
*/
extern BOOL HTPEP_deleteModule (const char * protocol);

/*
(
  Delete ALL PEP modules
)
*/
extern BOOL HTPEP_deleteAllModules (void);

/*
.
  Handling the URL Tree
.

The PEP information is stored as URL Trees. &nbsp;The
root of a URL Tree is identified by a hostname and a port number.
Each URL Tree contains a set of templates and realms which can be used to
predict what information to use in a hierarchical tree.

The URL trees are automatically collected after some time so the application
does not have to worry about freeing the trees. When a node in a tree is
freed, the gc registered as part of the PEP Module is called.

Server applications can have different PEP setups for each hostname and port
number, they control. For example, a server with interfaces
"www.foo.com" and "internal.foo.com" can have different
protection setups for each interface.
(
  Add information to the Database
)

Add a PEP information node to the database. If the entry is already found
then it is replaced with the new one. The template must follow normal URI
syntax but can include a wildcard Return YES if added (or replaced), else
NO
*/
extern HTPEPModule * HTPEP_findModule (const char * name);

/*
.
  The PEP Manager Filters
.

As mentioned, the PEP Manager is itself a set of
filters that can be registered by the
Net manager.
*/

extern HTNetBefore HTPEP_beforeFilter;
extern HTNetAfter  HTPEP_afterFilter;

/*
*/

#endif	/* NOT HTPEP_H */

/*

  

  @(#) $Id: HTPEP.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTPlain.h
::::::::::::::
/*

					W3C Sample Code Library libwww PLAIN TEXT STREAM




!Plain text object!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is implemented by HTPlain.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTPLAIN_H
#define HTPLAIN_H

#include "HTFormat.h"

extern HTConverter HTPlainPresent;

#endif

/*



@(#) $Id: HTPlain.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $


*/
::::::::::::::
HTProfil.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Default Initialization


!
  Application Profiles
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

As mentioned in the Library Architecture,
libwww consists of a small core and a large set of hooks for adding
functionality. By itself, the core it not capable of performing any Web related
tasks like accessing a HTTP server or parsing a HTML document. All this
functionality must be registered by the application. This way, the core of
libwww is kept application independent and can be used as the basic building
block for any kind of Web application.

The Library comes with a large set of default functions, for example for
accessing HTTP and FTP servers, parsing
RFC
822 headers etc. but it must all be registered by the application before
the core knows about it. You can either register the parts directly through
the many initialization functions in the Initialization Interface or you
can use these "precompiled" profiles which are set up to contain the featuers
often used by the a specific type of application, for example a client, a
server, a robot etc.

This module helps the application programmer setting up all this functionality,
but it is important to note that none of it is required in order to
use the Library. All the profiles declared below superseed the Library core
initialization function HTLibInit() which is defined in the
HTLib module.

This module is implemented by HTProfil.c, and it
is a part of the W3C Sample Code
Library. You can also have a look at the other
Initialization modules.
*/

#ifndef HTPROF_H
#define HTPROF_H
#include "WWWLib.h"
#include "WWWInit.h"

/*
.
  Client Application Profiles
.

We have a couple of different client application profiles suited to different
types of clients.
(
  Traditional Client Application
)

The first uses a non-blocking socket interface which enables the application
to perform multiple requests simultanously - in everyday words called
pseudo-threads. Besides that this profile contains typical filters for handling
redirection, authentication, logging, and proxy servers.
*/

extern void HTProfile_newClient (
	const char * AppName,
	const char * AppVersion);

/*
(
  Simple HTML Client
)

As above but furthermore contains the default libwww
HTML parser
*/

extern void HTProfile_newHTMLClient (
	const char * AppName,
	const char * AppVersion);

/*
(
  Client without a Persistent Cache
)

This is the same as above except that it doesn't start the persistent cache.
*/

extern void HTProfile_newNoCacheClient (
	const char * AppName,
	const char * AppVersion);

/*
(
  Simple HTML Client without Persistent Cache
)

As above but furthermore contains the default libwww
HTML parser
*/

extern void HTProfile_newHTMLNoCacheClient (
	const char * AppName,
	const char * AppVersion);

/*
(
  Preemptive (Blocking) Client
)

Do not use preemptive profiles if you are doing PUT or
POST requests.

We also have a blocking (preemptive) version of the same client interface.
The difference is that this version uses traditional blocking sockets and
hence only one request can be performed at the same time.
*/

extern void HTProfile_newPreemptiveClient (
	const char * AppName,
	const char * AppVersion);

/*
.
  Robot Application Profile
.

The robot profile contains much of the same functionality as the client,
but it does contain less filters. For example, robots are normally not interested
in performing automatic redirections or access authentication, and hence
this is not part of the robot profile.
*/

extern void HTProfile_newRobot (
	const char * AppName,
	const char * AppVersion);

/*

Do not use preemptive profiles if you are doing PUT or
POST requests.

As for the client interfacem we also have a blocking (preemptive) version
of the same interface. The difference is that this version uses traditional
blocking sockets and hence only one reques can be performed at the same time.
*/

extern void HTProfile_newPreemptiveRobot (
	const char * AppName,
	const char * AppVersion);

/*
.
  Delete a Profile
.

This is a generic profile cleanup that should be used on all the profiles
above. This will clean up the memory allocated by the profile and by the
Library core itself. After calling this you can not call any Library function
again. This call also supersedes the termination function for the Library
core, HTLibTerminate() so that you don't have to call that after
calling this function.
*/
extern void HTProfile_delete (void);

/*
*/

#endif

/*

  

  @(#) $Id: HTProfil.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTProt.h
::::::::::::::

/*



					W3C Sample Code Library libwww Protocol Class



!The Protocol Class!
*/
/*
**        (c) COPYRIGHT MIT 1995.
**        Please first read the full copyright statement in the file COPYRIGH.
*/
/*

The Protocol class defines an application level protocol (HTTP, FTP,
Gopher, etc.) to be used by libwww. Note that access to the local file system
also is considered to be an appliaction level protocol treated identically to
for example the HTTP protocol.

The Protocol class does only know about the application layer protocol and
it relies on the Transport Class to do the actualt
communication with the network, the local file system etc. The protocol class
defines an access method for both a client and a server. A typical client
application would probably only want to use the client method and a server
only the server method. However, any application can use both which allows it
to seemlessly to change between server and client profile as needed.

All protocol modules are dynamically bound to an access scheme. Take for
example the address http://www.w3.org which has the access scheme
http and if we have a protocol module capable of handling HTTP then we
can make the binding between http and this module. As mentioned in the
introduction to this chapter, the Library already comes with a large set of
protocol module, including HTTP so all we have to do in this case is to
register the HTTP module to the Library as being capable of handling
http URLs.

Libwww comes with a default set of protocols including the ones mentioned
above which can be initiated using the function HTProtocolInit()
in HTInit module

One special case is the support for access to WAIS
databases. WAIS has its own code Library
called freeWAIS which is required in order
to directly access wais URLs. We shall not describe in describe in detail here
how this can be enabled as it is described in the WWW-WAIS gateway.

This module is implemented by HTProt.c, and it is a
part of the  W3C Sample Code
Library.
*/
#ifndef HTPROT_H
#define HTPROT_H

typedef struct _HTProtocol HTProtocol;
typedef u_short HTProtocolId;

#include "HTReq.h"
#include "HTAnchor.h"
#include "HTEvent.h"
#include "HTTrans.h"
/*

An access scheme module takes as a parameter a socket (which is an invalid
socket the first time the function is called), a request structure containing details of the request,
and the action by which the (valid) socket was selected in the event loop.
When the protocol class routine is called, the anchor element in the request
is already valid (made valid by HTAccess).

.Creation and Deletion Methods.

(Add an Protocol)

This functions registers a protocol module and binds it to a specific
access acheme (the part before the first colon in a URL). For example, the
HTTP &nbsp;client module is bound to http URLs. The callback function is the
function to be called for loading.
*/
typedef int HTProtCallback (SOCKET, HTRequest *);

extern BOOL HTProtocol_add (const char *               name,
                            const char *        transport,
                            HTProtocolId        port,
                            BOOL                preemptive,
                            HTProtCallback *        client,
                            HTProtCallback *        server);
/*

(Delete a Protocol)

This functions deletes a registered protocol module so that it can not be
used for accessing a resource anymore.
*/
extern BOOL HTProtocol_delete (const char * name);
/*

(Remove ALL Registered Protocols)

This is the garbage collection function. It is called by HTLibTerminate()
*/
extern BOOL HTProtocol_deleteAll (void);
/*

.Protocol Class Methods.

(Find a Protocol Object)

You can search the list of registered protocol objects as a function of the
access acheme. If an access scheme is found then the protocol object is
returned.
*/
extern HTProtocol * HTProtocol_find (HTRequest * request, const char * access);
/*

(Get the callback functions)

You can get the callback functions registered together with a protocol
object using the following methods.
*/
extern HTProtCallback * HTProtocol_client (HTProtocol * protocol);
extern HTProtCallback * HTProtocol_server (HTProtocol * protocol);
/*

(Get the default Protocol ID)

Each protocol is registered with a default protocol ID which is the default
port number that this protocol is using. In the case of FTP it is 21, for
HTTP, it is 80 and for NNTP it is 119.
*/
extern HTProtocolId HTProtocol_id (HTProtocol * protocol);
/*

(Get the Protocol Name)

Get the protocol name that was registered when the protocol object was
created
*/
extern const char * HTProtocol_name (HTProtocol * protocol);
/*

(Is Access Scheme Preemptive)

Returns YES if the implementation of the access scheme supports preemptive
access only.
*/
extern BOOL HTProtocol_preemptive (HTProtocol * protocol);
/*

(Binding to the Transport Class)

An application protocol is registered together with a transport protocol in order to communicate with the
thansport layer.
*/
extern BOOL HTProtocol_setTransport (HTProtocol * protoccol,
                                     const char * transport);
extern const char * HTProtocol_transport (HTProtocol * protocol);
/*
*/
#endif /* HTPROT_H */
/*





@(#) $Id: HTProt.html,v 2.25 1999/12/01 13:07:07 kahan Exp $ 

*/
::::::::::::::
HTProxy.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Proxies and Gateways


!
  Proxy and gateway Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module keeps a list of proxies and gateways to be contacted on a request
in stead of requesting it directly from the origin server. The module replaces
the old system of environment variables for gateways and proxies. However
for backward compatibility there is a function that reads the environment
variables at start up. Note that there is a difference between a proxy and
a gateway - the difference is the way the URL is set up in the
RequestLine of the HTTP request. If the original, full URL looks
like "http://www.w3.org/test.html" then the result will for
a proxy is "http://www.w3.org/test.html" and a gateway
"/www.w3.org/test.html"

The module is implemented by HTProxy.c, and it is
a part of the  W3C Sample Code
Library.
*/
#ifndef HTPROXY_H
#define HTPROXY_H

#include "HTList.h"

/*
.
  Registering a Proxy Server
.

A proxy server is registered with a corresponding access method, for example
http, ftp etc. The `proxy' parameter should be a fully
valid name, like http://proxy.w3.org:8001 but domain name is
not required. If an entry exists for this access then delete it and use the
new one.
*/

extern BOOL HTProxy_add		(const char * access, const char * proxy);

/*
(
  Registering a Proxy Using Regular Expressions
)

Registers a proxy as the server to contact for any URL matching the regular
expression. This requires that you have compiled with the
HT_POSIX_REGEX flag, see the installation
instructions. If you call this function without having compiled with
the HT_POSIX_REGEX flag then you will essentially get the non-regex
version.&nbsp;The name of the proxy should be a fully valid URL, like
"http://proxy.w3.org:8001". Returns YES if OK, else NO
*/

extern BOOL HTProxy_addRegex (const char * regex,
                              const char * proxy,
                              int regex_flags);

/*
(
  Deleting All Registered Proxies
)
*/

extern BOOL HTProxy_deleteAll	(void);

/*

The remove function removes all registered proxies. This is automatically
done in  HTLibTerminate() 
.
  Registering a No Proxy Location
.

The noproxy list is a list of host names and domain names where
we don't contact a proxy even though a proxy is in fact registered for this
particular access method . When registering a noproxy item, you
can specify a specific port for this access method in which case it isvalid
only for requests to this port. If `port' is '0' then it applies to all ports
and if `access' is NULL then it applies to to all access methods. Examples
of host names are w3.org and www.close.com
*/

extern BOOL HTNoProxy_add	(const char * host, const char * access,
				 unsigned port);

/*
(
  Registering a NoProxy Location Using Regular Expressions
)

Registers a regular expression where URIs matching this expression should
go directly and not via a proxy. Examples:
http://<star>\.w3\.org and
http://www\.noproxy\.com/<star> (I use
<star> in order not interfere with C comments) This requires
that you have compiled with the HT_POSIX_REGEX flag, see the
installation instructions. If you call this
function without having compiled with the HT_POSIX_REGEX flag then
you will essentially get the non-regex version.&nbsp;
*/

extern BOOL HTNoProxy_addRegex (const char * regex, int regex_flags);

/*
(
  Delete all Noproxy Destinations
)
*/

extern BOOL HTNoProxy_deleteAll	(void);

/*

The remove function removes all entries in the list. This is automatically
done in  HTLibTerminate()
(
  Inverse the meaning of the NoProxy list
)

Allows to change the value of a flag so that the NoProxy list is interpreted
as if it were an OnlyProxy list.
*/

extern int  HTProxy_NoProxyIsOnlyProxy (void);
extern void HTProxy_setNoProxyIsOnlyProxy (int value);

/*
.
  Look for a Proxy server
.

This function evaluates the lists of registered proxies and if one is found
for the actual access method and it is not registered in the `noproxy' list,
then a URL containing the host to be contacted is returned to the caller.
This string must be freed be the caller.
*/

extern char * HTProxy_find	(const char * url);

/*
.
  Registering a gateway
.

A gateway is registered with a corresponding access method, for example
http, ftp etc. The `gate' parameter should be a fully valid
name, like http://gateway.w3.org:8001 but domain name is not
required. If an entry exists for this access then delete it and use the new
one.
*/

extern BOOL HTGateway_add	(const char * access, const char * gate);
extern BOOL HTGateway_deleteAll	(void);

/*

The remove function removes all registered proxies. This is automatically
done in  HTLibTerminate()
.
  Look for a Gateway
.

This function evaluates the lists of registered gateways and if one is found
for the actual access method then it is returned and must be freed by the
caller.
*/

extern char * HTGateway_find	(const char * url);

/*
.
  Backwards Compability with Environment Variables
.

This function maintains backwards compatibility with the old environment
variables and searches for the most common values: http, ftp, news, wais,
and gopher
*/

extern void HTProxy_getEnvVar	(void);

/*
*/

#endif /* HTPROXY_H */

/*

  

  @(#) $Id: HTProxy.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTRDF.h
::::::::::::::
/*

  					W3C Sample Code Library libwww RDF Parser


!
  RDF Parser Based on Expat and SiRPAC
!

Written and integrated into libwww by John Punin - thanks!

This module is implemented by HTRDF.c, and is a part
of the  W3C Sample Code Library.

This RDF parser is based on Janne Saarela's Java based
SiRPAC and
James Clark's expat XML
parser which isincluded in the libwww CVS code base where I compile is
as one library: libexpat.a.
See the external modules that libwww works with
for details.
*/

#ifndef HTRDF_H
#define HTRDF_H

#include "HTHash.h"

#define RDFMS "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
#define RDFSCHEMA "http://www.w3.org/TR/WD-rdf-schema#"
#define XMLSCHEMA "xml"

/*
.
  RDF Triple Class
.
*/

typedef struct _HTTriple HTTriple;

extern HTTriple * HTTriple_new (char * p, char * s, char * o);
extern BOOL HTTriple_delete (HTTriple * me);
extern void HTTriple_print (HTTriple * me);
extern char * HTTriple_subject (HTTriple * me);
extern char * HTTriple_predicate (HTTriple * me);
extern char * HTTriple_object (HTTriple * me);

/*
.
  RDF Element Class
.
*/

typedef struct _HTElement HTElement;

extern HTElement * HTElement_new (char * sName, HTAssocList * al);
extern HTElement * HTElement_new2 (char * sContent);
extern BOOL HTElement_addData (HTElement *me, char * sContent);
extern BOOL HTElement_delete (HTElement * me);
extern BOOL HTElement_addChild (HTElement * me, HTElement * element);
extern BOOL HTElement_addAttribute (HTElement * me, char * sName, char * sValue);
extern BOOL HTElement_removeAttribute (HTElement * me, char * sName);
extern char * HTElement_getAttribute (HTElement * me, char * sName);
extern char * HTElement_getAttribute2 (HTElement * me, char * sNamespace, char * sName);
extern BOOL HTElement_addTarget (HTElement * me, HTElement * element);
extern HTElement * HTElement_target (HTElement * me);
extern BOOL HTElement_instanceOfData (HTElement * me);

/*
.
  RDF Parser & Compiler Definition
.

These methods create and deletes an RDF Parser/Compiler (SIRPAC)
(
  Create and Delete Parser Instance
)
*/

typedef struct _HTRDFParser HTRDF;

extern HTRDF * HTRDF_new (void);
extern BOOL HTRDF_delete (HTRDF * me);

/*
(
  Callback Handler Announcing a new RDF Parser Object
)

When a RDF parser object is created, the stream
checks to see if there are any callbacks registered which should be notified
about the new stream instance. If that is the case then this callback is
called and a pointer to the RDF parser passed along. The output stream is
the target that was originally set for the request object before the request
was issued.
*/

typedef void HTRDFCallback_new (
	HTStream *		me,
	HTRequest *		request,
	HTFormat 		target_format,
	HTStream *		target_stream,
	HTRDF *                 rdfparser,
	void *                  context);

/*

  Register RDF Parser Creation Notification Callback


@@@Should be handled via XML names spaces@@@
*/

extern BOOL HTRDF_registerNewParserCallback (HTRDFCallback_new *, void * context);

/*
(
  Callback Handler Announcing a new RDF Triple
)

Handler announcing that a new triple has been generated.
*/

typedef void HTTripleCallback_new (
	HTRDF *		rdfp,
	HTTriple *	t,
	void *		context);

/*

  Register RDF Triple Creation Notification Callback

*/

extern BOOL HTRDF_registerNewTripleCallback (
	HTRDF *			me,
	HTTripleCallback_new * 	cbf,
	void * 			context);

/*
(
  Set Address
)

Saves the name of the source document for later inspection if needed
*/

extern BOOL HTRDF_setSource (HTRDF * me, char * source);

/*
(
  Resolve Symbolic References
)

Go through the m_vResolveQueue and assign direct object reference for each
symbolic reference
*/

extern BOOL HTRDF_resolve(HTRDF *me);

/*
(
  Find Suitable Start Element
)

Given an XML document (well-formed HTML, for example), look for a suitable
element to start parsing from
*/

extern BOOL HTRDF_processXML(HTRDF *me, HTElement *root);

/*
(
  Return the root element pointer.
)

This requires the parsing has been already done.
*/

extern HTElement * HTRDF_root(HTRDF *me);

/*
(
  Return the full namespace URI for a given prefix sPrefix.
)

The default namespace is identified with xmlns prefix. The namespace of xmlns
attribute is an empty string.
*/

extern char * HTRDF_namespace (HTRDF * me, char * sPrefix);

/*
(
  Parsing Literal or Resource?
)

Methods to determine whether we are parsing parseType="Literal" or
parseType="Resource"
*/

extern BOOL HTRDF_parseLiteral(HTRDF *me);
extern BOOL HTRDF_parseResource(HTRDF *me);

/*
(
  Resolve Later
)

Add the element e to the m_vResolveQueue to be resolved later.
*/

extern void HTRDF_resolveLater(HTRDF *me,HTElement *e);

/*
(
  Register ID
)

Add an element e to the Hashtable m_hIDtable which stores all nodes with
an ID
*/

extern void HTRDF_registerID(HTRDF *me, char * sID,HTElement *e);

/*
(
  Register Resource
)

Add an element e to the Vector m_vResources which stores all nodes with an
URI
*/

extern void HTRDF_registerResource(HTRDF *me,HTElement *e);

/*
(
  Look for Node
)

Look for a node by name sID from the Hashtable m_hIDtable of all registered
IDs.
*/

extern HTElement *HTRDF_lookforNode(HTRDF *me, char * sID);

/*
(
  If Element from RDF Schema?
)

Check if the element e is from the namespace of the RDF schema by comparing
only the beginning of the expanded element name with the canonical RDFMS
URI
*/

extern BOOL HTRDF_isRDF(HTRDF *me, HTElement *ele);
extern BOOL HTRDF_isRDFroot(HTRDF *me, HTElement *ele);

/*
(
  Is the element a Description?
)
*/

extern BOOL HTRDF_isDescription(HTRDF *me, HTElement *ele);

/*
(
  Is the element a Predicate? 
)

This method matches all properties but those from RDF namespace
*/

extern BOOL HTRDF_isTypedPredicate(HTRDF *me, HTElement *e);

/*
(
  Is the element a Container?
)
*/

extern BOOL HTRDF_isContainer(HTRDF *me, HTElement *e);

/*
(
  Is the element a Bag?
)
*/

extern BOOL HTRDF_isBag(HTRDF *me, HTElement *e);

/*
(
  Is the element an Alternative?
)
*/

extern BOOL HTRDF_isAlternative(HTRDF *me, HTElement *e);

/*
(
  Is the element a Sequence?
)
*/

extern BOOL HTRDF_isSequence(HTRDF *me, HTElement *e);

/*
(
  Is the element a ListItem?
)
*/

extern BOOL HTRDF_isListItem (HTRDF *me, HTElement *e);

/*
(
  Start processing an RDF/XML document instance from the root element rdf.
)
*/

extern BOOL HTRDF_processRDF(HTRDF *me, HTElement *ele);

/*

processDescription manages Description elements

  
    description
  
    The Description element itself
  
    inPredicate
  
    Is this is a nested description
  
    reificate
  
    Do we need to reificate
  
    createBag
  
    Do we create a bag container
  
    return
  
    An ID for the description

*/

extern char * HTRDF_processDescription (
	HTRDF *		me,
	HTElement *	description,
	BOOL		inPredicate,
	BOOL		reificate,
	BOOL		createBag);

/*
(
  Manage the typedNode production in the RDF grammar.
)
*/

extern char * HTRDF_processTypedNode(HTRDF *me, HTElement *e);

/*
(
  Special method to deal with rdf:resource attribute
)
*/

extern char * HTRDF_getResource(HTRDF *me,HTElement *e);

/*
(
  Create a new reification ID
)

Using a name part and an incremental counter m_iReificationCounter.
*/

extern char * HTRDF_newReificationID (HTRDF *me);

/*
(
  Create a new triple
)

and add it to the m_triples List
*/

extern void HTRDF_addTriple (HTRDF *me, char * sPredicate, char * sSubject,
			     char * sObject);

/*
(
  Create New Bag
)

allows one to determine whether SiRPAC produces Bag instances for each
Description block. The default setting is not to generate them.
*/

extern void HTRDF_createBags (HTRDF *me, BOOL b);

/*
(
  Set Output Stream
)

Set output stream for RDF parser
*/

extern void HTRDF_setOutputStream (HTRDF *me, HTStream *ostream);

/*
.
  RDF Converter Streams
.

A set of converter streams using the
HTRDF Parser object
(
  RDF To Triple Converter
)

This stream converter converts an RDF stream to triples that are passed to
the application using the new triples callback
handler. The RDF object itself can be obtained using the
new RDF parser object callback
*/

extern HTConverter HTRDFParser_new;

/*
(
  Print RDF Triple Converter
)

This stream converter converts an RDF stream to triples and sends them downstrem
as (predicate, subject, object). This can for example be used to
print them out to stdout etc.
*/

extern HTConverter HTRDFToTriples;

/*

(
  Parse a file of RDF
)

This function parses a file of RDF in a synchronous, non-blocking
way.  In other words, the file is not asynchronously loaded.  

If new_triple_callback is NULL, the default triple handler is 
invoked.  The context pointer will be available in the triple
callback function. 

Returns YES if the file is successfully parsed; otherwise NO is
returned and an error message is logged. 
*/

extern BOOL HTRDF_parseFile (const char *file_name, 
                             HTTripleCallback_new * new_triple_callback,
                             void *context);

/*
(
  Parse a buffer of RDF
)

This function parses a buffer of RDF in a synchronous, non-blocking way.  

If new_triple_callback is NULL, the default triple handler is 
invoked.  The context pointer will be available in the triple
callback function. 

Returns YES if the buffer is successfully parsed; otherwise NO is
returned and an error message is logged. 
*/

extern BOOL HTRDF_parseBuffer (const char *buffer, 
		               const char *buffer_name, 
                               int buffer_len, 
                               HTTripleCallback_new * new_triple_callback,
                               void *context);

/*

*/

#endif

/*

  

  @(#) $Id: HTRDF.html,v 1.1.1.1 2005/07/06 09:34:02 gully Exp $

*/





::::::::::::::
HTReader.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library Socket Reader Stream


!
  Socket Reader Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Socket Reader Stream is an input stream
&nbsp;which knows how to read from&nbsp;a BSD type socket. It is part
of the Transport interface and may be registered
as part of a Transport Object. The application
can&nbsp;initialize this stream together with the
HTWriter stream, for example. In the
default initialization module, you can find the
HTTransportInit() function which sets up this stream as a default
transport for handling socket read operations.

This module is implemented by HTReader.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTREADER_H
#define HTREADER_H

#include "HTIOStream.h"

/*
.
  Input Buffering
.

In order to optimize reading a channel, we bind a buffer to each channel
object. The size of this buffer is a compromise between speed and memory.
Here it is chosen as the default TCP High Water Mark (sb_hiwat) for receiving
data. By default, we have chosen a value that equals the normal TCP High
Water Mark (sb_hiwat) for receiving data.
*/

#define INPUT_BUFFER_SIZE    32*1024

/*
.
  Read Stream
.
*/

extern HTInput_new HTReader_new;

/*
*/

#endif

/*

  

  @(#) $Id: HTReader.html,v 1.1.1.1 1998/08/14 21:54:38 cvs Exp $

*/
::::::::::::::
HTReq.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Request Class


!
  The Request Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Libwww is based on a request/response paradigm and the Request class defines
"an operation to be performed on a URL". The request object is the
main entry point for an application to issue a request to the Library - all
operations on a URL must use a Request object. The request object
is application independent in that both servers and clients use the same
Request class. Examples of requests passed to the Library are a client
application issuing a GET request on a HTTP URL, or a server issuing
a load on a local file URL. The only difference is that the client gets the
input from a user whereas the server gets the input via the network.

A request object is created with a default set of parameters which are applicable
for many URL requests but the class defines a huge set of methods that an
be used to customize a request for a particular purpose. Example of things
that you can define is natural language, media types, what RFC 822 headers
to use, whether the request should be refreshed from cache etc. Scroll down
and see the set of parameters you can tune.

A request object is registered in the library by issuing an operation on
a URL - for example PUT, POST, or DELETE. You can find
many higher level "request issuing functions" in the
Access module - the methods defined by the Request
class itself are very low level but can of course be used directly if needed.

Whereas the lifetime of the URL (in form of an anchor) often is very long
(for example as long as the application is running), the lifetime of a request
is limited to the time it takes to service the request. The core does not
automatically delete any request object created by the application - it is
for the application to do. In many cases a request object can be deleted
when any of the termination callback functions
are called but the application may keep request objects around longer than
that

The Library can accept an unlimited number of simultaneous requests passed
by the application. One of the main functions of the Library core is to handle
any number of ongoing requests in an intelligent manner by limiting the number
of active request to the fit the available resources as defined by the
application. This is described in more detail in the HTNet
module.

This module is implemented by HTReqMan.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTREQ_H
#define HTREQ_H

typedef long HTRequestID;
typedef struct _HTRequest HTRequest;

#include "HTEvent.h"
#include "HTList.h"
#include "HTAssoc.h"
#include "HTFormat.h"
#include "HTStream.h"
#include "HTError.h"
#include "HTNet.h"
#include "HTUser.h"
#include "HTResponse.h"

/*
.
  Creation and Deletion Methods
.

The request object is intended to live as long as the request is still active,
but can be deleted as soon as it has terminated, for example in one of the
request termination callback functions as described in the
Net Manager. Only the anchor object stays around
after the request itself is terminated.
(
  Create new Object
)

Creates a new request object with a default set of options -- in most cases
it will need some information added which can be done using the methods in
this module, but it will work as is for a simple request.
*/

extern HTRequest * HTRequest_new (void);

/*
(
  Clear a Request Object
)

Clears all protocol specific information so that the request object can be
used for another request. It should be used with care as application specific
information is not re-initialized. Returns YES if OK, else NO.
*/

extern BOOL HTRequest_clear (HTRequest * me);

/*
(
  Create a duplicate
)

Creates a new HTRequest object as a duplicate of the src request. Returns
YES if OK, else NO
*/

extern HTRequest * HTRequest_dup (HTRequest * src);

/*

  Create a duplicate for Internal use


Creates a new HTRequest object as a duplicate of the src request. The difference
to the HTRequest_dup function is that we don't copy the error_stack and other
information that the application keeps in its copy of the request object.
Otherwise it will be freed multiple times. Returns YES if OK, else NO
*/

extern HTRequest * HTRequest_dupInternal (HTRequest * src);

extern BOOL HTRequest_setInternal (HTRequest * request, BOOL mode);
extern BOOL HTRequest_internal (HTRequest * request);

/*
(
  Delete Object
)

This function deletes the object and cleans up the memory.
*/

extern void HTRequest_delete (HTRequest * request);

/*
.
  Issuing a Request
.

These are the "basic request methods" provided directly by the Request
class. This is a very low level API as the caller must have set up the request
object before passing it to libwww. There are two versions: one for issuing
client requests and one for issuing server requests. You will probably most
often use the client version, but, in fact, libwww can also deal with incoming
connections. You can find many higher level issuing functions in the
HTAccess module. If you like, you can of course
use this directly!
*/

extern BOOL HTLoad (HTRequest * request, BOOL recursive);
extern BOOL HTServe(HTRequest * request, BOOL recursive);

/*
.
  Killing a Request
.

This function kills this particular request, see HTNet
module for a function that kills them all. If you know that you are
pipelining requests (typically the case for GUI browsers, robots etc.) then
it is often not enough to just kill a single request as the whole pipeline
gets affected. Therefore, in that case you MUST call the
HTHost_killPipe function instead,
*/

extern BOOL HTRequest_kill(HTRequest * request);

/*

Note that you can get to the HTHost object via the HTNet
object which you can get by calling
HTRequest_net(...).
.
  Relations to Other Libwww Objects
.

The Request object is linked to a set of other libwww objects - here's how
to get to these objects...
(
  Binding to an Anchor Object
)

Every request object has an anchor associated
with it. The anchor normally lives until the application terminates but a
request object only lives as long as the request is being serviced. If the
anchor that we have requested is a child anchor then we always load
the parent anchor; after the load jump to the location. A child anchor
is a an anchor which points to a subpart of the document (has a "#" in the
URL).
*/

extern void HTRequest_setAnchor (HTRequest *request, HTAnchor *anchor);
extern HTParentAnchor * HTRequest_anchor (HTRequest *request);

extern HTChildAnchor * HTRequest_childAnchor (HTRequest * request);

/*
(
  Binding to a User Profile
)

Each request is associated with a User profile
which contains information about the local host name, email address of the
user, news server etc. A request object is created with a default "generic
user" but can be assigned a specific user at any time.
*/

extern BOOL HTRequest_setUserProfile (HTRequest * request, HTUserProfile * up);
extern HTUserProfile * HTRequest_userProfile (HTRequest * request);

/*
(
  Binding to a Net Object
)

If a request is actually going on the net then the Net
Manager is contacted to handle the request. The Net manager creates a
HTNEt object and links it to the Request object. You can get to the HTNet
object using the following functions.
*/

extern HTNet * HTRequest_net (HTRequest * request);
extern BOOL HTRequest_setNet (HTRequest * request, HTNet * net);

/*

Note that you can go from the HTNet object to the
HTHost object by calling HTNet_host(...).
(
  Binding to a Response Object
)

If a request is actually going on the net and we are getting a response back
then we also create a HTResponse object and
bind it to the request object. Once we know what to do with the response,
we may transfer the information to the anchor object.
*/

extern HTResponse * HTRequest_response (HTRequest * request);
extern BOOL HTRequest_setResponse (HTRequest * request, HTResponse * response);

/*
.
  Set the Method for the Request
.

The Method is the operation to be executed on the requested object. The default
set if the set of operations defined by the HTTP protocol, that is "GET",
"HEAD", "PUT", "POST", "LINK", "UNLINK", and "DELETE" but many of these can
be used in other protocols as well. The important thing is to think of the
requested element as an object on which you want to perform an operation.
Then it is for the specific protocol implementation to try and carry this
operation out. However, not all operations can be implemented (or make sense)
in all protocols.

Methods are handled by the Method Module, and
the default value is "GET".
*/

extern void HTRequest_setMethod (HTRequest *request, HTMethod method);
extern HTMethod HTRequest_method (HTRequest *request);

/*
.
  Priority Management
.

The request can be assigned an initial priority which then gets inherited
by all HTNet objects and other requests objects
created as a result of this one. You can also assign a separate priority
to an indicidual HTNet object by using the methods in the
Net manager.
*/

extern HTPriority HTRequest_priority (HTRequest * request);
extern BOOL HTRequest_setPriority (HTRequest * request, HTPriority priority);

/*
.
  Pipelining Managament
.

Libwww supports HTTP/1.1 pipelining which greatly optimizes HTTP's behavior
over TCP. libwww also tries very hard to minimize the number of TCP packets
sent over the network. This is done by buffering outgoing requests until
either a minimum amount of data has been collected or a timeout causes a
flush to happen. The application can override the output buffering by explicit
request a request object to be flushed.
*/

extern BOOL HTRequest_setFlush (HTRequest * me, BOOL mode);
extern BOOL HTRequest_flush (HTRequest * me);

/*
(
  Force the Pipeline to be Flushed Immediately
)

Forcing a fluch immediatly is slightly different as this can be done in
"retrospect". That is, if suddenly the application decides on performing
a flush after the request was initiated then it can use this function to
flush at a later time.
*/

extern int HTRequest_forceFlush (HTRequest * request);

/*
.
  Dealing with Request Error Messages
.

Errors are, like almost anything,  kept in lists. An error list can be
associated with a request using the following functions. In order to make 
life easier, there are also some easy mapping functions to the
HTError object, so that you can add an error directly
to a request object.
*/

extern HTList * HTRequest_error (HTRequest * request);
extern void HTRequest_setError	(HTRequest * request, HTList * list);
extern void HTRequest_deleteAllErrors (HTRequest * request);

/*

These are the cover functions that go directly to the
Error Object
*/

extern BOOL HTRequest_addError (HTRequest * 	request,
				HTSeverity	severity,
				BOOL		ignore,
				int		element,
				void *		par,
				unsigned int	length,
				char *		where);

extern BOOL HTRequest_addSystemError (HTRequest * 	request,
				      HTSeverity 	severity,
				      int		errornumber,
				      BOOL		ignore,
				      char *		syscall);

/*
.
  Max number of Retrys for a Down Load
.

Automatic reload can happen in two situations:
	 
	   o 
	     The server sends a redirection response
	   o 
	     The document has expired
	 
	 
In order to avoid the Library going into an infinite loop, it is necessary
to keep track of the number of automatic reloads. Loops can occur if the
server has a reload to the same document or if the server sends back a Expires
header which has already expired. The default maximum number of automatic
reloads is 6.
*/

extern BOOL HTRequest_setMaxRetry (int newmax);
extern int  HTRequest_maxRetry (void);

extern int HTRequest_retrys (HTRequest * request);
extern BOOL HTRequest_doRetry (HTRequest *request);
extern BOOL HTRequest_addRetry (HTRequest * request);

extern int HTRequest_AAretrys (HTRequest * request);
extern BOOL HTRequest_addAARetry (HTRequest * request);

/*
.
  Set Max Forwards for TRACE methods
.

The TRACE method is used to invoke a remote, application-layer
loop-back of the request message. The final recipient of the request SHOULD
reflect the message received back to the client as the entity-body of a 200
(OK) response. The final recipient is either the origin server or the first
proxy or gateway to receive a Max-Forwards value of zero (0) in the request.
A TRACE request MUST NOT include an entity.
*/
extern BOOL HTRequest_setMaxForwards (HTRequest * request, int maxforwards);
extern int HTRequest_maxForwards (HTRequest * request);

/*
.
  Preemptive or Non-preemptive Access
.

An access scheme is defined with a default for using either preemptive (blocking
I/O) or non-preemptive (non-blocking I/O). This is basically a result of the
implementation of the protocol module itself. However, if non-blocking I/O
is the default then some times it is nice to be able to set the mode to blocking
instead. For example, when loading the first document (the home page),
blocking mode can be used instead of non-blocking.
*/

extern void HTRequest_setPreemptive (HTRequest *request, BOOL mode);
extern BOOL HTRequest_preemptive (HTRequest *request);

/*
.
  Content Negotiation
.

When accessing the local file system, the Library is capable of performing
content negotioation as described by the HTTP protocol. This is mainly for
server applications, but some client applications might also want to use
content negotiation when accessing the local file system. This method enables
or disables content negotiation - the default value is ON.
*/

extern void HTRequest_setNegotiation (HTRequest *request, BOOL mode);
extern BOOL HTRequest_negotiation (HTRequest *request);

/*
.
  Request Preconditions (HTTP If-* Headers)
.

Should this request use preconditions when doing a PUT or a
POST? These are the "if-*" header fields that can be used
to avoid version conflicts etc. The default is not to use any preconsitions
(HT_NO_MATCH). The _THIS versions use etags and/or time
stamps and the _ANY versions use the "*" header field value
of the if-match and if-non-match header fields.
*/
typedef enum _HTPreconditions {
    HT_NO_MATCH = 0,
    HT_MATCH_THIS,
    HT_MATCH_ANY,
    HT_DONT_MATCH_THIS,
    HT_DONT_MATCH_ANY
} HTPreconditions;

extern void HTRequest_setPreconditions (HTRequest * me, HTPreconditions mode);
extern HTPreconditions HTRequest_preconditions (HTRequest * me);

/*
.
  Local MIME header Parsers
.

MIMEParsers get their own type which is optimized for static and regex parser
strings.
*/

typedef struct _HTMIMEParseSet HTMIMEParseSet;
extern void HTRequest_setMIMEParseSet (HTRequest *request,
				       HTMIMEParseSet * parseSet, BOOL local);
extern HTMIMEParseSet * HTRequest_MIMEParseSet (HTRequest *request,
					      BOOL * pLocal);

/*
.
  Which Default Protocol Header Fields To Use?
.

Libwww supports a large set of headers that can be sent along with a request
(or a response for that matter). All headers can be either disabled or enabled
using bit flags that are defined in the following. See also the
section on how to extend the default set of supported header
fields.
(
  General HTTP Header Mask
)

There are a few header fields which have general applicability for both request
and response mesages, but which do not apply to the communication parties
or theentity being transferred. This mask enables and disables these headers.
If the bit is not turned on they are not sent.
*/

typedef enum _HTGnHd {
    HT_G_CC             = 0x1,
    HT_G_CONNECTION	= 0x2,
    HT_G_DATE		= 0x4,
    HT_G_PRAGMA_NO_CACHE= 0x8,
    HT_G_FORWARDED	= 0x10,
    HT_G_MESSAGE_ID	= 0x20,
    HT_G_MIME		= 0x40,
    HT_G_TRAILER        = 0x80,
    HT_G_TRANSFER       = 0x100,
    HT_G_EXTRA_HEADERS  = 0x200
} HTGnHd;

#define DEFAULT_GENERAL_HEADERS	\
        HT_G_CONNECTION + HT_G_CC + HT_G_TRANSFER + HT_G_TRAILER + \
        HT_G_EXTRA_HEADERS

extern void HTRequest_setGnHd (HTRequest *request, HTGnHd gnhd);
extern void HTRequest_addGnHd (HTRequest *request, HTGnHd gnhd);
extern HTGnHd HTRequest_gnHd (HTRequest *request);

/*
(
  Request Headers
)

The request header fields allow the client to pass additional information
about the request (and about the client itself) to the server. All headers
are optional but the default value is all request headers if present
except From and Pragma.
*/

typedef enum _HTRqHd {
    HT_C_ACCEPT_TYPE	= 0x1,
    HT_C_ACCEPT_CHAR	= 0x2,
    HT_C_ACCEPT_ENC	= 0x4,
    HT_C_ACCEPT_TE	= 0x8,
    HT_C_ACCEPT_LAN	= 0x10,
    HT_C_AUTH		= 0x20,             /* Includes proxy authentication */
    HT_C_EXPECT         = 0x40,
    HT_C_FROM		= 0x80,
    HT_C_HOST		= 0x100,
    HT_C_IMS		= 0x200,
    HT_C_IF_MATCH	= 0x400,
    HT_C_IF_MATCH_ANY	= 0x800,
    HT_C_IF_NONE_MATCH	= 0x1000,
    HT_C_IF_NONE_MATCH_ANY=0x2000,
    HT_C_IF_RANGE	= 0x4000,
    HT_C_IF_UNMOD_SINCE	= 0x8000,
    HT_C_MAX_FORWARDS	= 0x10000,
    HT_C_RANGE		= 0x20000,
    HT_C_REFERER	= 0x40000,
    HT_C_USER_AGENT	= 0x80000
} HTRqHd;

#define DEFAULT_REQUEST_HEADERS	\
	HT_C_ACCEPT_TYPE + HT_C_ACCEPT_CHAR + \
	HT_C_ACCEPT_ENC + HT_C_ACCEPT_TE + HT_C_ACCEPT_LAN + HT_C_AUTH + \
        HT_C_EXPECT + HT_C_HOST + HT_C_REFERER + HT_C_USER_AGENT

extern void HTRequest_setRqHd (HTRequest *request, HTRqHd rqhd);
extern void HTRequest_addRqHd (HTRequest *request, HTRqHd rqhd);
extern HTRqHd HTRequest_rqHd (HTRequest *request);

/*
(
  Response Headers
)

The response header fields allow the server to pass additional information
about the response (and about the server itself) to the client. All headers
are optional.
*/

typedef enum _HTRsHd {
    HT_S_AGE		= 0x1,
    HT_S_LOCATION   	= 0x2,
    HT_S_PROXY_AUTH 	= 0x4,
    HT_S_PUBLIC    	= 0x8,
    HT_S_RETRY_AFTER	= 0x10,
    HT_S_SERVER		= 0x20,
    HT_S_VARY		= 0x40,
    HT_S_WARNING	= 0x80,
    HT_S_WWW_AUTH	= 0x100,
    HT_S_TRAILER        = 0x200
} HTRsHd;

#define DEFAULT_RESPONSE_HEADERS HT_S_SERVER

extern void HTRequest_setRsHd (HTRequest * request, HTRsHd rshd);
extern void HTRequest_addRsHd (HTRequest * request, HTRsHd rshd);
extern HTRsHd HTRequest_rsHd (HTRequest * request);

/*
(
  Entity Header Mask
)

The entity headers contain information about the object sent in the HTTP
transaction. See the Anchor module, for the storage
of entity headers. This flag defines which headers are to be sent in a request
together with an entity body. All headers are optional but the default value
is ALL ENTITY HEADERS IF PRESENT
*/

typedef enum _HTEnHd {
    HT_E_ALLOW			= 0x1,
    HT_E_CONTENT_BASE		= 0x2,
    HT_E_CONTENT_ENCODING	= 0x4,
    HT_E_CONTENT_LANGUAGE	= 0x8,
    HT_E_CONTENT_LENGTH		= 0x10,
    HT_E_CONTENT_LOCATION	= 0x20,
    HT_E_CONTENT_MD5		= 0x40,
    HT_E_CONTENT_RANGE		= 0x80,
    HT_E_CTE			= 0x100,	/* Content-Transfer-Encoding */
    HT_E_CONTENT_TYPE		= 0x200,
    HT_E_DERIVED_FROM		= 0x400,
    HT_E_ETAG			= 0x800,
    HT_E_EXPIRES		= 0x1000,
    HT_E_LAST_MODIFIED		= 0x2000,
    HT_E_LINK			= 0x4000,
    HT_E_TITLE			= 0x8000,
    HT_E_URI			= 0x10000,
    HT_E_VERSION		= 0x20000
} HTEnHd;

#define DEFAULT_ENTITY_HEADERS		0xFFFFFFFF		      /* all */

extern void HTRequest_setEnHd (HTRequest *request, HTEnHd enhd);
extern void HTRequest_addEnHd (HTRequest *request, HTEnHd enhd);
extern HTEnHd HTRequest_enHd (HTRequest *request);

/*
.
  Extending The Default Set Of Header Fields
.

See also how to set up default header fields. There
are three ways to extend the set of headers that are sent in a request:

  o 
	     A simple association list
  o 
	     A stream oriented approach where the stream (called
    a generator) has direct access to the outgoing stream. That is, it can
    add any header it likes.
  o 
	     HTTP extension mechanism which
    is a much better way for handling extensions.

(
  1) Simple Association List
)

Add the (name, value) and it will be converted into MIME header format as
name: value. Do NOT add CRLF line termination - this is done by
the HTTP header generator stream
*/

extern BOOL HTRequest_addExtraHeader       (HTRequest * request,
                                            char * token, char * value);
extern HTAssocList * HTRequest_extraHeader (HTRequest * request);
extern BOOL HTRequest_deleteExtraHeaderAll (HTRequest * request);

/*
(
  2) Stream Oriented Header Generators
)

Extra header information can be send along with a request using
header generators. The text is sent as is so
it must be preformatted with CRLF line terminators. You can also
register MIME header parsers using the HTHeader
module.
*/

extern void HTRequest_setGenerator (HTRequest *request, HTList *gens,
                                    BOOL override);
extern HTList * HTRequest_generator (HTRequest *request, BOOL *override);

/*
(
  3) HTTP Extension Framework
)

These association lists contain the information that we are to send as HTTP
Extension Framework. This is not done yet but you can find some hints in
the PEP module
*/

/* TBD */

/*
.
  User And Application Preferences Using Accept Headers
.

The Accept family of headers is an important part of HTTP handling the format
negotiation. The Library supports both a global set of accept headers that
are used in all HTTP requests and a local set of accept headers
that are used in specific requests only. The global ones are defined in the
Format Manager.

Each request can have its local set of accept headers that either are added
to the global set or replaces the global set of accept headers. Non of the
headers have to be set. If the global set is sufficient for all
requests then this us perfectly fine. If the parameter "override" is set
then only local accept headers are used, else both local and global
headers are used.
(
  Content Types
)

The local list of specific conversions which the format manager
can do in order to fulfill the request. It typically points to a list set
up on initialisation time for example by HTInit().
There is also a global list of
conversions which contains a generic set of possible conversions.
*/

extern void HTRequest_setConversion (HTRequest *request, HTList *type, BOOL override);
extern HTList * HTRequest_conversion (HTRequest *request);

/*
(
  Content Encodings
)

The list of encodings acceptable in the output stream.
*/

extern void HTRequest_setEncoding (HTRequest *request, HTList *enc, BOOL override);
extern HTList * HTRequest_encoding (HTRequest *request);

/*
(
  Transfer Encodings
)

The list of transfer encodings acceptable in the output stream.
*/

extern void HTRequest_setTransfer (HTRequest *request, HTList *te, BOOL override);
extern HTList * HTRequest_transfer (HTRequest *request);

/*
(
  Content Languages
)

The list of (human) language values acceptable in the response. The default
is all languages.
*/

extern void HTRequest_setLanguage (HTRequest *request, HTList *lang, BOOL override);
extern HTList * HTRequest_language (HTRequest *request);

/*
(
  Content Charsets
)

The list of charsets accepted by the application
*/

extern void HTRequest_setCharset (HTRequest *request, HTList *charset, BOOL override);
extern HTList * HTRequest_charset (HTRequest *request);

/*
.
  HTTP Cache Validation and Cache Control
.

The Library has two concepts of caching: in memory and on file. When loading
a document, this flag can be set in order to define who can give a response
to the request. The memory buffer is considered to be equivalent to a history
buffer. That is, it doesn't not follow the same expiration mechanism that
is characteristic for a persistent file cache.

You can also set the cache to run in disconnected mode - see the
Cache manager for more details on how to do this.
*/

typedef enum _HTReload {
    HT_CACHE_OK	            = 0x0,	        /* Use any version available */
    HT_CACHE_FLUSH_MEM	    = 0x1,	/* Reload from file cache or network */
    HT_CACHE_VALIDATE	    = 0x2,	             /* Validate cache entry */
    HT_CACHE_END_VALIDATE   = 0x4,                  /* End to end validation */
    HT_CACHE_RANGE_VALIDATE = 0x8,
    HT_CACHE_FLUSH	    = 0x10,                     /* Force full reload */
    HT_CACHE_ERROR          = 0x20         /* An error occurred in the cache */
} HTReload;

extern void HTRequest_setReloadMode (HTRequest *request, HTReload mode);
extern HTReload HTRequest_reloadMode (HTRequest *request);

/*
.
  Default PUT name
.

When publishing to a server which doesn't accept a URL ending in "/", e.g,
the default Overview, index page, you can use
HTRequest_setAltPutName to setup the intended URL. If this
variable is defined, it'll be used during the cache lookup and update
operationsm, so that cache-wise, it will look as if we had published
only to "/".
*/

extern char * HTRequest_defaultPutName (HTRequest * me);
extern BOOL HTRequest_setDefaultPutName (HTRequest * me, char * name);
extern BOOL HTRequest_deleteDefaultPutName (HTRequest * me);

/*
(
  HTTP Cache Control Directives
)

The cache control directives are all part of the cache control header and
control the behavior of any intermediate cache between the user agent and
the origin server. This association list is a list of the connection control
directives that are to be sent as part of the Cache-Control
header.
*/

extern BOOL HTRequest_addCacheControl        (HTRequest * request,
                                              char * token, char *value);
extern BOOL HTRequest_deleteCacheControlAll  (HTRequest * request);
extern HTAssocList * HTRequest_cacheControl  (HTRequest * request);

/*
.
  Date and Time Stamp when Request was Issued
.

The start time when the request was issued may be of value to the cache
validation mechanism as described by the HTTP/1.1 specification. The value
is automatically set when creating the request headers and sending off the
request. The time is a local time.
*/

extern time_t HTRequest_date  (HTRequest * request);
extern BOOL HTRequest_setDate (HTRequest * request, time_t date);

/*
.
  HTTP Expect Directives
.

The Expect request-header field is used to indicate that particular server
behaviors are required by the client. A server that does not understand or
is unable to comply with any of the expectation values in the Expect field
of a request MUST respond with appropriate error status.
*/

extern BOOL HTRequest_addExpect (HTRequest * me,
				 char * token, char * value);
extern BOOL HTRequest_deleteExpect (HTRequest * me);
extern HTAssocList * HTRequest_expect (HTRequest * me);

/*
.
  Partial Requests and Range Retrievals
.

Libwww can issue range requests in case we have already obtained a part of
the entity body. Since all HTTP entities are represented in HTTP messages
as sequences of bytes, the concept of a byte range is meaningful for any
HTTP entity. (However, not all clients and servers need to support byte-range
operations.) Byte range specifications in HTTP apply to the sequence of bytes
in the entity-body (not necessarily the same as the message-body). A byte
range operation may specify a single range of bytes, or a set of ranges within
a single entity.
*/

extern BOOL HTRequest_addRange       (HTRequest * request,
                                      char * unit, char * range);
extern BOOL HTRequest_deleteRangeAll (HTRequest * request);
extern HTAssocList * HTRequest_range (HTRequest * request);

/*
.
  HTTP Connection Control Request Directives
.

The connection control directives are all part of the connection header and
control the behavior of this connection. This association list is a list
of the connection control directives that are to be sent as part of the
Connection header.
*/

extern BOOL HTRequest_addConnection        (HTRequest * request,
                                            char * token, char * value);
extern BOOL HTRequest_deleteConnection     (HTRequest * request);
extern HTAssocList * HTRequest_connection  (HTRequest * request);

/*
.
  HTTP Access Authentication Credentials
.

When a access denied response is returned to the Library, for example from
a remote HTTP server, this code is passed back to the application. The
application can then decide whether a new request should be established or
not. These two methods return the authentication information required to
issue a new request, that is the new anchor and any list of keywords associated
with this anchor.
*/

extern BOOL HTRequest_addCredentials       (HTRequest * request,
                                            char * token, char * value);
extern BOOL HTRequest_deleteCredentialsAll (HTRequest * request);
extern HTAssocList * HTRequest_credentials (HTRequest * request);

/*
(
  Realms
)

The realm is normally set and used by the authentication filters.
*/

extern BOOL HTRequest_setRealm (HTRequest * request, char * realm);
extern const char * HTRequest_realm (HTRequest * request);
extern BOOL HTRequest_deleteRealm (HTRequest * me);

/*
.
  HTTP Referer Field
.

If this parameter is set then a `Referer: <parent address> can be generated
in the request to the server, see
Referer field in a HTTP Request
*/

extern void HTRequest_setParent (HTRequest *request, HTParentAnchor *parent);
extern HTParentAnchor * HTRequest_parent (HTRequest *request);

/*
.
  Local BEFORE and AFTER Filters
.

The request object may have it's own before and after
filters. These may override or suplement the
global set in HTNet. The request object itself handles
the list element, that is this should not be freed bu the caller.
(
  BEFORE Filters
)

The BEFORE filters are called just after the
request has been passed to the Library but before any request is issued over
the network. A BEFORE can infact stop a request completely from being processed.

  Add a local BEFORE Filter


You can add a local BEFORE filter for a single request so that the
both the local and global BEFORE filters are called or you can replace
the global filters with a local set. Note that the local set can be NULL.
This can be used to effectively disable all BEFORE filters without
unregistering the global ones.
*/

extern BOOL HTRequest_addBefore (HTRequest * request, HTNetBefore * filter,
				 const char * tmplate, void * param,
                                 HTFilterOrder order, BOOL override);
extern HTList * HTRequest_before (HTRequest * request, BOOL * override);

/*

  Delete a Local BEFORE Filter


You can delete a local BEFORE filter explicitly by passing the filter itself
or you can delete all filters which are registered for a certain status code.
*/
extern BOOL HTRequest_deleteBefore (HTRequest * request, HTNetBefore * filter);
extern BOOL HTRequest_deleteBeforeAll (HTRequest * request);

/*
(
  AFTER Filters
)

You can add a local AFTER filter for a single request so that the both the
local and global AFTER filters are called or you can replace the global filters
with a local set. Note that the local set can be NULL. This can be used to
effectively disable all AFTER filters without unregistering the global ones.

AFTER filters can be registered to handle a certain set of return values
from the protocol modules, for example explicitly to handle redirection,
authentication, etc. You can find all the available codes in the HTNet object
description.

  Add a local AFTER Filter

*/

extern BOOL HTRequest_addAfter (HTRequest * request, HTNetAfter * filter,
				const char * tmplate, void * param,
                                int status, HTFilterOrder order,
                                BOOL override);
extern HTList * HTRequest_after (HTRequest * request, BOOL * override);

/*

  Delete an AFTER Filter


You can delete a local AFTER filter explicitly by passing the filter itself
or you can delete all filters which are registered for a certain status code.
*/

extern BOOL HTRequest_deleteAfter (HTRequest * request, HTNetAfter * filter);
extern BOOL HTRequest_deleteAfterStatus (HTRequest * request, int status);
extern BOOL HTRequest_deleteAfterAll (HTRequest * request);

/*
.
  Sending data from App to Network
.

Multiple Request objects can be connected in order to create a
PostWeb for sending data
from one location (source) to another (destination). Request objects are
bound together by connecting the output stream of the source with the input
stream of the destination requst. The connection can be done directly so
that the output from the source is exactly what is sent to the destination
or there can be a conversion between the two streams so that we can do
conversions on the fly while copying data. This is in fact the way we use
for building a proxy server.

The Library supports two ways of posting a data object to a remote destination:
Input comes from a socket descriptor or from memory. In the case where you
want to copy a URL, for example from local file system or
from a remote HTTP server then you must use the
PostWeb design. This model
operates by using at least two request objects which gets linked to eachother
as part of the PostWeb model. However, if you are posting from memory, we
only use one request object to perform the operation. In order to
do this, the application must register a callback function that can be called
when the HTTP client module is ready for accepting data.
be included as part of the body and/or as extra metainformation. In the latter
case you need to register a callback function of the following type using
the methods provided in the next section.
*/

typedef int HTPostCallback (HTRequest * request, HTStream * target);

extern void HTRequest_setPostCallback (HTRequest * request, HTPostCallback * cbf);
extern HTPostCallback * HTRequest_postCallback (HTRequest * request);

/*

The Entity Anchor is either the anchor directly associated with the Request
object or the post anchor associated with the object. The purpose of the
entity anchor is if we are to send data to a remote server then we get the
metainformation using the entity anchor.
*/

extern BOOL HTRequest_setEntityAnchor (HTRequest * request, HTParentAnchor * anchor);
extern HTParentAnchor * HTRequest_entityAnchor (HTRequest * request);

/*
(
  Input Stream
)

The input stream is to be used to put data to the network. Normally
each protocol sets the input stream in order to generate the protocol headers
while making a request.
*/

extern void HTRequest_setInputStream (HTRequest * request, HTStream * input);
extern HTStream *HTRequest_inputStream (HTRequest * request);

/*
(
  Is This Request part of a Post Web? (Deprecated)
)

Check to see if this request object is part of a Post Web.
*/

extern BOOL HTRequest_isPostWeb (HTRequest * request);

/*
(
  Source of a Request
)

A request may have a source in which is another request object that as output
stream has the input stream of this request object.
*/

extern BOOL HTRequest_setSource (HTRequest * request, HTRequest * source);
extern HTRequest * HTRequest_source (HTRequest * request);

/*
.
  Streams From Network to Application
.
(
  Default Output Stream
)

The output stream is to be used to put data down to as they come in
from the network and back to the application. The default value is
NULL which means that the stream goes to the user (display).
*/

extern void HTRequest_setOutputStream (HTRequest *request, HTStream *output);
extern HTStream *HTRequest_outputStream (HTRequest *request);

/*
(
  Default Output Stream Format
)

The desired format of the output stream. This is used in the
stream stack builder to determine which stream
to plug in to deal with the data. If NULL, then
WWW_PRESENT is default value.
*/

extern void HTRequest_setOutputFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_outputFormat (HTRequest *request);

/*
(
  Has Output Stream been Connected to Channel? (Deprecated)
)

Has output stream been connected to the channel? If not then we must free
it explicitly when deleting the request object
*/
extern void HTRequest_setOutputConnected (HTRequest * request, BOOL mode);
extern BOOL HTRequest_outputConnected	 (HTRequest * request);

/*
(
  Default Debug Stream
)

All object bodies sent from the server with status codes different from
200 OK will be put down this stream. This can be used for
redirecting body information in status codes different from "200 OK" to for
example a debug window. If the value is NULL (default) then the stream is
not set up.
*/

extern void HTRequest_setDebugStream (HTRequest *request, HTStream *debug);
extern HTStream *HTRequest_debugStream (HTRequest *request);

/*
(
  Default Debug Stream Format
)

The desired format of the error stream. This can be used to get unconverted
data etc. from the library. The default value if WWW_HTML as
a character based only has one WWW_PRESENT.
*/

extern void HTRequest_setDebugFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_debugFormat (HTRequest *request);

/*
.
  Context Swapping
.

In multi threaded applications it is often required to keep track of the
context of a request so that when the Library returns a result of a request,
it can be put into the context it was in before the request was first passed
to the Library. This call back function allows the application to do this.
*/

typedef int HTRequestCallback (HTRequest * request, void *param);

extern void HTRequest_setCallback (HTRequest *request, HTRequestCallback *cb);
extern HTRequestCallback *HTRequest_callback (HTRequest *request);

/*

The callback function can be passed an arbitrary pointer (the void part)
which can describe the context of the current request structure. If such
context information is required then it can be set using the following methods:
*/

extern void HTRequest_setContext (HTRequest *request, void *context);
extern void *HTRequest_context (HTRequest *request);

/*
.
  Should we Issue a full HTTP Request-URI?
.

In early versions of HTTP, the request sent to the remote server varies whether
we use a proxy or go directly to the origin server. The default value is
OFF but we use a full request if we are talking to a proxy server.
*/

extern void HTRequest_setFullURI (HTRequest *request, BOOL mode);
extern BOOL HTRequest_fullURI (HTRequest *request);

/*
.
  Handling Proxies
.

In case we are using a proxy for this requst then we can register it together
with the request object. That way we can find the proxy and look for
authentication information, for example in the
Authentication filter. The string is freed by
the Request object on deletion. This is normally handled automatically by
the proxy and gateway module
*/

extern BOOL HTRequest_setProxy    (HTRequest * request, const char * proxy);
extern char * HTRequest_proxy     (HTRequest * request);
extern BOOL HTRequest_deleteProxy (HTRequest * request);

/*
.
Message Body Manipulation
.

An application may use these functions to set and manipulate the request
message body.  This message body is specially indicate for methods that use
small XML message bodies. Once the application defines it, this message body
will be send just after the headers. It  does not use
"Expect: 100-continue" header, and the application
should not try to use both.  It's important to remark that
"Expect: 100-continue" header is a very importante feature defined in HTTP.
It's prevents that, for example, the server must read many unnecessary bytes
from request body. Using "Expect: 100-continue" header, your application
safes time and network (see 
RFC2616, section 8.2.3).
Please, if possible, use always HTRequest Entity and entity callback, leave
this only for small XML bodies in extension methods (see 
HTMethod), and when using it, be very
careful!

When using a message body, the application may define its length and
format. If the message body is set and its length is also set and it greater
than 0, a Content-Lenght header will be added to the request. Similarly, if 
the message body and its type are set, a Content-Type header will be added 
to the request too. Otherwise, those headers will not be included.

Note: The caller should free the string returned by
HTRequest_messageBody function!
*/

extern BOOL HTRequest_setMessageBody (HTRequest * request, const char * body);
extern BOOL HTRequest_deleteMessageBody (HTRequest * request);
extern char * HTRequest_messageBody (HTRequest * request);

extern BOOL HTRequest_setMessageBodyLength (HTRequest * request, long int length);
extern long int HTRequest_messageBodyLength (HTRequest * request);

extern BOOL HTRequest_setMessageBodyFormat (HTRequest * request, HTFormat format);
extern HTFormat HTRequest_messageBodyFormat (HTRequest * request);

/*

.
  Bytes Read or Written in a Request
.

This function returns the bytes read in the current request. For a deeper
description of what the current request is, please read the user's guide.
This function can be used in for example the HTAlert
module to give the number of bytes read or written in a progress message.
*/

extern long HTRequest_bodyRead (HTRequest * request);
extern long HTRequest_bodyWritten (HTRequest * request);

/*

You can also get the total number of bytes read or written including the
headers
*/

extern long HTRequest_bytesRead (HTRequest * request);
extern long HTRequest_bytesWritten (HTRequest * request);

/*
*/

#endif /* HTREQ_H */

/*

  

  @(#) $Id: HTReq.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTReqMan.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Private Request Definition


!
  Private Request Definition
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is the private part of the request object. It has the functions
declarations that are private to the Library and that shouldn't be used by
applications. The module has been separated from the old HTAccess module.
See also the public part of the declarition in the HTReq
Module.

This module is implemented by HTReqMan.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTREQMAN_H
#define HTREQMAN_H

#include "HTReq.h"
#include "HTList.h"
#include "HTFormat.h"
#include "HTAnchor.h"
#include "HTMethod.h"
#include "HTAABrow.h"
#include "HTStream.h"
#include "HTNet.h"
#include "HTMIMPrs.h"

/*

When a request is handled, all kinds of things about it need to be passed
along together with a request. It is intended to live as long as the request
is still active, but can be deleted as soon as it has terminated. Only the
anchor object stays around after the request itself is terminated.
*/

struct _HTRequest {

    BOOL		internal;      /* Does the app knows about this one? */

    time_t		date;      /* Time stamp when the request was issued */

    HTMethod		method;

    BOOL                flush;                /* Should we flush immediately */

    HTPriority		priority;		/* Priority for this request */

/*
(
Message body
)

A request message body indicated for XML bodies. It is used for extension
methods. See HTReq.html for details.
*/

#ifdef HT_EXT
    char *             messageBody;
    long int           messageBodyLength;
    HTFormat           messageBodyFormat;
#endif

/*
(
  User Profile
)

Each request can be assigned a user profile containing
information about this host and the user issuing the request.
*/

    HTUserProfile *	userprofile;

/*
(
  Net Object
)

Each request is assigned a Net object which contains pointers to other objects
handling the request.
*/

    HTNet *		net;		    /* Information about socket etc. */

/*
(
  Response Object
)

When we start getting MIME headers in as a response we keep it in this object
until we know what to do with it.
*/

    HTResponse *        response;

/*
(
  Error Manager
)
*/

    HTList *		error_stack;		           /* List of errors */

/*
(
  Have many times do We Want to Try?
)
*/

    int			retrys;       	      /* Number of automatic reloads */
    int                 max_forwards;
    int			AAretrys;      	      /* Number of authentication
                                                 retries */

/*
(
  Preemptive or Non-Preemptive load?
)

Each protocol module is registered with a default behavior but if you have
registered a protocol module for non-preemtive load you can override this
by using the following flag.
*/

    BOOL		preemptive;

/*
(
  Content Negotiation
)

Normally, when we access the local file system we do content negotiation
in order to find the most suited representation. However, you can turn this
off by using the following flag.
*/

    BOOL		ContentNegotiation;

/*
(
  Should we use preconditions?
)
*/

    HTPreconditions     preconditions;

/*
(
  Headers and header information
)

These are the masks that decides what headers to send.
*/

    HTGnHd		GenMask;
    HTRsHd		ResponseMask;
    HTRqHd		RequestMask;
    HTEnHd		EntityMask;

/*
(
  Local MIME Header Parsers
)

Each request can be assigned its own MIME header parsers.
*/

    HTMIMEParseSet *	parseSet;
    BOOL		pars_local;

/*
(
  Accept headers
)

These are the accept headers that we want to send out.
*/

    HTList *		conversions;
    BOOL		conv_local;

    HTList *		encodings;
    BOOL		enc_local;

    HTList *		tes;
    BOOL		te_local;

    HTList *		languages;
    BOOL		lang_local;

    HTList *		charsets;
    BOOL		char_local;

    HTList *		befores;
    BOOL		befores_local;

    HTList *		afters;
    BOOL		afters_local;

/*
(
  Are we using a Proxy?
)

If so then we keep the name in this variable
*/

    char * 		proxy;
    BOOL                full_uri;

/*
(
  Cache Control Directives
)

This association list is a list of the cache control directives that are
to be sent as part of the Cache-Control header.
*/

    HTReload		reload;
    HTAssocList *       cache_control;

/*
(
  Default PUT name
)

Stores the default name when publishing to a "/" URL.
*/

   char *               default_put_name;

/*
(
  Byte Ranges
)

This association list is a list of the cache control directives that are
to be sent as part of the Range header.
*/

    HTAssocList *       byte_ranges;

/*
(
  Connection Control Directives
)

This association list is a list of the connection control directives that
are to be sent as part of the Connection header.
*/

    HTAssocList *       connection;

/*
(
  Expect Directives
)

The Expect request-header field is used to indicate that particular server
behaviors are required by the client. A server that does not understand or
is unable to comply with any of the expectation values in the Expect field
of a request MUST respond with appropriate error status.
*/

    HTAssocList *       expect;

/*
(
  Access Authentication Information
)

The credentials list contains the information that we are to
send as part of the Authorization header. The realm is if we
already know that we need to generate credentials for a specific realm.
*/

    char *		realm;				    /* Current realm */
    HTAssocList *	credentials;	   /* Credentials received by server */

/*
(
  Request Header Extensibility
)

  

  1) Simple Association List


Add the (name, value) and it will be converted into MIME header format as
name: value. DO NOT ADD CRLF line termination - this is done
by the HTTP header generator stream
*/

    HTAssocList	*	extra_headers;

/*

  2) Stream Oriented Header Generators


A generator is a stream with direct access to the output stream
*/

    HTList *		generators;
    BOOL		gens_local;

/*

  4) HTTP Extension Framework


These association lists contain the information that we are to send as
HTTP Extension Framework.
*/

    HTAssocList *	mandatory;
    HTAssocList *	optional;

/*
(
  Anchors
)
*/

    HTParentAnchor *	anchor;	       /* The Client anchor for this request */

    HTChildAnchor *	childAnchor;	    /* For element within the object */
    HTParentAnchor *	parentAnchor;			/* For referer field */

/*
(
  Streams From Network to Application
)
*/

    HTStream *		output_stream; 
    HTStream *		orig_output_stream; 
    HTFormat		output_format;
    BOOL		connected;

    HTStream *		debug_stream;
    HTStream *		orig_debug_stream;
    HTFormat		debug_format;

/*
(
  Streams From Application to Network
)
*/

    HTStream *		input_stream; 
    HTFormat		input_format;

/*
(
  Callback Function for getting data down the Input Stream
)
*/

    HTPostCallback *	PostCallback;

/*
(
  Context Swapping
)
*/

    HTRequestCallback *	callback;
    void *		context;

/*
(
  PostWeb Information (Not used anymore - don't use!)
)
*/

    HTRequest *		source;		     /* Source for request or itself */
    HTParentAnchor *	source_anchor;		  /* Source anchor or itself */

    HTRequest *		mainDestination;	     /* For the typical case */
    HTList *		destinations;		 /* List of related requests */
    int			destRequests;	   /* Number of destination requests */
    int			destStreams;	    /* Number of destination streams */

/*
*/

};

/*
.
  Post Web Management
.

These functions are mainly used internally in the Library but there is no
reason for them not to be public.
*/

extern BOOL HTRequest_addDestination (HTRequest * src, HTRequest * dest);
extern BOOL HTRequest_removeDestination	(HTRequest * dest);
extern BOOL HTRequest_destinationsReady (HTRequest * me);

extern BOOL HTRequest_linkDestination (HTRequest * dest);
extern BOOL HTRequest_unlinkDestination (HTRequest * dest);

extern BOOL HTRequest_removePostWeb (HTRequest * me);
extern BOOL HTRequest_killPostWeb (HTRequest * me);

#define	HTRequest_mainDestination(me) \
	((me) && (me)->source ? (me)->source->mainDestination : NULL)
#define HTRequest_isDestination(me) \
	((me) && (me)->source && (me) != (me)->source)
#define HTRequest_isMainDestination(me) \
	((me) && (me)->source && \
	(me) == (me)->source->mainDestination)
#define HTRequest_isSource(me) \
	((me) && (me)->source && (me) == (me)->source)

/*

End of Declaration
*/

#endif /* HTREQMAN_H */

/*

  

  @(#) $Id: HTReqMan.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTResMan.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Private Request Definition


!
  Private Response Definition
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is the private part of the response object. It has the functions
declarations that are private to the Library and that shouldn't be used by
applications. See also the public part of the declarition in the
HTResponse Module.

This module is implemented by HTResMan.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTRESMAN_H
#define HTRESMAN_H

#include "HTResponse.h"
#include "HTList.h"
#include "HTFormat.h"
#include "HTAnchor.h"
#include "HTMethod.h"
#include "HTAABrow.h"
#include "HTStream.h"
#include "HTNet.h"
#include "HTMIMPrs.h"

/*

When a request is handled, all kinds of things about it need to be passed
along together with a request. It is intended to live as long as the request
is still active, but can be deleted as soon as it has terminated. Only the
anchor object stays around after the request itself is terminated.
*/

struct _HTResponse {

    int                 hash;

/*
(
  Redirection
)

If we get a redirection back then we return the new destination for this
request to the application using this anchor.
*/

    HTAnchor *		redirectionAnchor;		  /* Redirection URL */

/*
(
  Retry Request After
)

If we get a response back saying that we have to retry the request after
a certain amount of time then add this information here. Libwww does not
retry the request automatically - this is for the application to do.
*/

    time_t		retry_after;		 /* Absolut time for a retry */

/*
(
  Access Authentication Information
)

The challenge and the credentials entries are use
by the authentication parsers and generators respectively.
*/

    char *		realm;				    /* Current realm */
    char *		scheme;				   /* Current scheme */

    HTAssocList *	challenge;         /* Challenge received in response */

/*
(
  Connection Control Directives
)

This association list is a list of the connection control directives that
have been received in the response.
*/

    HTAssocList *       connection;

/*
(
  Protocol Extension Protocol (PEP) Information
)

These association lists contain the information that we have received in
PEP headers in the response.
*/

    HTAssocList *	protocol;
    HTAssocList *	protocol_info;
    HTAssocList *	protocol_request;

/*

(
  Cache Control Directives
)

This association list is a list of the cache control directives that have
been received as part of the response. We also keep track of whether the
response si cachable or not.
*/

    HTCachable          cachable;
    BOOL                cached;             /* If anchor has inherited lists */
    HTAssocList *       cache_control;

/*
(
  Range Requests
)

We may get a partial response in which case we register the received ranges
of the resource.
*/

    HTAssocList *       byte_ranges;

/*
(
  Variants
)

The response may be a negotiated response in which case we wanna know. This
has significance for whether the object is cachable or not.
*/

    HTAssocList *       variants;

/*
(
  Content Length
)

We register the content length as thjis is of importance to all responses.
The content length is&nbsp;a common way to figure out how many bytes we can
expect.
*/

    long int	       content_length;

/*
(
  Content Type
)

The Content type is important to know as we set of the stream pipe and do
the format conversion.
*/

    HTFormat           content_type;
    HTAssocList *      type_parameters;    /* Type parameters (charset etc.) */

/*
(
  Content Encoding
)

We register the content-encoding as it may affect the stream pipe as we set
it up.
*/

    HTList *	       content_encoding;

/*
(
  Transfer Encoding
)

The transfer encoding is likewise important when we set up the stream pipe.
*/

    HTList *          transfer_encoding;

/*
(
  Content Transfer Encoding
)

The content transfer encoding is likewise important when we set up the stream pipe.
*/

    HTEncoding         cte;

/*
(
  Trailer
)

The tailers are headers that come at the end
*/

    HTAssocList *      trailer;

/*
(
  Original Reponse Header Values
)

We store the&nbsp;original headers as they may become useful in many ways
- for example in lazy parsing.
*/

    HTAssocList *      headers;

/*

The reason string furnished by the server, as some servers may send
useful custom information in it
*/

    char *             reason;             /* JK: HTTP reason string */

/*
*/

}; /* End of definition of HTResponse */

/*

End of Declaration
*/

#endif /* HTRESMAN_H */

/*

  

  @(#) $Id: HTResMan.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTResponse.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Response Class


!
  The Response Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The response object is created as a placeholder for the response received
by the remote server. All filters can then use the information passed in
the response and act appropriately. The response object is deleted automatically
when the corresponding request object is deleted. We try and do some fancy
tricks in order to do lazy parsing and reusing parsed values so that we can
optimize the code.

The Response object is created automatically when we start to receive
metainformation (for example MIME headers) and is
linked to the Request object. The
Response object is also deleted automatically when the corresponding request
object is deleted but it can of course be deleted before if this is
desired.

Note that if you are using non-blocking sockets then libwww
behaves asynchronously as you may issue multiple requests and get back the
responses in the order they appear on the net interface.


This module is implemented by HTResponse.c, and
it is a part of the  W3C Sample Code
Library.
*/

#ifndef HTRESPONSE_H
#define HTRESPONSE_H

typedef struct _HTResponse HTResponse;

#include "HTEvent.h"
#include "HTList.h"
#include "HTAssoc.h"
#include "HTFormat.h"
#include "HTUser.h"

/*
.
  Creating and Deleting Response Objects
.

The response obejct gets created when we start receiving a response from
a remote server.
(
  Create Response Object
)

Creates a new response object with a corresponding User Profile object.
*/

extern HTResponse * HTResponse_new (void);

/*
(
  Delete Response Object
)

This function deletes the object and cleans up the memory.
*/

extern BOOL HTResponse_delete (HTResponse * response);

/*
.
  Redirections
.

When a redirection response is returned to the Library, for example from
a remote HTTP server, this code is passed back to the application. The
application can then decide whether a new request should be established or
not. These two methods return the redirection information required to issue
a new request, that is the new anchor and any list of keywords associated
with this anchor.
*/

extern HTAnchor * HTResponse_redirection (HTResponse * response);
extern BOOL HTResponse_setRedirection (HTResponse * response, HTAnchor * anchor);

/*
.
  Retry Request After
.

Some services, for example HTTP, can in case they are unavailable at the
time the request is issued send back a time and date stamp to the client
telling when they are expected to back online. In case a request results
in a HT_RETRY status, the application can use any time indicated in this
field to retry the request at a later time. The Library does not initiate
any request on its own - it's for the application to do. The time returned
by this function is in calendar time or -1 if not available.
*/

extern time_t HTResponse_retryTime (HTResponse * response);
extern BOOL HTResponse_setRetryTime (HTResponse * response, time_t retry);

/*
.
  HTTP Access Authentication Challanges
.

When a access denied response is returned to the Library, for example from
a remote HTTP server, this code is passed back to the application. The
application can then decide whether a new request should be established or
not. These two methods return the authentication information required to
issue a new request, that is the new anchor and any list of keywords associated
with this anchor.
*/

extern BOOL HTResponse_addChallenge (HTResponse * response, char * token, char * value);

extern BOOL HTResponse_deleteChallengeAll (HTResponse * response);

extern HTAssocList * HTResponse_challenge (HTResponse * response);

/*
(
  Realms
)
*/

extern BOOL HTResponse_setRealm (HTResponse * response, char * realm);
extern const char * HTResponse_realm (HTResponse * response);

/*
(
  Access Authentication Schemes
)
*/

extern BOOL HTResponse_setScheme (HTResponse * response, char * scheme);
extern const char * HTResponse_scheme (HTResponse * response);

/*
.
  HTTP Connection Control Directives
.

The connection control directives are all part of the connection header and
control the behavior of this connection. The respose object contains the
connection information that we have received in the response.
*/

extern BOOL HTResponse_addConnection       (HTResponse * response,
                                            char * token, char * value);
extern BOOL HTResponse_deleteConnectionAll (HTResponse * response);
extern HTAssocList * HTResponse_connection (HTResponse * response);

/*
.
  HTTP Extensions (PEP)
.

HTTP can be extended in several ways but traditionally it has been by using
new headers. Here we present a new idea which provides a framework for describing
extensions and their scope. This is only an idea an may be modified later!
The implementation of the extensions can be found in the
PEP module
(
  Protocol
)

This association list is a list of the extension directives that were received
as part of the response.
*/

extern BOOL HTResponse_addProtocol       (HTResponse * response,
                                          char * token, char * value);
extern BOOL HTResponse_deleteProtocolAll (HTResponse * response);
extern HTAssocList * HTResponse_protocol (HTResponse * response);

/*
(
  Protocol Info
)

This association list is a list of the extension directives that were received
as part of the response.
*/

extern BOOL HTResponse_addProtocolInfo       (HTResponse * response,
                                              char * token, char * value);
extern BOOL HTResponse_deleteProtocolInfoAll (HTResponse * response);
extern HTAssocList * HTResponse_protocolInfo (HTResponse * response);

/*
(
  Protocol Request
)

This association list is a list of the extension directives that were received
as part of the response.
*/

extern BOOL HTResponse_addProtocolRequest       (HTResponse * response,
                                                 char * token, char * value);
extern BOOL HTResponse_deleteProtocolRequestAll (HTResponse * response);
extern HTAssocList * HTResponse_protocolRequest (HTResponse * response);

/*
.
  HTTP Cache Control Directives
.

This association list is a list of the cache control directives that have
been received as part of the response. We also keep track of whether the
response is cachable or not.
*/

extern BOOL HTResponse_addCacheControl       (HTResponse * response,
                                              char * token, char *value);
extern BOOL HTResponse_deleteCacheControlAll (HTResponse * response);
extern HTAssocList * HTResponse_cacheControl (HTResponse * response);

/*
(
  Is the response Cachable?
)

The various cache-control headers and directives decides whether
an object is cachable or not. Check these methods before starting caching!
*/

typedef enum _HTCachable {
    HT_NO_CACHE            = 0,
    HT_CACHE_ALL           = 1,
    HT_CACHE_ETAG          = 2,
    HT_CACHE_NOT_MODIFIED  = 3
} HTCachable; 

extern HTCachable HTResponse_isCachable  (HTResponse * me);
extern BOOL HTResponse_setCachable (HTResponse * me, HTCachable mode);

/*
(
  The Response Enity Tag (etag)
)
Return the etag if any
*/

extern char * HTResponse_etag (HTResponse * me);

/*

(
  Has the Response been Cached?
)

When we gc the response object we need to know whether the header lists have
been inherited by other objects (the anchor object,
for example) and hence shouldn't be deleted. We can tell the response object
this by using the following method call
*/

extern BOOL HTResponse_isCached (HTResponse * me, BOOL mode);

/*
(
  Some Cache-Control helper Methods
)

Some useful helper functions for handling specific response cache directives
*/

extern time_t HTResponse_maxAge              (HTResponse * response);
extern BOOL   HTResponse_mustRevalidate      (HTResponse * response);
extern char * HTResponse_noCache             (HTResponse * response);

/*
(
  Partial responses and Range Retrievals
)

Libwww can issue range requests in case we have already obtained a part of
the entity body. Since all HTTP entities are represented in HTTP messages
as sequences of bytes, the concept of a byte range is meaningful for any
HTTP entity. (However, not all clients and servers need to support byte-range
operations.) Byte range specifications in HTTP apply to the sequence of bytes
in the entity-body (not necessarily the same as the message-body). A byte
range operation may specify a single range of bytes, or a set of ranges within
a single entity.
*/

extern BOOL HTResponse_addRange       (HTResponse * response,
                                       char * unit, char * range);
extern BOOL HTResponse_deleteRangeAll (HTResponse * response);
extern HTAssocList * HTResponse_range (HTResponse * response);

/*
(
  Content Length
)

We store the content length so that we have an idea of how many bytes to
expect.
*/

extern long int HTResponse_length (HTResponse * response);
extern void HTResponse_setLength  (HTResponse * response, long int length);
extern void HTResponse_addLength  (HTResponse * response, long int deltalength);

/*
(
  Content Type (Media type)
)

We store the content-type of the response along with the charset, level and
all other paramaters that may follow the content-type itself.
*/

extern HTFormat HTResponse_format (HTResponse * response);
extern void HTResponse_setFormat  (HTResponse * response, HTFormat format);

/*

The Response object stores all content type parameters (charset, level, etc.)
in an Association list so here you will always be able to find them. We also
have a few methods for the special cases: charset and
level as they are often needed.
*/

extern HTAssocList * HTResponse_formatParam (HTResponse * response);
extern BOOL HTResponse_addFormatParam  (HTResponse * response,
					const char * name, const char * value);

/*

  Charset parameter to Content-Type

*/

extern HTCharset HTResponse_charset (HTResponse * response);
extern BOOL HTResponse_setCharset   (HTResponse * response, HTCharset charset);

/*

  Level parameter to Content-Type

*/

extern HTLevel HTResponse_level (HTResponse * response);
extern BOOL HTResponse_setLevel (HTResponse * response, HTLevel level);

/*
(
  Content Encodings
)

The list of encodings that we have received in the response.
*/

extern HTList * HTResponse_encoding (HTResponse * response);
extern BOOL HTResponse_addEncoding  (HTResponse * response, HTEncoding enc);

/*
(
  Transfer Encodings
)

The list of encodings that we have received in the response.
*/

extern HTList * HTResponse_transfer (HTResponse * response);
extern BOOL HTResponse_addTransfer  (HTResponse * response, HTEncoding te);

/*
(
  Content Transfer Encodings
)

Any transfer encoding that we have received in the response.
*/

extern HTEncoding HTResponse_contentTransferEncoding (HTResponse * response);
extern BOOL HTResponse_setContentTransferEncoding (HTResponse * response,
                                                   HTEncoding cte);

/*
(
  Vary Headers
)

Any Vary header fields
*/

extern BOOL HTResponse_addVariant (HTResponse * me, char * token, char * value);
extern BOOL HTResponse_deleteVariantAll (HTResponse * me);
extern HTAssocList * HTResponse_variant (HTResponse * me);

/*
(
  Trailers
)

Any trailer header fields
*/

extern BOOL HTResponse_addTrailer (HTResponse * me, char * token, char * value);
extern BOOL HTResponse_deleteTrailerAll (HTResponse * me);
extern HTAssocList * HTResponse_trailer (HTResponse * me);

/*

(
  Original Response Headers
)

The MIME parser may add the original response headers
as (name,value) pairs. The information may be picked up by the
persistent cache manager.
*/

extern BOOL HTResponse_addHeader       (HTResponse * response,
                                        char * token, char * value);
extern BOOL HTResponse_deleteHeaderAll (HTResponse * response);
extern HTAssocList * HTResponse_header (HTResponse * response);

extern HTAssocList * HTResponse_handOverHeader (HTResponse * me);

/*

(
  The HTTP reason string
)
The string returned in the HTTP status line. Some servers send custom
info in this string and applications may want to show it.
*/

extern char * HTResponse_reason (HTResponse * me);
extern BOOL HTResponse_setReason (HTResponse * me, char * reason);

/*

*/

#endif /* HTRESPONSE_H */

/*

  

  @(#) $Id: HTResponse.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTRules.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Rule File Configuration manager


!
  Rule File Configuration Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The W3C Library provides this module for handling configuration files (a.k.a.
rule files). Rule files can be used to initialize as much as the application
desires including setting up new protocol modules etc. Also the rules file
do not have to be a fil - it can be a database or any other way of storage
information. This implementation is not used by the Library at all and is
part of the Application interface.

This module is implemented by HTRules.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTRULE_H
#define HTRULE_H

#include "HTList.h"
#include "HTReq.h"
#include "HTFormat.h"

/*
.
  Parse a Rule File
.

Parsing a whole rule file is done using a converter stream. This means
that a rule file can come from anywhere, even accross the network. We
have defined a special content type for rule files called
WWW_RULES in HTFormat and
made a file suffix binding for all files ending in
".conf" in the default
initialization of the file suffix bindings
module.

The rule file parser comes in two variants: one that asks the user and
one that doesn't. Needless to say that you have to be carefull with
the latter one. You can also define HT_AUTOMATIC_RULES
when compiling libwww to determine
whether it is OK to parse a rule file without asking the user.
*/

extern HTConverter HTRules, HTRules_parseAutomatically;

/*
.
  Parse a single line from a Rule File
.

This routine may be used for loading configuration information from sources
other than the rule file, for example INI files for X resources.
config is a string in the syntax of a rule file line.
*/

extern BOOL HTRule_parseLine (HTList * list, const char * config);

/*
.
  Add a Rule to the List
.

This function adds a rule to the list of rules. The pattern
is a 0-terminated string containing a single "*". equiv points
to the equivalent string with * for the place where the text matched by *
goes.
*/

typedef struct _HTRule HTRule;

typedef enum _HTRuleOp {
    HT_Invalid, 
    HT_Map, 
    HT_Pass, 
    HT_Fail,
    HT_DefProt,
    HT_Protect,
    HT_Exec,
    HT_Redirect,
    HT_UseProxy
} HTRuleOp;

extern BOOL HTRule_add (HTList * list, HTRuleOp op,
			const char * pattern, const char * replace);

/*
.
  Delete all Registered Rules
.

This function clears all rules registered
*/

extern BOOL HTRule_deleteAll (HTList *list);

/*
.
  Global Rules
.

Rules are handled as list as everything else that has to do with preferences.
We provide two functions for getting and setting the global rules:
*/

extern HTList * HTRule_global(void);
extern BOOL HTRule_setGlobal (HTList * list);
extern BOOL HTRule_addGlobal (HTRuleOp op, const char * pattern, const char * replace);

/*
.
  Translate by rules
.

This function walks through the list of rules and translates the reference
when matches are found. The list is traversed in order starting from the
head of the list. It returns the address of the equivalent string allocated
from the heap which the CALLER MUST FREE. If no translation occured, then
it is a copy of the original.
*/

extern char * HTRule_translate (HTList * list, const char * token,
				BOOL ignore_case);

/*
*/

#endif

/*

  

  @(#) $Id: HTRules.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTSChunk.h
::::::::::::::
/*


  					W3C Sample Code Library libwww Stream to Chunk Converter


!
  Stream to Chunk Converter
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This stream converts a Stream obejct into a
Chunk object. Chunks are dynamic streams so this
is in other words a conversion from a stream based model to a dynamic data
buffer model for handling a downloaded object. It is for the caller of this
stream to free the chunk.

If max_size is 0 then we use a default size, if -1 then there is no limit.

This module is implemented by HTSChunk.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTSCHUNK_H
#define HTSCHUNK_H

#include "HTChunk.h"
#include "HTStream.h"

extern HTStream * HTStreamToChunk (HTRequest * 	request,
				   HTChunk **	chunk,
				   int 		max_size);

/*

End of definition module
*/

#endif /* HTSCHUNK_H */

/*

  

  @(#) $Id: HTSChunk.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTSocket.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Identity Socket Read


!
  Identity Socket Read Method
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This function is an "identity" application protocol in that it reads
data from the transport and passes it down stream without doing anything
with it. It simply reads data and is a wrapper around a registered
transport mechanism for reading from a socket.
It provides a callback function for the event loop
so that a socket can be loaded using non-blocking I/O. The function requires
an open socket. It will typically be used in server applications or
in a client application that can read directly from stdin.

This module is implemented by HTSocket.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTSOCKET_H
#define HTSOCKET_H

#include "HTProt.h"

extern HTProtCallback HTLoadSocket;

/*
*/


/*
*/
#endif

/*

  

  @(#) $Id: HTSocket.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTSQL.h
::::::::::::::
/*

  					W3C Sample Code Library libwww SQL API


!
  Simple SQL API
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module interacts with the MYSQL C client library to perform SQL operations.
It is not intended as a complete SQL API but handles most of the typical
error situations talking to an SQL server so that the caller doesn't have
to think about it.

This requires that you have linked against a MySQL
library. See the installation instructions
for details.

This module is implemented by HTSQL.c, and it is a
part of the  W3C Sample Code Library.
*/

#ifndef HTSQL_H
#define HTSQL_H

#include <mysql/mysql.h>

/*
.
  The HTSQL Object
.
*/

typedef struct _HTSQL HTSQL;

extern HTSQL * HTSQL_new (const char * host,
			  const char * user, const char * pw,
			  int flags);
extern BOOL HTSQL_delete (HTSQL * me);

/*
.
  Handling the link to the Server
.
(
  Open a connection to the SQL server
)
*/

extern BOOL HTSQL_connect (HTSQL * me);

/*
(
  Close the link to the database
)
*/

extern BOOL HTSQL_close (HTSQL * me);

/*
(
  You can get information about whom we are talking to by calling this function:
)
*/

extern BOOL HTSQL_version (HTSQL *		me,
			   char **		server,
			   unsigned int * 	protocol_version,
			   char **		server_version,
			   char **		client_version);

/*
(
  Selecting the current database
)
*/

extern BOOL HTSQL_selectDB (HTSQL * me, const char * db);

/*
(
  Getting the raw MYSQL object
)

After you have connected you can get the raw MYSQL object by
calling this function
*/

extern MYSQL * HTSQL_getMysql (HTSQL * me);

/*
.
  SQL printf
.

When creating queries to send to the SQL server you need to generate a lot
of SQL specific strings. This function knows most of the commonly used SQL
ways of handling date and time string, escaping and quoting strings and how
to write integers as strings. The function works pretty much as fprintf with
the following possible format arguments:

  
    %s
  
    Writes a string as is. No quotation or escaping is performed. NULL is written
    as "null".
  
    %S
  
    Writes a string in quotes and escapes any special SQL characters. NULL is
    written as "null".
  
    %T
  
    Creates an SQL datetime stamp from a time_t variable looking
    like this YYYY-MM-DD HH:MM:SS. -1 is written as
    "null"
  
    %u
  
    Unsigned integer
  
    %l
  
    Unsigned long integer

*/

extern char * HTSQL_printf (char * buf, int length, char * fmt, ...);

/*
.
  Issuing a Query
.

You can issue a query using this function. If the connection to the server
was dropped then it automatically tries to reconnect
*/

extern BOOL HTSQL_query (HTSQL * me, const char * query);

/*

Get information about the last inserted row's unique ID or how many rows
were affected by the last query:
*/

extern int HTSQL_getLastInsertId (HTSQL * me);
extern int HTSQL_GetAffectedRows (HTSQL * me);

/*
.
  Handle Query Results
.

Call this funciton to store the SQL query result
*/

extern MYSQL_RES * HTSQL_storeResult (HTSQL * me);

/*

When you are done with a query result then call this to clean up
*/

extern BOOL HTSQL_freeResult (MYSQL_RES * me);

/*
*/

#endif

/*

  

  @(#) $Id: HTSQL.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTSQLLog.h
::::::::::::::
/*

  					W3C Sample Code Library libwww SQL Log Class


!
  SQL Log Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This SQL based log class generates a SQL database and a set of tables storing
the results of a request. The result is stored in different tables depending
on whether it is information about the request or the resource returned.
The module uses the simple libwww SQL interface

This requires that you have linked against a MySQL
library. See the installation instructions
for details.

This module is implemented by HTSQLLog.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTSQLLOG_H
#define HTSQLLOG_H

#include "HTReq.h"

/*
.
  Open and Close the Logs
.

Create a new SQLLog object and connect to the SQL server.
*/

typedef struct _HTSQLLog HTSQLLog;

typedef enum _HTSQLLogFlags {
    HTSQLLOG_CLEAR_URIS_TABLE 		= 0x1,
    HTSQLLOG_CLEAR_LINKS_TABLE		= 0x2,
    HTSQLLOG_CLEAR_REQUESTS_TABLE	= 0x4,
    HTSQLLOG_CLEAR_RESOURCES_TABLE	= 0x8,
    HTSQLLOG_DROP_URIS_TABLE 		= 0x10,
    HTSQLLOG_DROP_LINKS_TABLE		= 0x20,
    HTSQLLOG_DROP_REQUESTS_TABLE	= 0x40,
    HTSQLLOG_DROP_RESOURCES_TABLE	= 0x80
} HTSQLLogFlags; 

extern HTSQLLog * HTSQLLog_open (const char * 	host,
				 const char * 	user,
				 const char * 	pw,
				 const char * 	db,
				 HTSQLLogFlags 	flags);

/*
.
  Close Connection to the SQL Server
.

Close the log file and delete the log object
*/

extern BOOL HTSQLLog_close (HTSQLLog * me);

/*
.
  Write Logdata to the Database
.
(
  Add a Log Entry
)
*/

extern BOOL HTSQLLog_addEntry (HTSQLLog * me, HTRequest * request, int status);

/*
(
  Add a Link Relationship Entry
)
*/

extern BOOL HTSQLLog_addLinkRelationship (HTSQLLog * me,
					  const char * src_uri,
					  const char * dst_uri,
					  const char * link_type,
                                          const char * comment);

/*
.
  Options and Flags
.
(
  Make URIs Relative to this Base
)

Instead of inserting the absolute URI then you can log relative URIs instead
which often saves a lot of space. Set the base URI using this function
*/

extern BOOL HTSQLLog_makeRelativeTo (HTSQLLog * me, const char * relative);

/*
(
  How many times has this Log Object Been Accessed?
)

This has nothing to do with the SQL database but merely returns the access
count number to the log or -1 if error.
*/

extern int HTSQLLog_accessCount (HTSQLLog * me);

/*
*/

#endif

/*

  

  @(#) $Id: HTSQLLog.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTStream.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Generic Stream Class


!
  Generic Stream Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Stream class defines objects which accepts a sequence of characters.
Streams may also have an output in which case multiple stream objects can
be cascaded to build a stream pipe where the output of a stream is directed
into the input of the next stream object "down the line". Of course, one
of the main features of streams is that they can perform a data conversion
on the data before piping it to the output. As multiple streams may be
cascaded, the complete data conversion is then the sum of each individual
data conversion performed by the stream objects being part of the stream
pipe.

It is not required that a stream has a target, it might as well be
a black hole that just accepts data without ever giving it out again. The
generic stream class is subclassed multiple places in the Library and a good
example is the structured stream definition which
creates a SGML object.

All stream class methods return an integer status code telling whether the
operation succeeded or not.. This is the way for a stream to pass control
information upstream to the caller which may also be a stream. The general
return codes from the methods are:

	 
	   o 
	     HT_WOULD_BLOCK
  o 
	     HT_ERROR
  o 
	     HT_OK
  o 
	     >0 - any return greater than 0 will result in that the return code
    will be parsed through all stream objects. This can be used to pass back
    information to the protocol modules, for example

	 
It is in general not relevant to return how much data has been written in
the stream, as there often will be a relationship other than 1:1 between
indata and outdata. However, it is important that a stream keeps state (either
on the incoming data or the outgoing data stream) so that it can accept a
HT_WOULD_BLOCK and continue at a later time when the blocking
situation has stopped.

This module is implemented by HTStream.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTSTREAM_H
#define HTSTREAM_H

#include "HTList.h"

typedef struct _HTStream HTStream;

typedef struct _HTStreamClass {

    char * name;

/*

This field is for diagnostics only
*/

    int (*flush)	(HTStream * me);

/*

The flush method is introduced in order to allow the stream to put
any buffered data down the stream pipe but without taking the stream pipe
down. It is for the stream to decide whether it has buffered data or not.
In some situations, the stream might not want to send buffered data down
the target as the date might be relevant for this stream only.
*/

    int (*_free)	(HTStream * me);

/*

The free method is like the flush method but it also
frees the current stream object and all stream objects down stream. When
the free method has been called, the whole stream pipe
(not only this obejct) should not accept any more data.
*/

    int (*abort)	(HTStream * me, HTList * errorlist);

/*

The abort method should only be used if a stream is interrupted, for
example by the user, or an error occurs.
*/

    int (*put_character)(HTStream * me, char ch);
				
    int (*put_string)	(HTStream * me, const char * str);

    int (*put_block)	(HTStream * me, const char * str, int len);

/*

These methods are for actually putting data down the stream. It is important
that the most efficient method is chosen (often put_block). There is no guarantee
that a stream won't change method, for example from
put_character to put_block
*/

} HTStreamClass;

/*


.
  Basic Utility Streams
.

These streams can be plugged in everywhere in a stream pipe.
(
  Black Hole Stream
)

This stream simply absorbs data without doing anything what so ever.
*/

extern HTStream * HTBlackHole (void);

/*
(
  Generic Error Stream
)

The Error stream simply returns HT_ERROR on all methods. This
can be used to stop a stream as soon as data arrives, for example from the
network.
*/

extern HTStream * HTErrorStream (void);

/*
*/

#endif /* HTSTREAM_H */

/*

  

  @(#) $Id: HTStream.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTString.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Generic String Management


!
  Generic String Management
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

These functions provide functionality for case-independent string comparison
and allocations with copies etc.

This module is implemented by HTString.c, and it
is a part of the W3C
Sample Code Library.
*/

#ifndef HTSTRING_H
#define HTSTRING_H

/*
.
  Dynamic String Manipulation
.

These two functions are dynamic versions of strcpy and
strcat. They use malloc for allocating space for
the string. If StrAllocCopy is called with a non-NULL dest,
then this is freed before the new value is assigned so that only the
last string created has to be freed by the user. If
StrAllocCat is called with a NULL pointer as destination then
it is equivalent to StrAllocCopy. 
*/

#define StrAllocCopy(dest, src) HTSACopy (&(dest), src)
#define StrAllocCat(dest, src)  HTSACat  (&(dest), src)

extern char * HTSACopy (char **dest, const char *src);
extern char * HTSACat  (char **dest, const char *src);

/*

The next two functions take a variable number of strings and cats them together
using dynamic memory. This is basically like a simple form for sprintf where
the only argument is char *. One day we should turn this into
a real dynamic sprintf().
*/

extern char * StrAllocMCopy (char ** dest, ...);
extern char * StrAllocMCat (char ** dest, ...);

/*

The last argument MUST be NULL as we otherwise don't know when the argument
list stops.
.
  Case-insensitive String Comparison
.

The usual routines (comp instead of cmp) had some problem.
*/

extern int strcasecomp  (const char *a, const char *b);
extern int strncasecomp (const char *a, const char *b, int n);

/*
.
  Tail String Comparison
.

Like strcmp, but match the tail of s2 (used for cookie domain comparison)
*/

extern int tailcomp(const char * s1, const char * s2);
extern int tailcasecomp(const char * s1, const char * s2);

/*
.
  String Comparison with Wild Card Match
.

String comparison function for file names with one wildcard * in the template.
Arguments are:

  
    tmpl
  
    is a template string to match the name against. agaist, may contain a single
    wildcard character * which matches zero or more arbitrary characters.
  
    name
  
    is the name to be matched agaist the template.


Returns empty string ("") if perfect match, pointer to part matched by wildcard
if any, or NULL if no match. This is basically the same as YES if match,
else NO.
*/

extern char * HTStrMatch	(const char * tmpl, const char * name);
extern char * HTStrCaseMatch	(const char * tmpl, const char * name);

/*
.
  Case-insensitive strstr
.

This works like strstr() but is not case-sensitive.
*/

extern char * HTStrCaseStr (char * s1, char * s2);

/*
.
  Strip white space off a string
.

Return value points to first non-white character, or to '/0' if none. All
trailing white space is OVERWRITTEN with zero.
*/

extern char * HTStrip (char * s);

/*
*/

#endif /* !HTSTRING_H */

/*

  

  @(#) $Id: HTString.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTStruct.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Structured Stream Class


!
  Structured Stream Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Structured stream class defines objects which accepts a structured
sequence of characters for eaxmple a SGML document. I'll rephrase that. A
structured object is am ordered tree-structured arrangement of data which
is representable as text. An example is the SGML parser
which outputs to a Structured Object. A Structured object can output its
contents to another Structured Object. It's a kind of typed
stream. The architecure is largely Dan Conolly's. Elements and entities are
passed to the sob by number, implying a knowledge of the DTD.

The Structured Stream is a subclass of a
Generic Stream Object. As always, we don't have
classes in basic C so we have to do this by hand!

This module is a part of the 
W3C Sample Code Library.
*/
#ifndef HTSTRUCT_H
#define HTSTRUCT_H

#include "HTStream.h"
#include "HTList.h"


/*
*/
typedef struct _HTStructured HTStructured;

typedef struct _HTStructuredClass {

    char * name;

    int (*flush)	(HTStructured * me);

    int (*_free)	(HTStructured *	me);

    int (*abort)	(HTStructured *	me, HTList * errorlist);

    int (*put_character)(HTStructured *	me, char ch);

    int (*put_string)	(HTStructured *	me, const char * str);

    int (*put_block)	(HTStructured * me, const char * str, int len);

/*

See the Generic Stream Definition for an explanation
of these methods. Note that they all have a HTStructured object
a the parameter, not a generic stream. This is to avoid incompatible
pointer warnings
*/

    void (*start_element)(HTStructured *me,
			  int		element_number,
			  const BOOL *	attribute_present,
			  const char **	attribute_value);

    void (*end_element)	(HTStructured *	me, int element_number);

    void (*put_entity)	(HTStructured *	me, int entity_number);

    int (*unparsed_begin_element)(HTStructured * me, const char * str, int len);

    int (*unparsed_end_element)(HTStructured * me, const char * str, int len);

    int (*unparsed_entity)(HTStructured * me, const char * str, int len);
		
} HTStructuredClass;

#endif

/*

  

  @(#) $Id: HTStruct.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTStyle.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Stylesheet Manager


!
  Stylesheet Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Styles allow the translation between a logical property of a piece of text
and its physical representation. A StyleSheet is a collection of styles,
defining the translation necessary to represent a document. It is a linked
list of styles.

A stylesheet is a collection of styles - these styles can either come from
over the net or they can be provided by the application as needed.

The manager doesn't contain any styles - it only provides a mechanism for
registering styles, looking them up and deleting them. That is, it doesn't
have any idea of what a style actually looks like - as this is highly application
dependent, it is not a good idea to provide this as common library code.

This module is implemented by HTStyle.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTSTYLE_H
#define HTSTYLE_H

/*
.
  Creating and Deleting a StyleSheet
.

A Stylesheet is a container containing multiple individual styles. You must
therefore first create a stylesheet before you can create individual styles.
*/

typedef struct _HTStyleSheet HTStyleSheet;

extern HTStyleSheet * HTStyleSheet_new (const char * name);
extern BOOL HTStyleSheet_delete (HTStyleSheet * me);

/*
.
  Creating and Deleting Individual Styles
.
*/

typedef struct _HTStyle HTStyle;

extern HTStyle * HTStyle_new (const char * name, int element, void * context);
extern BOOL HTStyle_delete (HTStyle * me);

/*
.
  Adding and Deleting Individual styles from Stylesheet
.
*/

extern BOOL HTStyleSheet_addStyle (HTStyleSheet * me, HTStyle * style);
extern BOOL HTStyleSheet_deleteStyle (HTStyleSheet * me, HTStyle * style);

/*
.
  Searching for a Specific Style
.
*/

extern HTStyle * HTStyleSheet_findStyleWithName (HTStyleSheet * me, const char * name);
extern HTStyle * HTStyleSheet_findStyleForElement (HTStyleSheet * me, int element);

/*
*/

#endif /* HTSTYLE_H */

/*

  

  @(#) $Id: HTStyle.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTTChunk.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Chunked Transfer Encoding and Decoding


!
  Chunked Transfer Encoding and Decoding
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Chunked transfer encoding and decoding is new in HTTP/1.1. It allows applications
to use persistent connections while not knowing the content length a priori
to the response header is generated.

Both the encoder and the decoder are of type
HTCoder which is defined in the
Stream Pipe Builder. This means that bot the
encoder and the decoder are registered dynamically and called by the Stream
Pipe Builder if required.

Note: These streams are not set up by default. They must be
registered by the application. You can use the default initialization function
HTEncoderInit() function in the
initialization interface.

This module is implemented by HTTChunk.c, and it
is a part of the  W3C Sample Code
Library.

*/
#ifndef HTTCHUNK_H
#define HTTCHUNK_H

#include "HTFormat.h"

/*
*/

extern HTCoder HTChunkedDecoder, HTChunkedEncoder;

/*
*/

#endif /* HTTCHUNK_H */

/*

  

  @(#) $Id: HTTChunk.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTTCP.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Socket Open and Close


!
  Socket Open and Close
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Socket Open and Close methods knows how to establish a BSD socket TCP
connection and is part of the Transport interface.

This module is implemented by HTTCP.c, and it is a
part of the W3C Sample Code
Library.
*/

#ifndef HTTCP_H
#define HTTCP_H
#include "HTReq.h"
#include "HTNet.h"

/*
.
  Active Connection Establishment
.

This makes an active connect to the specified host. An
HTNet Object is parsed in order to handle errors
and other stuff. The default port might be overwritten by any port indication
in the URL specified
as <host>:<port> If it is a multihomed host (a
host having multiple IP-addresses with the same host name) &nbsp;then
HTDoConnect() measures the time it takes to connect and updates
the calculated weights in the DNS object.
*/

extern int HTDoConnect (HTNet * net);

/*
.
  Passive Connection Establishment
.

This function makes an accept on a port. The net must contain
a valid socket to accept on. If accept is OK then we duplicate the
net object and assign the accepted socket to the newly created net object.
The original Net object will keep accepting connections
on the original socket, for example port 80 in the case of
HTTP. The newly created Net object will be freed
when the protocol module has finished. If the
accepted net object pointer points to the net object itself, that
is - the same object all along - then we reuse the same Net obejct; closes
the original socket and replaces it wik the accepted one. This is a quick
way of accepting a single connection.
*/

extern int HTDoAccept (HTNet * listen, HTNet * accept);

/*
.
  Listen on a Socket
.

Listens on the specified port described in the Net
object. backlog is the number of connections that can be
queued on the socket - you can use HT_BACKLOG for a
platform dependent value (typically 5 on BSD and 32 on SVR4). Returns
HT_ERROR or HT_OK.
*/

extern int HTDoListen (HTNet * net, HTNet * accept, int backlog);

/*
.
  Closing a socket
.

Closes a socket
*/

extern int HTDoClose (HTNet * net);

/*
*/

#endif   /* HTTCP_H */

/*

  

  @(#) $Id: HTTCP.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTTee.h
::::::::::::::
/*

					W3C Sample Code Library libwww T Stream




!Tee stream!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Tee stream just writes everything you put into it into two other
streams. One use (the only use?!) is for taking a cached copey on disk
while loading the main copy, without having to wait for the disk copy
to be finished and reread it. 

You can create a T stream using this method. Each stream returns a
return value and in order to resolve conflicts in the return code you
can specify a resolver callback function. Each time any of the data
methods are called the resolver function is then called with the
return codes from the two streams. The return code of the T stream
itself will be the result of the resolver function. If you pass NULL
as the resolver routine then a default resolver is used.

This module is implemented by HTTee.c, and it is
a part of the  W3C
Sample Code Library.

*/

#ifndef _HTTEE_H
#define _HTTEE_H

#include "HTStream.h"
#include "HTArray.h"

extern HTStream * HTTee (HTStream * s1, HTStream * s2, HTComparer * resolver);

#endif /* HTTEE_H */

/*



@(#) $Id: HTTee.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTTelnet.h
::::::::::::::
/*

					W3C Sample Code Library libwww TELNET, RLOGIN ETC.




!Telnet and similar access methods!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is implemented by HTTelnet.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTTELNET_H
#define HTTELNET_H

#include "HTProt.h"

extern HTProtCallback HTLoadTelnet;

#endif

/*



@(#) $Id: HTTelnet.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTTeXGen.h
::::::::::::::
/*

					W3C Sample Code Library libwww HTML TO LATEX CONVERTER STREAM




!LaTeX generator!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module converts a structured stream from HTML into LaTeX format. The
conversion is mostly a 1:1 translation, but as the LaTeX compiler is much
more strict than a typical HTML converter some typographical constraints
are put on the translation. Only text is translated for the moment. 

This module is implemented by HTTeXGen.c, and
it is a part of the 
W3C Sample Code Library.

*/

#ifndef HTTEXGEN_H
#define HTTEXGEN_H
#include "HTStruct.h"
#include "HTFormat.h"

/*

.Conversion Module.

The conversion module is defined as

*/

extern HTConverter HTMLToTeX;

/*

*/

#endif

/*



@(#) $Id: HTTeXGen.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTTimer.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Timer Class


!
  The Timer Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Timer class handles timers for libwww and the application. This works
exactly as in X where you create a timer object with a callback function
and a timeout. The callback will be called every time the timer expires.
There are several timeouts that can be set in libwww:

  o 
	     The time we keep an idle persistent connection open. Here there are in fact
	     two mechanisms depending on whether you use blocking or non-blocking sockets.
	     The default is 60 secs. The timers can be accessed using the functions defined
	     in the HTHost object
  o 
	     The idle time we want to wait when receiving a response from a server, that
	     is, if it doesn't send anything in a number of secs. The default here is
	     no timeout. It can be accessed in the
	     HTHost object as well.
  o 
	     The timeout before we flush pending requests in a pipeline, the default here
	     is 30 ms. It is also accessed in the HTHost
    object
  o 
	     The timeout before we start sending the body of a PUT or
    POST request. Normally we send the Expect: 100-continue
    header field but if the server doesn't send back a 100 Continue
    code then we upload the body anyway. The default is 2 secs and can be accessed
    in the HTTP module.

*/

#ifndef HTTIMER_H
#define HTTIMER_H

#include "wwwsys.h"
#include "HTReq.h"

typedef struct _HTTimer HTTimer;

typedef int HTTimerCallback (HTTimer *, void *, HTEventType type);

/*
.
  Create and Delete Timers
.

The callback function is the function that is to be called when timer expires.
*/

extern HTTimer * HTTimer_new (HTTimer *, HTTimerCallback *, 
			      void *, ms_t millis,
                              BOOL relative, BOOL repetitive);
extern BOOL HTTimer_delete (HTTimer * timer);
extern BOOL HTTimer_deleteAll (void);
extern BOOL HTTimer_expireAll (void);

/*
.
  Dispatch Timer
.

Just do it
*/

extern int HTTimer_dispatch (HTTimer * timer);

/*
(
  Get the next timer in line
)

Dispatches all expired timers and optionally returns the time till the next
one.
*/

extern int HTTimer_next (ms_t * pSoonest);

/*
(
  Reset an already existing Repetitive Timer
)
*/

extern BOOL HTTimer_refresh(HTTimer * timer, ms_t now);

/*
.
  Get Information about a Timer Object
.
(
  Absolute Time when This Timer Expires
)

Absolute time in millies when this timer will expire
*/

extern ms_t HTTimer_expiresAbsolute (HTTimer * timer);

/*
(
  Relative Time this Timer is running
)

Gived the relative time in millies that this timer was registered with. For
example, a relative timer set to expire in 20ms will return 20.
*/

#define HTTimer_getTime(t)	HTTimer_expiresRelative(t)
extern ms_t HTTimer_expiresRelative (HTTimer * timer);

/*
(
  Has this Timer Expired?
)

If so then it's time to call the dispatcher!
*/

extern BOOL HTTimer_hasTimerExpired (HTTimer * timer);

/*
(
  What callback is this Timer Registered with?
)
*/

extern HTTimerCallback * HTTimer_callback (HTTimer * timer);

/*
(
  Is this Time relative or Absolute?
)
*/

extern BOOL HTTimer_isRelative (HTTimer * timer);

/*
.
  Platform Specific Timers
.

On some platform, timers are supported via events or other OS specific
mechanisms. You can make libwww can support these by registering a platform
specific timer add and timer delete method.
*/

typedef BOOL HTTimerSetCallback (HTTimer * timer);

extern BOOL HTTimer_registerSetTimerCallback (HTTimerSetCallback * cbf);
extern BOOL HTTimer_registerDeleteTimerCallback (HTTimerSetCallback * cbf);

/*
*/

#endif /* HTTIMER_H */

/*

  

  @(#) $Id: HTTimer.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTTPGen.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww HTTP General Header Stream


!
  HTTP General Header Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The HTTP General Header stream generates the general headers of a HTTP request
or response and writes it to the target which is normally either a HTTP response
stream or a HTTP request stream.

This module is implemented by HTTPGen.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTTPGEN_H
#define HTTPGEN_H

#include "HTStream.h"
#include "HTReq.h"

/*
(
  Streams Definition
)

This stream makes a general HTTP header before it goes into transparent mode.
If endHeader is YES then we send an empty CRLF
in order to end the header.
*/

extern HTStream * HTTPGen_new  (HTRequest * request, HTStream * target,
				BOOL endHeader, int version);

/*
*/

#endif

/*

  

  @(#) $Id: HTTPGen.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTTP.h
::::::::::::::
/* 

  
  					W3C Sample Code Library libwww HTTP Client


!
  Multi Threaded HyperText Tranfer Protocol Client Module
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the HTTP client module. This is actually a very small definition
file as almost everything is set up elsewhere.

This module is implemented by HTTP.c, and it is a part
of the W3C Sample Code Library.
*/

#ifndef HTTP_H
#define HTTP_H

#include "HTProt.h"
#include "HTStream.h"

/*
(
  HTTP Client Connection Mode
)

The HTTP client module supports various modes for communicating with HTTP
servers. The mode are defined by the enumeration below.
*/

typedef enum _HTTPConnectionMode { 
    HTTP_11_PIPELINING     = 0x1,
    HTTP_11_NO_PIPELINING  = 0x2, 
    HTTP_11_MUX            = 0x4,
    HTTP_FORCE_10          = 0x8
} HTTPConnectionMode; 

extern void HTTP_setConnectionMode (HTTPConnectionMode mode);
extern HTTPConnectionMode HTTP_connectionMode (void);

/*
(
  HTTP Write Delay of Content Bodies
)

Because of the differences between HTTP/1.0 and HTTP/1.1, HTTP PUT
and POST requests can not be dealt with in non-preemptive mode -
they have to use timers and hence must be in preemptive mode.

The default write mechanism used is first to write the headers and then wait
for a period of time before writing the body. This often allows the server
to respond before we start sending data accross the wire. If the write for
some reason fails in a bad way then we try again, waiting a little bit longer
this time as this may give the server enough time to think.

The default wait periods are 2000ms for the first wait and 3000ms if that
fails. These are rather conservative values but can be changed by using these
functions. The second try value must be larger (or equal) to the first try
value and the first try value must be larger than 20 ms.
*/
extern BOOL HTTP_setBodyWriteDelay (ms_t first_try, ms_t second_try);
extern void HTTP_bodyWriteDelay (ms_t * first_try, ms_t * second_try);

/*
(
  HTTP Event Handler
)

The event handler is the actual HTTP client state machine taking care of
the communication.
*/

extern HTProtCallback HTLoadHTTP;
extern HTConverter HTTPStatus_new;

#endif /* HTTP_H */

/*

  

  @(#) $Id: HTTP.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTTPReq.h
::::::::::::::
/*

					W3C Sample Code Library libwww HTTP REQUEST STREAM




!HTTP Request Stream!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The HTTP Request stream generates a HTTP request header and writes it
to the target which is normally a HTWriter stream.

This module is implemented by HTTPReq.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTTPREQ_H
#define HTTPREQ_H

#include "HTStream.h"
#include "HTReq.h"

/*

(Streams Definition)

This stream makes a HTTP request header before it goes into
transparent mode. If endHeader is YES then we send an
empty CRLF in order to end the header.

*/

extern HTStream * HTTPRequest_new (HTRequest * request, HTStream * target,
				   BOOL endHeader, int version);

/*

*/

#endif

/*



@(#) $Id: HTTPReq.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTTPRes.h
::::::::::::::
/*

					W3C Sample Code Library libwww HTTP RESPONSE STREAM




!HTTP Response Stream!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The HTTP response stream generates a HTTP response header and writes
it to the target which is normally a HTWriter stream.

This module is implemented by HTTPRes.c, and
it is a part of the  W3C
Sample Code Library.

*/

#ifndef HTTPRES_H
#define HTTPRES_H

#include "HTStream.h"
#include "HTReq.h"

/*

(Streams Definition)

This stream makes a server specific HTTP header before it goes into
transparent mode. If endHeader is YES then we send an
empty CRLF in order to end the header.

*/

extern HTStream * HTTPResponse_new (HTRequest *	request, HTStream * target,
				    BOOL endHeader, int version);

/*

*/

#endif

/*



@(#) $Id: HTTPRes.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTTPServ.h
::::::::::::::
/*

					W3C Sample Code Library libwww HTTP SERVER




!HTTP Server Module!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is actually a very small definition file as almost everything is
set up elsewhere. 

This module is implemented by HTTPServ.c, and
it is a part of the W3C
Sample Code Library. 

*/

#ifndef HTTPSERV_H
#define HTTPSERV_H

#include "HTProt.h"

extern HTProtCallback HTServHTTP;

#endif /* HTTPSERV_H */

/*



@(#) $Id: HTTPServ.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTTPUtil.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww HTTP COMMON


!
  HTTP Communalities between Server and Client Module
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The HTTP client module and the
server module has a few things in common which
we keep in this file.
*/
#ifndef HTTPUTIL_H
#define HTTPUTIL_H

/*
(
  HTTP Version Management
)
*/

typedef enum _HTTPVersion {
    HTTP = 0,
    HTTP_09,		
    HTTP_10,
    HTTP_11,
    HTTP_12
} HTTPVersion;

/*
(
  Versions supported by HTTP
)
*/

#define HTTP_VERSION_10	"HTTP/1.0"
#define HTTP_VERSION	"HTTP/1.1"

/*
*/

#endif

/*

  

  @(#) $Id: HTTPUtil.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTTrans.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Transport Class


!
  The Transport Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Transport Class defines a transport as used by the
HTChannel class to communicate with the network,
the local file system etc. New transport objects may be registered at any
time. This allows the application to easily hook in its own transport layers.
The purpose of the HTTransport object is to contain transport dependent methods
for opening and closing a connection to the transport and also to get an
input stream and an output strean for reading and writing to the transport
respectively.

Note: The library core does not &nbsp;define any default transport
objects - they are all considered part of the application. The library comes
with a default set of transports which can be initiated using the function
HTTransportInit() in HTInit module

This module is implemented by HTTrans.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTTRANS_H
#define HTTRANS_H

/*
.
  Creation and Deletion Methods
.

All transport interfaces are registered dynamically in libwww. This means
that libwww is independent of the transport being used (TCP, for example),
and you can therefore use libwww in any context you like. You have to specify
a set of parameters in order for libwww to be able to use it. The transport
class is defined as follows:
*/

typedef struct _HTTransport HTTransport;

typedef enum _HTTransportMode {
    HT_TP_SINGLE	= 0,		/* One single request at a time */
    HT_TP_PIPELINE	= 1,		/* Use pipelined requests */
    HT_TP_INTERLEAVE	= 2		/* Can we interleave requests? */
} HTTransportMode;

#include "HTIOStream.h"
#include "HTReq.h"

/*
(
  Add a Transport
)

A new transport can be registered at any time in the Library. You must specify
a name ad the supported channel mode that the transport supports. Then you
must also register two creation methods of an input and an output stream
respectively. You can find the definition of the I/O streams in the
HTIOStream module.
*/

extern BOOL HTTransport_add (const char *		name,
			     HTTransportMode		mode,
			     HTInput_new *		get_input,
			     HTOutput_new *		get_output);

/*
(
  Delete a Transport
)

This functions deletes a registered protocol module so that it can not be
used for accessing a resource anymore.
*/

extern BOOL HTTransport_delete (const char * name);

/*
(
  Remove ALL Registered Transports
)

This is the garbage collection function. It is called by
HTLibTerminate()
*/

extern BOOL HTTransport_deleteAll (void);

/*
.
  Transport Class Methods
.
(
  Find a Transport Protocol Object
)

You can search the list of registered protocol objects as a function of the
access acheme. If an access scheme is found then the protocol object is returned.
*/

extern HTTransport * HTTransport_find (HTRequest * request, const char * name);

/*
(
  Supported Transort Modes
)

A transport object is registered with the flow control
mode that it supports. This mode describes whether we can issue multiple
requests at the same time.
*/

extern HTTransportMode HTTransport_mode (HTTransport * tp);
extern BOOL HTTransport_setMode (HTTransport * tp, HTTransportMode mode);

/*
(
  Input and Output Stream Creation Methods
)
*/

struct _HTTransport {
    char *		name;
    HTTransportMode	mode;			      /* Flow mode supported */
    HTInput_new *	input_new; 	     /* Input stream creation method */
    HTOutput_new *	output_new;	    /* Output stream creation method */
};

/*
*/

#endif /* HTTRANS_H */

/*

  

  @(#) $Id: HTTrans.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTUser.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww User Profile Class


!
  The User Profile Class
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The User profile&nbsp;class manages what we know about a user on this
host. This can for example be the FQDN of the host, the user's email
address, the time zone, the news server etc. Note that this information does
not correspond to the actual information for the host but instead represents
"the information that the user wants to show the world". The user may use
an arbitrary email address to be used in a HTTP
request, for example. The application may assign a context to each use
which gives the application to extend the use of this class.

This module is implemented by HTUser.c, and it is
a part of the W3C Sample Code
Library.
*/

#ifndef HTUSER_H
#define HTUSER_H

typedef struct _HTUserProfile HTUserProfile;

/*
.
  Creation and Deletion Methods
.

The application may create any number of user profile objects. By default
the Library creates a generic user which is the default value used to initialize
a Request object. This can be replaced by other
user profiles at any point in time.
(
  Create a User Profile
)
*/
extern HTUserProfile * HTUserProfile_new (const char * name, void * context);

/*
(
  Localize a User Profile
)

Localize a user profile by filling in all the information that we can figure
out automatically, for example the email address, news server etc.
*/
extern BOOL HTUserProfile_localize (HTUserProfile * up);

/*
(
  Delete a User Profile
)
*/
extern BOOL HTUserProfile_delete (HTUserProfile * up);

/*
.
  User Profile Class Methods
.
(
  Fully Qualified Domain Name (FQDN)
)

The FQDN is a fully qualified domain name in that it contains both a local
host name and the domain name. It turns out that this is in fact very difficult
to obtain a FQDN on a variety of platforms.
*/

extern char * HTUserProfile_fqdn (HTUserProfile * up);
extern BOOL HTUserProfile_setFqdn (HTUserProfile * up, const char * fqdn);

/*
(
  User Email Address
)

This is the email address that the user wants to send out for example as
a "password" when using anonymous FTP access and
as a "From" field in a HTTP request.
*/

extern char * HTUserProfile_email (HTUserProfile * up);
extern BOOL HTUserProfile_setEmail (HTUserProfile * up, const char * email);

/*
(
  News Server
)

Control the news server that this user wishes to use
*/

extern char * HTUserProfile_news (HTUserProfile * host);
extern BOOL HTUserProfile_setNews (HTUserProfile * host, const char * news);

/*
(
  Location of Temporary Files
)

Control the location for temporary files for this profile. The format
must be in URL format which is different from local file syntax as
URL syntaz always uses '/' as delimiters and also encoding of special
characters. See the
documentation on URLs
for more information about URL syntax.
*/

extern char * HTUserProfile_tmp (HTUserProfile * host);
extern BOOL HTUserProfile_setTmp (HTUserProfile * host, const char * tmp);

/*
(
  Local Time Zone (in seconds)
)

Another widely used piece information that is very hard toobtain is the local
time zone. As we often must convert to and from GMT (Universal Time) we must
have the correct time zone. If we for some reason guesses wrong then the
user must change it manually.
*/

extern time_t HTUserProfile_timezone (HTUserProfile * up);
extern BOOL HTUserProfile_setTimezone (HTUserProfile * up, time_t timezone);

/*
(
  User Profile Context
)

The applicatoin may have additional information that it wishes to assign
to a user profile. It can do this using the user context which is handled
as follows:
*/

extern void * HTUserProfile_context (HTUserProfile * up);
extern BOOL HTUserProfile_setContext (HTUserProfile * up, void * context);

/*
*/

#endif /* HTUser_H */

/*

  

  @(#) $Id: HTUser.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTUtils.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Debug Information and General Purpose
  Macros


!
  Debug Information and General Purpose Macros
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is a part of the  W3C Sample
Code Library. See also the system dependent file
sysdep module for system specific information.
*/

#ifndef HTUTILS_H
#define HTUTILS_H

/*
.
  Destination for User Print Messages
.

You can send print messages to the user to various destinations
depending on the type of your application. By default, on Unix the
messages are sent to stdout using
fprintf. If we are on MSWindows and have a windows
applications then register a HTPrintCallback
function. This is done with HTPrint_setCallback. It tells
HTPrint to call a HTPrintCallback. If
HTDEBUG
is not defined then don't do any of the above.
*/

typedef int HTPrintCallback(const char * fmt, va_list pArgs);
extern void HTPrint_setCallback(HTPrintCallback * pCall);
extern HTPrintCallback * HTPrint_getCallback(void);

extern int HTPrint(const char * fmt, ...);

/*
.
  Debug Message Control
.

This is the global flag for setting the WWWTRACE options.
The verbose mode is no longer a simple boolean but a bit field so that it
is possible to see parts of the output messages.
*/

#if defined(NODEBUG) || defined(NDEBUG) || defined(_NDEBUG)
#undef HTDEBUG
#else
#ifndef HTDEBUG
#define HTDEBUG		1
#endif /* HTDEBUG */
#endif

/*
(
  C Preprocessor defines
)

Make sure that the following macros are defined
*/

#ifndef __FILE__
#define __FILE__	""
#endif

#ifndef __LINE__
#define __LINE__	0L
#endif

/*
(
  Definition of the Global Trace Flag
)

The global trace flag variable is available everywhere.
*/

#ifdef HTDEBUG
/* @@@ Amaya change. Somehow WWW_WIN_DLL isn't defined */
#ifdef WWW_MSWINDOWS
#undef WWW_WIN_DLL
#endif /* WWW_MSWINDOWS */
#ifdef WWW_WIN_DLL
extern int *		WWW_TraceFlag;	 /* In DLLs, we need the indirection */
#define WWWTRACE	(*WWW_TraceFlag) 
#else
extern unsigned int	WWW_TraceFlag;	     /* Global flag for all W3 trace */
#define WWWTRACE	(WWW_TraceFlag)
#endif /* WWW_WIN_DLL */
#else
#define WWWTRACE	0
#endif /* HTDEBUG */

/*
(
  Select which Trace Messages to show
)

Libwww has a huge set of trace messages and it is therefor a good idea to
be able to select which ones to see for any particular trace. An easy way
to set this is using the funtion
HTSetTraceMessageMask. The WWWTRACE
define outputs messages if verbose mode is active according to the following
rules:
*/

typedef enum _HTTraceFlags {
    SHOW_UTIL_TRACE	= 0x1,
    SHOW_APP_TRACE	= 0x2,
    SHOW_CACHE_TRACE	= 0x4,
    SHOW_SGML_TRACE	= 0x8,
    SHOW_BIND_TRACE	= 0x10,
    SHOW_THREAD_TRACE	= 0x20,
    SHOW_STREAM_TRACE	= 0x40,
    SHOW_PROTOCOL_TRACE = 0x80,
    SHOW_MEM_TRACE	= 0x100,
    SHOW_URI_TRACE	= 0x200,
    SHOW_AUTH_TRACE	= 0x400,
    SHOW_ANCHOR_TRACE	= 0x800,
    SHOW_PICS_TRACE	= 0x1000,
    SHOW_CORE_TRACE	= 0x2000,
    SHOW_MUX_TRACE      = 0x4000,
    SHOW_SQL_TRACE      = 0x8000,
    SHOW_XML_TRACE      = 0x10000,
    SHOW_ALL_TRACE	= (int) 0xFFFFFFFF
} HTTraceFlags;

/*

The flags are made so that they can serve as a group flag for correlated
trace messages, e.g. showing messages for SGML and HTML at the same time.
*/

#define UTIL_TRACE	(WWWTRACE & SHOW_UTIL_TRACE)
#define APP_TRACE	(WWWTRACE & SHOW_APP_TRACE)
#define CACHE_TRACE	(WWWTRACE & SHOW_CACHE_TRACE)
#define SGML_TRACE	(WWWTRACE & SHOW_SGML_TRACE)
#define BIND_TRACE	(WWWTRACE & SHOW_BIND_TRACE)
#define THD_TRACE	(WWWTRACE & SHOW_THREAD_TRACE)
#define STREAM_TRACE	(WWWTRACE & SHOW_STREAM_TRACE)
#define PROT_TRACE	(WWWTRACE & SHOW_PROTOCOL_TRACE)
#define MEM_TRACE	(WWWTRACE & SHOW_MEM_TRACE)
#define URI_TRACE	(WWWTRACE & SHOW_URI_TRACE)
#define AUTH_TRACE	(WWWTRACE & SHOW_AUTH_TRACE)
#define ANCH_TRACE	(WWWTRACE & SHOW_ANCHOR_TRACE)
#define PICS_TRACE	(WWWTRACE & SHOW_PICS_TRACE)
#define CORE_TRACE	(WWWTRACE & SHOW_CORE_TRACE)
#define MUX_TRACE	(WWWTRACE & SHOW_MUX_TRACE)
#define SQL_TRACE	(WWWTRACE & SHOW_SQL_TRACE)
#define XML_TRACE	(WWWTRACE & SHOW_XML_TRACE)
#define ALL_TRACE	(WWWTRACE & SHOW_ALL_TRACE)

/*
(
  Destination for Trace Messages
)

You can send trace messages to various destinations depending on the type
of your application. By default, on Unix the messages are sent to
stderr using fprintf. If we are on MSWindows and
have a windows applications then register a HTTraceCallback
function. This is done with HTTrace_setCallback. It tells
HTTrace to call a HTTraceCallback. If 
HTDEBUG is not defined then don't do any of the above.
*/

typedef int HTTraceCallback(const char * fmt, va_list pArgs);
extern void HTTrace_setCallback(HTTraceCallback * pCall);
extern HTTraceCallback * HTTrace_getCallback(void);

/*

The HTTRACE macro uses "_" as parameter separater
instead of ",". This enables us to use a single macro instead
of a macro for each number of arguments which we consider a more elegant
and flexible solution. The implication is, however, that we can't have variables
that start or end with an "_" if they are to be used in a trace
message.
*/

#ifdef HTDEBUG
#undef _
#define _ ,
#define HTTRACE(TYPE, FMT) \
	do { if (TYPE) HTTrace(FMT); } while (0);
extern int HTTrace(const char * fmt, ...);
#else
#define HTTRACE(TYPE, FMT)		/* empty */
#endif /* HTDEBUG */

/*
(
  Data Trace Logging
)

A similar mechanism exists for logging data, except that is adds a data and
length argument to the trace call. Again, you can register your own callbacks
if need be.
*/

typedef int HTTraceDataCallback(char * data, size_t len, char * fmt, va_list pArgs);
extern void HTTraceData_setCallback(HTTraceDataCallback * pCall);
extern HTTraceDataCallback * HTTraceData_getCallback(void);

/*

Again we use the same macro expansion mechanism as for HTTrace
*/

#ifdef HTDEBUG
#define HTTRACEDATA(DATA, LEN, FMT) HTTraceData((DATA), (LEN), FMT)
extern int HTTraceData(char * data, size_t len, char * fmt, ...);
#else
#define HTTRACEDATA(DATA, LEN, FMT)	/* empty */
#endif /* HTDEBUG */

/*
(
  Debug Breaks
)

Call this function and the program halts. We use the same macro expansion
mechanism as for HTTrace
*/

extern void HTDebugBreak(char * file, unsigned long line, const char * fmt, ...);

#ifdef WWW_MSWINDOWS
/* @@@ change for amaya. This is to avoid the debugger kick in every time
  there are timeouts. We could change this in the timer code too */
#define HTDEBUGBREAK(FMT)               /* empty */
#else
#ifdef HTDEBUG
#define HTDEBUGBREAK(FMT) HTDebugBreak(__FILE__, __LINE__, FMT)
#else
#define HTDEBUGBREAK(FMT)		/* empty */
#endif /* HTDEBUG */
#endif /* WWW_MSWINDOWS */


/*
.
  Macros for Function Declarations
.

These function prefixes are used by scripts and other tools and helps figuring
out which functions are exported and which are not. See also the
libwww style guide.
*/

#define PUBLIC			/* Accessible outside this module     */
#define PRIVATE static		/* Accessible only within this module */

/*
.
  Often used Interger Macros
.
(
  Min and Max functions
)
*/

#ifndef HTMIN 
#define HTMIN(a,b) ((a) <= (b) ? (a) : (b))
#define HTMAX(a,b) ((a) >= (b) ? (a) : (b))
#endif

/*
(
  Double abs function
)
*/

#ifndef HTDABS
#define HTDABS(a) ((a) < 0.0 ? (-(a)) : (a))
#endif

/*


.
  Return Codes for Protocol Modules and Streams
.

Theese are the codes returned from the protocol modules, and the stream modules.
Success are (>=0) and failure are (<0)
*/

#define HT_OK			0	/* Generic success */
#define HT_ALL			1	/* Used by Net Manager */

#define HT_CONTINUE             100     /* Continue an operation */
#define HT_UPGRADE              101     /* Switching protocols */

#define HT_LOADED		200  	/* Everything's OK */
#define HT_CREATED  	        201     /* New object is created */
#define HT_ACCEPTED  	        202     /* Accepted */
#define HT_NO_DATA		204  	/* OK but no data was loaded */
#define HT_RESET_CONTENT        205     /* Reset content */
#define HT_PARTIAL_CONTENT	206  	/* Partial Content */

#define HT_MULTIPLE_CHOICES     300     /* Multiple choices */
#define HT_PERM_REDIRECT	301  	/* Permanent redirection */
#define HT_FOUND        	302  	/* Found */
#define HT_SEE_OTHER            303     /* See other */
#define HT_NOT_MODIFIED         304     /* Not Modified */
#define HT_USE_PROXY            305     /* Use Proxy */
#define HT_PROXY_REDIRECT       306     /* Proxy Redirect */
#define HT_TEMP_REDIRECT        307     /* Temporary redirect */

#define HT_IGNORE		900  	/* Ignore this in the Net manager */
#define HT_CLOSED		901  	/* The socket was closed */
#define HT_PENDING		902  	/* Wait for connection */
#define HT_RELOAD		903  	/* If we must reload the document */

#define HT_ERROR		-1	/* Generic failure */

#define HT_NO_ACCESS		-401	/* Unauthorized */
#define HT_FORBIDDEN		-403	/* Access forbidden */
#define HT_NOT_FOUND		-404	/* Not found */
#define HT_NOT_ACCEPTABLE	-406	/* Not Acceptable */
#define HT_NO_PROXY_ACCESS      -407    /* Proxy Authentication Failed */
#define HT_CONFLICT             -409    /* Conflict */
#define HT_LENGTH_REQUIRED      -411    /* Length required */
#define HT_PRECONDITION_FAILED  -412    /* Precondition failed */
#define HT_TOO_BIG              -413    /* Request entity too large */
#define HT_URI_TOO_BIG          -414    /* Request-URI too long */
#define HT_UNSUPPORTED          -415    /* Unsupported */
#define HT_BAD_RANGE            -416    /* Request Range not satisfiable */
#define HT_EXPECTATION_FAILED   -417    /* Expectation Failed */
#define HT_REAUTH               -418    /* Reauthentication required */
#define HT_PROXY_REAUTH         -419    /* Proxy Reauthentication required */

#define HT_RETRY		-503	/* If service isn't available */
#define HT_BAD_VERSION		-505	/* Bad protocol version */

#ifdef HT_DAV                           /* WebDAV Status codes */
#define HT_PROCESSING            102    /* Processing  */
#define HT_MULTI_STATUS          207    /* Multi-Status */
#define HT_UNPROCESSABLE        -422    /* Unprocessable Entity */  
#define HT_LOCKED               -423    /* Locked */
#define HT_FAILED_DEPENDENCY    -424    /* Failed Dependency */
#define HT_INSUFFICIENT_STORAGE -507    /* Insufficient Storage */
#endif

#define HT_INTERNAL		-900    /* Weird -- should never happen. */
#define HT_WOULD_BLOCK		-901    /* If we are in a select */
#define HT_INTERRUPTED 		-902    /* Note the negative value! */
#define HT_PAUSE                -903    /* If we want to pause a stream */
#define HT_RECOVER_PIPE         -904    /* Recover pipe line */
#define HT_TIMEOUT              -905    /* Connection timeout */
#define HT_NO_HOST              -906    /* Can't locate host */

/*
.
  Upper- and Lowercase macros
.

The problem here is that toupper(x) is not defined officially unless isupper(x)
is. These macros are CERTAINLY needed on #if defined(pyr) || define(mips)
or BDSI platforms. For safefy, we make them mandatory.
*/

#ifndef TOLOWER
#define TOLOWER(c) tolower((int) (c))
#define TOUPPER(c) toupper((int) (c))
#endif

/*
.
  Max and Min values for Integers and Floating Point
.
*/

#ifdef FLT_EPSILON				    /* The ANSI C way define */
#define HT_EPSILON FLT_EPSILON
#else
#define HT_EPSILON 0.00000001
#endif

/*
.
  The local equivalents of CR and LF
.

We can check for these after net ascii text has been converted to the local
representation. Similarly, we include them in strings to be sent as net ascii
after translation.
*/

#define LF   FROMASCII('\012')  /* ASCII line feed LOCAL EQUIVALENT */
#define CR   FROMASCII('\015')  /* Will be converted to ^M for transmission */

/*
.
  Library Dynamic Memory Magement
.

The Library has it's own dynamic memory API which is declared in
memory management module.
*/

#include "HTMemory.h"

/*
*/

#endif /* HT_UTILS.h */

/*

  

  @(#) $Id: HTUtils.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTUTree.h
::::::::::::::
/*


  					W3C Sample Code Library libwww URL Tress


!
  URL Trees
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

A URL tree is a hierarchical container class that is well suited for
storing information about a URL hierarchy. The root of a URL tree
is the hostname part of the URL, for example
www.w3.org:8000.&nbsp;Client application can use URL trees to
store what they know about remote servers, for example the access authentication,
PICS labels and PEP modules required to access a specific URL from a remote
server. However, URL trees can also be used on server side to contain information
about the server tree, for example what parts of the tree is protected etc.

There are three components of the URL tree which all can be searched for
using the methods declared in this module.
	 
	   o 
	     The Tree itself
	   o 
	     A URL Node which represents a hierarchy level in a URL
	   o 
	     A URL Template which can span multiple nodes and are very similar to the
	     realms known from for example Basic Access Authentication in HTTP.
	 
	 
Typically, a URL tree will be empty when the application starts and as time
goes by and we get to know more about the remote servers that we have access,
the URL trees will contain more and more information. A nice feature about
URL trees is that the application can interpolate information based on realms
and templates. This gives the application a good chance of guessing what
information (for example a set of credentials) should be appended to a new
request.

We do not currently distinguish between multiple access mechanisms, for example
HTTP and FTP, however, URL trees are mostly used within the
HTTP domain.

URL Trees are often used by filters which
stores information about remote services, Each filter can have its own URL
tree&nbsp;or a URL tree can be shared among multiple filters.

This module is implemented by HTUTree.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTUTREE_H
#define HTUTREE_H
#include "HTReq.h"

/*
.
  URL Trees
.

The three parts of a URL tree are called
*/

typedef struct _HTUTree     HTUTree;
typedef struct _HTURealm     HTURealm;
typedef struct _HTUTemplate HTUTemplate;

/*
(
  Create a URL Tree
)

Create a new authentication base Returns new object or NULL if error
*/


typedef int HTUTree_gc		(void * context);

extern HTUTree * HTUTree_new (const char * 		root,
			      const char * 		host,
			      int 			port,
			      HTUTree_gc *	 	gc);

/*
(
  Delete a URL Tree
)

Delete a complete server tree and everything within it.
*/

extern BOOL HTUTree_delete (const char * 	root,
			    const char * 	host,
			    int			port);

/*
(
  Delete ALL URL Trees
)

Delete all information bases
*/

extern BOOL HTUTree_deleteAll (void);

/*
(
  Find a URL Tree
)

Find a authentication base. Return NULL if not found
*/

extern HTUTree * HTUTree_find (const char *	root,
			       const char *	host,
			       int		port);

/*

.
  URL Nodes
.

*/

extern void * HTUTree_findNode (HTUTree * tree, 
                                const char * realm, const char * path); 

/*

*/

extern BOOL HTUTree_addNode (HTUTree * tree, 
                             const char * realm, const char * path, 
                             void * context);

/*


*/

extern BOOL HTUTree_replaceNode (HTUTree * tree, 
                                 const char * realm, const char * path, 
                                 void * context);

/*

*/

extern BOOL HTUTree_deleteNode (HTUTree * tree, 
                                const char * realm, const char * path);

/*


*/

#endif /* HTUTREE_H */

/*

  

  @(#) $Id: HTUTree.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTUU.h
::::::::::::::
/*

					W3C Sample Code Library libwww UU ENCODING AND DECODING




!Encoding to Printable Characters!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

File module provides functions HTUU_encode() and
HTUU_decode() which convert a buffer of bytes to/from RFC
1113 printable encoding format.

This technique is similar to the familiar Unix uuencode format in that
it maps 6 binary bits to one ASCII character (or more aptly, 3 binary
bytes to 4 ASCII characters).  However, RFC 1113 does not use the same
mapping to printable characters as uuencode. 

This module is implemented by HTUU.c, and it is a
part of the  W3C
Sample Code Library.

*/

#ifndef HTUU_H
#define HTUU_H


extern int HTUU_encode (unsigned char * bufin, unsigned int nbytes,
			char * bufcoded);

extern int HTUU_decode (char * bufcoded, unsigned char * bufplain,
			int outbufsize);

#endif

/*



@(#) $Id: HTUU.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTWAIS.h
::::::::::::::
/*

  					W3C Sample Code Library libwww WAIS Gateway


!
  WAIS Gateway Interface
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module does not actually perform the WAIS protocol directly, but it
does using one or more libraries of the freeWAIS distribution. The ui.a library
came with the old free WAIS from TMC, the client.a and wais.a libraries are
needed from the freeWAIS from CNIDR.

If you include this module in the library, you must also
	 
	   o 
	     Compile the Library by including the --with-wais directive in
    the configure script.
  o 
	     Have the WAIS Library available
	 
	 
The wais source files are parsed by a separate and independent module,
HTWSRC. You can include HTWSRC without
including direct wais using this module, and your WWW code will be able to
read source files, and access WAIS indexes through a gateway.

A WAIS-WWW gateway is just a normal
Web server with a libwww compiled with this module.

This module is implemented by HTWAIS.c, and it is
a part of the  W3C Sample Code
Library.
*/

#ifndef HTWAIS_H
#define HTWAIS_H

#include "HTEvent.h"

/*
.
  Control Flags
.

The number of lines handled from a WAIS search is determined by this variable.
The default value is 100 (this is defined in the module)
*/

extern int HTMaxWAISLines;

extern HTProtCallback HTLoadWAIS;

/*
*/

#endif

/*

  

  @(#) $Id: HTWAIS.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTWriter.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Unbuffered Socket Writer Stream


!
  Unbuffered Socket Writer Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Socket Writer Stream is an output stream
&nbsp;which knows how to write to a BSD type socket. It is part of the
Transport interface and may be registered as
part of a Transport Object. The application
can&nbsp;initialize this stream together with the
HTReader stream, for example. In the
default initialization module, you can find the
HTTransportInit() function which sets up this stream as a default
transport for handling unbuffered socket write operations. See also the
buffered writer stream.

This module is implemented by HTWriter.c, and it
is a part of the W3C Sample Code
Library.
*/

#ifndef HTWRITE_H
#define HTWRITE_H

#include "HTIOStream.h"


/*
*/
extern HTOutput_new HTWriter_new;

extern BOOL HTWriter_set (HTOutputStream *	me,
			  HTNet *		net,
			  HTChannel *		ch,
			  void *		param,
			  int			mode);


/*
*/
#endif

/*

  

  @(#) $Id: HTWriter.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
HTWSRC.h
::::::::::::::
/*

					W3C Sample Code Library libwww WAIS




!WAIS Source file parser!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This converter returns a stream object
into which a WAIS
source file can be written.  The result is put via a structured stream into whatever format was
required for the output stream. See also: HTWAIS protocol interface module.

This module is implemented by HTWSRC.c, and it
is a part of the  W3C
Sample Code Library.

*/

#ifndef HTWSRC_H
#define HTWSRC_H

#include "HTFormat.h"

extern  HTConverter HTWSRCConvert;

/*

.Escaping Strings.

HTDeSlash takes out the invlaid characters in a URL path ELEMENT by
converting them into hex-escaped characters.  HTEnSlash does the
reverse. Each returns a pointer to a newly allocated string which
must eventually be freed by the caller.

*/

extern char * HTDeSlash (const char * str);

extern char * HTEnSlash (const char * str);

#endif

/*



@(#) $Id: HTWSRC.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
HTWWWStr.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library libwww WWW String Utilities


!
  WWW Related String Management
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is like the generic string utility
module but it contains more Web related string utility functions. Examples
are functions that return a date string, a Message ID string
etc.

This module is implemented by HTWWWStr.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTWWWSTR_H
#define HTWWWSTR_H

#include "HTUser.h"
#include "HTAtom.h"

/*
.
  MIME Parsing and other String Based Utilities
.

A bunch of "finding the next whatever" functions.
(
  Next word or quoted string
)

This function returns a RFC822 word separated by space, comma, or semi-colons.
pstr points to a string containing a word separated by white
white space "," ";" or "=". The word can optionally be quoted using
 or "" Comments surrrounded by '(' ')' are filtered out. On exit,
pstr has been moved to the first delimiter past the field THE
STRING HAS BEEN MUTILATED by a 0 terminator. The function returns a pointer
to the first word or NULL on error
*/

extern char * HTNextField (char** pstr);

/*
(
  Next Name-value Pair
)

This is the same as HTNextField but it does not look for '='
as a separator so if there is a name-value pair then both parts are returned.
Returns a pointer to the first word or NULL on error
*/

extern char * HTNextPair (char ** pstr);

/*
(
  Next Name-value Parameter
)

This is the same as HTNextPair but it does not look for ','
as a separator so if there is a name-value pair then both parts are returned.
Returns a pointer to the first word or NULL on error
*/

extern char * HTNextParam (char ** pstr);

/*
(
  Next LWS Delimited Token
)

A simpler version of the above that only looks for linear white space as
the delimiter.
*/

extern char * HTNextLWSToken (char ** pstr);

/*
(
  Find next "/" Delimited Segment
)

This is the same as HTNextField but it includes "/" as a delimiter. Returns
a pointer to the first segment or NULL on error
*/

extern char * HTNextSegment (char ** pstr);

/*
(
  Next Comma Separated String (or Element)
)

This is the same as HTNextPair but it does not look for anything else than
',' as separator Returns a pointer to the first word or NULL on error
*/

extern char * HTNextElement (char ** pstr);

/*
(
  Next S-expression
)

Find the next s-expression token from a string of characters. We return the
name of this expression and the param points to
the parameters. Note, that the string has been mutilated by a 0 terminator!
*/

extern char * HTNextSExp (char ** exp, char ** param);

/*
.
  Reading CRLF
.

The Library provides a default set of read routines that can handle the most
common situations. However, before we start we make following definition
is to make life easier when having a state machine looking for a
<CRLF> sequence.
*/

typedef enum _HTEOLState {
    EOL_ERR = -1,
    EOL_BEGIN = 0,
    EOL_FCR,
    EOL_FLF,
    EOL_DOT,
    EOL_SCR,
    EOL_SLF,
    /* intermediate states */
    EOL_END,
    EOL_FOLD,
    EOL_LINE
} HTEOLState;

/*
.
  RFC1123 Date/Time Stamp String
.

Returns a string containing a date/time stamp string in RFC-1123 format.
The string is in static memory so be aware!
*/

extern const char * HTDateTimeStr (time_t *calendar, BOOL local);

/*
.
  Date used for directory listings
.

Generates a date/time stamp string used in directory listings. There is nothing
special about this format, it is just to make directory listings look alike.
*/

extern BOOL HTDateDirStr (time_t * time, char * str, int len);

/*
.
  Parse a Date/Time String
.

Converts a variety of different string representations of date time stamps
in GMT to a local representation of localtime time_t. The local
time zone is taken from the user profile
information or directly from the system if NULL is passed as
user profile . If the time is relative (for example in the Age
header) then you can indicate whether it should be expanded to local time
or not by using the expand argument.
*/

extern time_t HTParseTime (const char * str, HTUserProfile * up, BOOL expand);

/*
.
  Unique Message-ID String
.

The message ID string can for example be use as a RFC 822 header. The content
is based on the information taken from the user
profile which can be supplied by the application.
*/
extern const char * HTMessageIdStr (HTUserProfile * up);

/*
.
  Matching MIME Content-Types
.

Matches MIME constructions for content-types and others like them,
for example "text/html", "text/plain". It can also match wild cards like
"text/" and "/. We use  instead of * in order note
to make C like comments :-)
*/

extern BOOL HTMIMEMatch (HTAtom * tmplate, HTAtom * actual);

/*
.
  Converts an Integer to a String using Prefix
.

In computer-world 1K is 1024 bytes and 1M is 1024K -- however, sprintf()
still formats in base-10. Therefore I output only until 999, and then start
using the next unit. This doesn't work wrong, it's just a feature. The conversion
is done in "str" which must be large enough to contain the result.
*/

extern void HTNumToStr (unsigned long n, char *str, int len);

/*
.
  Conversion between URLs and Local File Names
.

These are two functions that separate the URL naming syntax from platform
dependent file naming schemes. If you are porting the code to a new platform,
you probably have to do some translation here.
(
  Convert file URLs into a local representation
)

The URL has already been translated through the rules in get_physical in
HTAccess.c and all we need to do now is to map the path to a local
representation, for example if must translate '/' to the ones that turn the
wrong way ;-) Returns local file (that must be freed by caller) if OK, else
NULL.
*/

extern char * HTWWWToLocal (const char * url, const char * base,
			    HTUserProfile * up);

/*
(
  Convert a local file name into a URL
)

Generates a WWW URL name from a local file name or NULL if error. Returns
URL (that must be freed by caller) if OK, else NULL. The access parameter
can be used to indicate any special scheme used for local file access. If
NULL then "file:" is used.
*/

extern char * HTLocalToWWW (const char * local, const char * access);

/*
*/

#endif

/*

  

  @(#) $Id: HTWWWStr.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTXML.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Expat XML Parser Wrapper


!
  Expat XML Parser Wrapper
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is implemented by HTXML.c, and is a part
of the  W3C Sample Code Library.

We use James Clark's expat
XML parser which is very neat indeed. As the code doesn't come as a separate
library, I included it in the libwww CVS code base where I compile is as
one library: libexpat.a. See
the external modules that libwww works with for
details. Thanks so much to John Punin for writing this code!
*/

#ifndef HTXML_H
#define HTXML_H

#include "HTFormat.h"
#include "HTStream.h"
#ifdef HT_STRUCT_XML_STREAM
#include "HTStruct.h"
#include "SGML.h"
#endif /* HT_STRUCT_XML_STREAM */

#include <expat.h>

/*
.
  Libwww Stream Converter
.

This stream is a libwww converter which
calls and creates a expat stream instance. In order to tell the application
that a new stream instance has been created.
*/

extern HTConverter HTXML_new;

/*
.
  Callback Handler Announcing a new Expat Stream object
.

When a libwww to expat XML stream converter instance
is created, the stream checks to see if there are any callbacks registered
which should be notified about the new stream instance. If that is the case
then this callback is called and a pointer to the XML parser passed along.
The output stream is the target that was originally set for the request object
before the request was issued.
*/

typedef void HTXMLCallback_new (
	HTStream *		me,
	HTRequest *		request,
	HTFormat 		target_format,
	HTStream *		target_stream,
	XML_Parser              xmlparser,
	void *                  context);

/*
(
  Register Creation notification Callback
)
@@@Should be handled via XML names spaces@@@
*/

extern BOOL HTXMLCallback_registerNew (HTXMLCallback_new *, void * context);

/*
.
  XML Expat Stream to Libwww Structured Stream
.

This is a stream that converts from the expat stream to a
libwww structured stream. Again, the application
can
*/

#ifdef HT_STRUCT_XML_STREAM
extern BOOL HTXMLStructured_setHandlers(
	HTStream *			me,
	XML_StartElementHandler		start,
	XML_EndElementHandler		end, 
	XML_CharacterDataHandler	char_data,
	XML_DefaultHandler		def_handler);

extern BOOL HTXMLStructured_setUserData (HTStream * me, void * user_data);
extern HTStream * HTXMLStructured_new (const SGML_dtd * dtd, HTStructured *
starget);
#endif

/*
*/

#endif

/*

  

  @(#) $Id: HTXML.html,v 1.1.1.1 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
HTXParse.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Callback Stream


!
  XParse: Module to get Unparsed Stream from libwww
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This version of the stream object is a hook for clients that want an unparsed
stream from libwww. The HTXParse_put_* and HTXParse_write routines copy the
content of the incoming buffer into a buffer that is realloced whenever
necessary. This buffer is handed over to the client in HTXParse_free. See
also HTFWriter for writing to C files.
(
  Bugs:
)
	 
	   o 
	     strings written must be less than buffer size.
	 
	 
This module is implemented by HTXParse.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTXPARSE_H
#define HTXPARSE_H

#include "HTStream.h"
#include "HTReader.h"
#include "HTReq.h"

typedef struct _HTXParseStruct HTXParseStruct;

typedef void CallClient (HTXParseStruct * me);

struct _HTXParseStruct {
	CallClient	*call_client;
	int             used;         /* how much of the buffer is being used*/
	BOOL            finished;     /* document loaded? */
        int             length;       /* how long the buffer is */
	char *          buffer;       /* storage in until client takes over */
	char *          content_type;
	HTRequest *	request;      /* the request structure */
};

extern HTConverter HTXParse;

#endif

/*

End of declaration
*/
::::::::::::::
HTZip.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww ZLib Compress and Decompress Stream


!
  ZLib Compress and Decompress Stream
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module provides an interface to the zlib compress and decompress functions. It can be hooked inas as content encoding coder/decoder in libwww which allows for on-the-fly encoding/decoding.

This module is implemented by HTZip.c, and it
is a part of the  W3C Sample Code
Library.
*/

#ifndef HTZIP_H
#define HTZIP_H

#include "HTFormat.h"

/*
*/

#ifdef HT_ZLIB
extern HTCoder HTZLib_inflate;
#endif

/*

End of definition module
*/

#endif /* HTZIP_H */

/*

  

  @(#) $Id: HTZip.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
SGML.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww SGML Parser


!
  SGML Parser
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The SGML parser is a state machine. It is called for every character of the
input stream. The DTD data structure contains pointers to functions which
are called to implement the actual effect of the text read. When these functions
are called, the attribute structures pointed to by the DTD are valid, and
the function is parsed a pointer to the curent tag structure, and an "element
stack" which represents the state of nesting within SGML elements. See also
the the generic Stream definition

The following aspects are from Dan Connolly's suggestions: Binary search,
Strcutured object scheme basically, SGML content enum type.

This module is implemented by SGML.c, and it is a part
of the W3C Sample Code Library.
*/

#ifndef SGML_H
#define SGML_H

#include "HTStream.h"
#include "HTStruct.h"

/*
.
  SGML Content Types
.
*/

typedef enum _SGMLContent{
    SGML_EMPTY,    	/* no content */
    SGML_LITERAL, 	/* character data. Recognized exact close tag only.
  		    	   Old www server compatibility only! Not SGML */
    SGML_CDATA,    	/* character data. recognize </ only */
    SGML_RCDATA,   	/* replaceable character data. recognize </ and &ref; */
    SGML_MIXED,    	/* elements and parsed character data. recognize all markup */
    SGML_ELEMENT   	/* any data found will be returned as an error*/
} SGMLContent;

/*
.
  Attribute Types
.

Describes the SGML tag attribute
*/

typedef struct _HTAttr {
    char *	name;		/* The (constant) name of the attribute */
    				/* Could put type info in here */
} HTAttr;

extern char * HTAttr_name (HTAttr * attr);

/*
.
  Tag Structure Describing SGML Elements
.

  
    name
  
    is the string which comes after the tag opener "<".
  
    attributes
  
    points to a zero-terminated array of attribute names.
  
    litteral
  
    determines how the SGML engine parses the charaters within the element. If
    set, tag openers are ignored except for that which opens a matching closing
    tag.

*/

typedef struct _HTTag {
    char *      name;			/* The name of the tag */
    HTAttr *	attributes;		/* The list of acceptable attributes */
    int		number_of_attributes;	/* Number of possible attributes */
    SGMLContent contents;		/* End only on end tag @@ */		
} HTTag;

extern char * HTTag_name (HTTag * tag);
extern SGMLContent HTTag_content (HTTag * tag);
extern int HTTag_attributes (HTTag * tag);
extern char * HTTag_attributeName (HTTag * tag, int attribute_number);

/*
.
  DTD Information
.

Not the whole DTD, but all this parser uses of it.
*/

#define MAX_ATTRIBUTES 32	     /* Max number of attributes per element */

typedef struct {
    HTTag *		tags;		/* Must be in strcmp order by name */ 
    int			number_of_tags;
    const char **	entity_names;	/* Must be in strcmp order by name */
    int			number_of_entities;
} SGML_dtd;

extern HTTag * SGML_findTag (SGML_dtd * dtd, int element_number);
extern char * SGML_findTagName (SGML_dtd * dtd, int element_number);
extern SGMLContent SGML_findTagContents (SGML_dtd * dtd, int element_number);
extern int SGML_findElementNumber(SGML_dtd *dtd, char *name_element);

/*
.
  Create an SGML Parser Instance
.

Create an SGML parser instance which converts a stream to a structured stream.
*/

extern HTStream * SGML_new (const SGML_dtd * 	dtd,
			    HTStructured *	target);

/*
*/

#endif	/* SGML_H */

/*

  

  @(#) $Id: SGML.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWApp.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Application Interface


!
  Application Interface
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

In addition top the basic W3C Sample Code Library WWWLib
interface you may include the other
interfaces&nbsp;depending on the needs of your
application. However, it is not required and none of the files included below
are ever used in the core part of the Library itself. Only if this file is
included, the extra modules will get included in the linked object code.
It is also possible to include only a subset of the files below if the
functionality you are after is covered by them. This interface contains many
application specific features including a set of default
BEFORE and AFTER filters.
*/

#ifndef WWWAPP_H
#define WWWAPP_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/
#include "wwwsys.h"

/*
(
  Event Manager
)

The core part of libwww only provides the hooks for the event manager. There
is no event loop internal to the core part. Instead the application must
provide the event loop in order to use either pseudo threads or real threads.
If the application only uses blocking sockets without threads then it is
not required to register any event loop at all. We provide a default
implementation of an event loop which you can either take or get some ideas
from.
*/
#include "HTEvtLst.h"

/*
(
  Managing the Home Page
)

This module provides some "make life easier" functions in order to get the
application going. They help you generate the first anchor, also called the
home anchor. It also contains a nice set of default WWW addresses.
*/
#include "HTHome.h"

/*
(
  User Dialogs and Messages
)

You can register a set of callback functions to handle user prompting, error
messages, confimations etc. Here we give a set of functions that can be used
on almost anu thinkable platform. If you want to provide your own platform
dependent implementation then fine :-)
*/
#include "HTDialog.h"

/*
(
  Load, Upload, and Search URLs
)

Even though you may use the API for the HTRequest object directly in order
to issue a request, you will probably find that in real life it is easier
to use a higher level abstraction API. This API is provided by the
HTAccess module where you will find all kind
of functions for down loading a URL etc.
*/
#include "HTAccess.h"

/*
(
  Rule File Management
)

Another way to initialize applications is to use a rule file, also known
as a configuration file. This is for
example the case with the W3C httpd and the W3C Line Mode Browser. This module
provides basic support for configuration file management and the application
can use this is desired. The module is not referred to by the Library. Reading
a rule file is implemented as a stream converter so that a rule file can
come from anywhere, even across the network!
*/
#include "HTRules.h"

/*
(
  Proxies and Gateways
)

Applications do not have to provide native support for all protocols, they
can in many situations rely on the support of proxies and gateways to help
doing the job. Proxy servers are often used to carry client requests through
a firewall where they can provide services like corporate caching and other
network optimizations. Both Proxy servers and gateways can serve as "protocol
translators" which can convert a request in the main Web protocol, HTTP,
to an equivalent request in another protocol, for example NNTP, FTP, or Gopher.
In case a proxy server or a gateway is available to the application, it can
therefore by use of HTTP forward all requests to for example a proxy server
which then handle the communications with the remote server, for example
using FTP about the document and return it to the application (proxy client)
using HTTP.
*/
#include "HTProxy.h"

/*
(
  BEFORE and AFTER Filters
)

Before a request has been issued and after it has terminated
the application often has to do some action as a result of the request (and
of the result of the request). The Client Profile Interface Library provides
a set of standard BEFORE and AFTER filters to handle caching,
redirection, authentication, logging etc.
*/
#include "HTFilter.h"

/*
(
  Logging
)

Often it is required to log the requests issued to the Library. This can
either be the case if the application is a server or it can also be useful
in a client application. This module provides a simple logging mechanism
which can be enabled if needed. See also the SQL
based logging module.
*/
#include "HTLog.h"

/*
(
  History Management
)

Another type of logging is keeping track of which documents a user has visited
when browsing along on the Web. The Library history manager provides a basic
set of functionality to keep track of a linear history list.
*/
#include "HTHist.h"

/*

End of application specific modules
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWApp.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWCache.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Persistent Cache Manager


!
  Declaration of W3C Sample Code Persistent Cache Manager
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Caching is a required part of any efficient Internet access applications
as it saves bandwidth and improves access performance significantly in almost
all types of accesses. The Library supports two different types of cache:
The memory cache and the file cache. The two types differ in several ways
which reflects their two main purposes: The memory cache is for short term
storage of graphic objects whereas the file cache is for intermediate term
storage of data objects. Often it is desirable to have both a memory and
a file version of a cached document, so the two types do not exclude each
other.

The cache contains details of persietent files which contain the contents
of remote documents. The existing cache manager is somewhat naive - especially
in its garbage collection but it is just an example of how it can be done.
More advanced implementations are welcome!
*/

#ifndef WWWCACHE_H
#define WWWCACHE_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
(
  Caching Manager
)

The cache interface defines a persistent cache manager based on accessing
files.
*/
#include "HTCache.h"

/*
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWCache.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWCore.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Core Interface


!
  Declaration of W3C Sample Code Library Core Interface
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the basic include file for the core of the W3C Sample Code Library.
The core part of the Library is designed as a set of registration modules
with no real functionality in itself. Instead all the functionality comes
when the application registeres the modules that provides a desired functionaly,
for example accessing HTTP servers or the local file system. The Library
has a special include file called WWWApp.h which
contains all converters, protocol modules, and a lot of other "sugar" modules
that can make the core a very powerful Web interface. You can include this
one if the application is to use all the functionality of the Library.
*/

#ifndef WWWCORE_H
#define WWWCORE_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/
#include "wwwsys.h"

/*
(
  Generic Libwww Information
)

This module contains some generic functions for getting the name and version
of libwww. It also contains some global configuration options like if you
can access the local file system, for example.
*/
#include "HTLib.h"

/*
(
  The Request Class
)

Libwww is based on a request/response paradigm and the Request class defines
"an operation to be performed on a URL". The request object is the
main entry point for an application to issue a request to the Library - all
operations on a URL must use a Request object.
*/

#include "HTReq.h"

/*
(
  Request Methods
)

This module defines the set of methods that you can perform on a request,
for example GET, HEAD, PUT, POST, DELETE,
etc.
*/

#include "HTMethod.h"

/*
(
  The Anchor (URL) Class
)

An anchor represents a region of a hypertext
document which is linked to another anchor in the same or a different document.
Another name for anchors would be URLs as an anchor represents all we know
about a URL - including where it points to and who points to it.
*/
#include "HTAnchor.h"

/*
(
  The Link Class
)

A Link represents the link between anchor objects.
By keeping the link as a object and not as part of the anchor we are capable
of handling link semantics in a much more organized way. For example, we
can then search for link types among all the link objects that we have created.
*/
#include "HTLink.h"

/*
(
  Parsing URLs
)

This module contains code to parse URIs for the various components according
to the URI syntax
*/

#include "HTParse.h"

/*
(
  Escaping and Unescaping URLs
)

URLs are written only with the graphic printable characters of the US-ASCII
coded character set. All other characters must be escaped before they can
be used in URLs. This module defines the methods required for escaping and
unescaping the URLs.
*/

#include "HTEscape.h"

/*
(
  URL Trees and Hierarchies
)

A URL tree is a data class that can store all
the information we know about a URL hierarchy. Typically, a URL hierarchy
is what a client sees of a Web server but it can also be the view a server
has of itself. A URL tree has the advantage that it can be searched using
URLs or using realms. The letter is most useful to "guess" information
about a remote URL that we haven't seen before.
*/

#include "HTUTree.h"

/*
(
  Web Related String Functions
)

This module is like the generic string utility
module but it contains more Web related string utility functions. Examples
are functions that return a date string, a Message ID string
etc.
*/

#include "HTWWWStr.h"

/*
(
  The User Profile Class
)

The User profile&nbsp;class manages what we know about a user on this
host. This can for example be the FQDN of the host, the user's email
address, the time zone, the news server etc.
*/

#include "HTUser.h"

/*
(
  The Event Class
)

The Event Class defines any event manager to be used by libwww for handling
events.
*/

#include "HTEvent.h"

/*
(
  The Network Trace Handler
)

The Network Trace Handler provides an easy mechanism
for tracing memory problems. It gives a complete dump of all read and written
information to and from the network
*/

#include "HTMemLog.h"

/*
(
  The Error Class
)

The Error class provides an easy API for registering
errors ocurring while the Library serves a request. All errors are registered
in an "error stack"&nbsp;in the Request object which
allows for nested errors.
*/

#include "HTError.h"

/*
(
  The Alert Class
)

The Alert class defines a set of methods to be
used by libwww to be used for passing prompts and message to a user.
*/

#include "HTAlert.h"

/*
(
  The Format Manager
)

The Format Manager is responsible for setting up the stream pipe from the
Channel Object to the Request
Object when data is arriving, for example as a response to s
HTTP Get request. The Format Manager is also
responsible for keeping track of the "preferences" of the application
and/or user. It is an integral part of the Web and HTTP, that the client
application can express its preferences as a set of "accept" headers in a
HTTP request.
*/

#include "HTFormat.h"

/*
(
  The Generic Stream Class
)

The Stream class defines objects which accepts
a sequence of characters. Streams may also have an output in which case multiple
stream objects can be cascaded to build a stream pipe where the output of
a stream is directed into the input of the next stream object "down the line".
*/

#include "HTStream.h"

/*
(
  The Structured Stream Class
)

The Structured stream class defines objects which
accepts a structured sequence of characters for eaxmple a SGML document.
I'll rephrase that. A structured object is am ordered tree-structured arrangement
of data which is representable as text. An example is the
SGML parser which outputs to a Structured Object.
*/

#include "HTStruct.h"

/*
(
  No Free Stream
)

This stream is a throughline for all methods except FREE and
ABORT. This means that it can be use to put ahead of streams that you
don't want to be freed or aborted until you are redy to do it
yourself.
*/

#include "HTNoFree.h"

/*
(
  The Input/output Stream Classes
)

The I/O Stream class defines objects which
accepts a sequence of characters to and from a
transport
*/

#include "HTIOStream.h"

/*
(
  The DNS Class
)

The DNS Class defines generic access to &nbsp;the DNS system. It maintains
a cache of all visited hosts so that subsequent connects to the same host
doesn't imply a new request to the DNS every time.
*/

#include "HTDNS.h"

/*
(
  The Host Class
)

The Host class manages what we know about a remote
host. This can for example be what type of host it is, and what version it
is using.
*/

#include "HTHost.h"

/*
(
  The Net Class
)

The Net class manages information related to a "thread"
in libwww. As libwww threads are not really threads but a notion of using
interleaved, non-blocking I/O for accessing data objects from the network
(or local file system), they can be used on any platform with or without
support for native threads.
*/

#include "HTNet.h"

/*
(
  Internet Functions
)

This module has the common code for handling typical Internet functions like
getting the name of the local host, getting the domain name and email address
of user etc.
*/

#include "HTInet.h"

/*
(
  The Transport Class
)

The Transport Class defines a transport as used by the
HTChannel class to communicate with the network,
the local file system etc. New transport objects may be registered at any
time. This allows the application to easily hook in its own transport layers.
*/

#include "HTTrans.h"

/*
(
  The Protocol Class
)

The Protocol class defines an application level protocol (HTTP, FTP, Gopher,
etc.) to be used by libwww. Please note that access to the local file system
also is considered to be an appliaction level protocol treated identically
to for example the HTTP protocol.
*/

#include "HTProt.h"

/*

End of Core modules
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWCore.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWDir.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Directory Listings


!
  Declaration of W3C Sample Code Directory Listings
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the include file for the directory handling modules for parsing and
presenting directory listings - often in the form of a HTML document.
*/

#ifndef WWWDIR_H
#define WWWDIR_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
(
  Directory listings
)

The directory manager generates directory listings for FTP and HTTP requests.
This module contains the protocol independent code and it produces the HTML
object. It is only included if either the FTP or
the File module is included.
*/

#include "HTDir.h"

/*
(
  Icons
)

No directory listings without icons! The WWWDir interface contains support
for including references (URLs and ALT text tags) to icons in directory listings.
The icons are selected as a function of the media type and the content encoding
of the file in question. That is - you can set up icons for compressed files,
postscript files etc. There is also a small set of specific icons representing
directories etc.

Note: Icons are not set up by default! You must enable them yourself.
The Library distribution contains a small
set of default icons which you can find at
$(datadir)/www-icons, and they can be set up using the
HTIconInit() initialization function in the
WWWInit startup interface
*/
#include "HTIcons.h"

/*
(
  File Descriptions
)

Descriptions appearing in directory listings are
produced by this module. This may be overridden by another module for those
who which descriptions to come from somewhere else. It's only HTTP directory
listings that contain a description field (if enabled by the
Directory browsing module.
*/

#include "HTDescpt.h"

/*

End of DIR module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWDir.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWFile.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Local File Access


!
  Declaration of W3C Sample Code Local File Access
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the module for accessing local files and directories. The module
contans
*/

#ifndef WWWFILE_H
#define WWWFILE_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
(
  Access the Local File System
)

The WWWFile interface provides a platform independent access scheme for local
files. The local file access works exactly like any other access scheme,
for example HTTP, in that the "file protocol" is independent of the underlying
transport. This can be used to for example slide in a CVS transport layser
underneath the file module without making any modifications to the file module
itself. You can read more about the transport managament in the
Transport Interface.
*/
#include "HTFile.h"

/*
(
  Content Negotiation
)

When accessing the local file system, you can enable content negotiation
as described in the HTTP
specification. &nbsp;The content negotiation algorithm is based on file
suffixes as defined by the Bind manager. When looking
for a file you do not have to specify a suffix. Instead this module
looks for all alternatives with the same main name. For example, looking
for the file Overview can result in any of the files (or directories)
Overview.txt, Overview.html, Overview.ps etc. The selection
algorithm is based on the values of the preferences for language, media type,
encoding, etc. - exactly like a server would do with the accept
headers.
*/

#include "HTMulti.h"

/*
(
  File Suffix Binding
)

This module sets up the binding between a file suffix and a media type, language,
encoding etc. In a client application the suffixes are used in protocols
that does not directly support media types etc., like FTP, and in server
applications they are used to make the bindings between the server and the
local file store that the server can serve to the rest of the world (well
almost)
*/

#include "HTBind.h"

/*
.
  Default File Suffix Bindings
.

Register the default set of bindings between file suffixes and media types.
This is used for example to guess the media type of a FTP URL of a local
file URL.
*/

#include "HTBInit.h"

/*

End of FILE module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWFile.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWFTP.h
::::::::::::::
/*

  					W3C Sample Code Library libwww FTP CLIENT


!
  Declaration of W3C Sample Code FTP MODULE
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the include file for the basic FTP module that can be used together
with the core of the W3C Sample Code Library.
It contains all FTP specific modules which are required to compile and build
the FTP DLL.
*/

#ifndef WWWFTP_H
#define WWWFTP_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  System dependencies
.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
.
  Library Includes
.
(
  The main FTP state machine
)
*/

#include "HTFTP.h"			/* FTP client state machine */

/*
(
  The FTP Directory listing Management
)
*/

#include "HTFTPDir.h"			/* Streams for parsing FTP output */

/*

End of FTP module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWFTP.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWGophe.h
::::::::::::::
/*

					W3C Sample Code Library libwww GOPHER CLIENT





!Declaration of W3C Sample Code GOPHER MODULE!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the include file for the basic GOPHER module that can be used
together with the core of the W3C Sample Code Library. It contains all
GOPHER specific modules which are required to compile and build the
GOPHER DLL.

*/

#ifndef WWWGOPHER_H
#define WWWGOPHER_H

/*

*/

#ifdef __cplusplus
extern "C" { 
#endif

/*

.System dependencies.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this
file is that the Internet world is more complicated than Posix and
ANSI.

*/

#include "wwwsys.h"

/*

.Library Includes.


*/

#include "HTGopher.h"			      /* GOPHER client state machine */

/*

End of GOPHER module

*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*



@(#) $Id: WWWGophe.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
WWWHTML.h
::::::::::::::
/*

  					W3C Sample Code Library libwww HTML PARSER


!
  Declaration of W3C Sample Code HTML MODULE
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the include file for the basic HTML module that can be used together
with libwww. It contains all HTML specific modules which are required to
compile and use the default libwww HTML parser
*/

#ifndef WWWHTML_H
#define WWWHTML_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  System dependencies
.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
.
  Library Includes
.
*/

#include "HTMLPDTD.h"
#include "SGML.h"
#include "HTMLGen.h"
#include "HTTeXGen.h"
#include "HTPlain.h"
#include "HTML.h"
#include "HText.h"
#include "HTHInit.h"
#include "HTStyle.h"

/*

End of HTML module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWHTML.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWHTTP.h
::::::::::::::
/*

  					W3C Sample Code Library libwww HTTP Client/Server Module


!
  Declaration of W3C Sample Code HTTP Module
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the include file for all HTTP access including the
server side and the client
side. It can be used together with the core of
the W3C Sample Code Library. It contains all HTTP specific modules which
are required to compile and build the HTTP DLL.
*/

#ifndef WWWHTTP_H
#define WWWHTTP_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/
#include "wwwsys.h"

/*
(
  Basic HTTP definitions and utilities
)

A small set of very basic HTTP stuff
*/

#include "HTTPUtil.h"

/*
(
  HTTP Client State Machine
)

The client statue machine handles the client side of HTTP generating requests
and parsing responses.
*/
#include "HTTP.h"

/*
(
  HTTP Server State Machine
)

The HTTP module also contains a very simple server module which can be used
for experimenting but which is not a full blown server.
*/
#include "HTTPServ.h"			/* HTTP server state machine */

/*
(
  General HTTP Header Stream
)

The HTTP Request stream generates a HTTP request header and writes it to
the target which is normally a HTWriter stream.
*/
#include "HTTPGen.h"

/*
(
  Client-side Request Generator Stream
)

The HTTP Request stream generates a HTTP request header and writes it to
the target which is normally a HTWriter stream.
*/
#include "HTTPReq.h"

/*
(
  Server-side Response Generator Stream
)

The HTTP response stream generates a HTTP response header and writes it to
the target which is normally a HTWriter stream.
*/
#include "HTTPRes.h"

/*
(
  Chunked Encoding and Decoding
)

Chunked transfer encoding and decoding is new in HTTP/1.1. It allows applications
to use persistent connections while not knowing the content length a priori
to the response header is generated.
*/
#include "HTTChunk.h"

/*
(
  HTTP Extensions
)

The PEP Manager is a registry for PEP Protocols
that follow the generic syntax defined by the
HTTP PEP protocol headers. All PEP
Protocols are registered at run-time in form of a PEP Module.
A PEP Module consists of the following:
*/
#include "HTPEP.h"

/*
(
  Generic Authentication
)

The Authentication Manager is a registry
for Authentication Schemes that follow the generic syntax defined
by the HTTP WWW-authenticate
and Authorization headers. Currently, the only scheme defined
is Basic Authentication, but Digest Authentication will soon
follow. All Authentication Schemes are registered at run-time in form
of an Authentication Module. An Authentication Module consists
of the following:
*/
#include "HTAAUtil.h"

/*
(
  Client Side Authentication
)

Contains code for parsing challenges and creating credentials for basic and
digest authentication schemes. See also the HTAAUtil
module for how to handle other authentication schemes.
*/
#include "HTAABrow.h"

/*
(
  HTTP Cookies
)

The cookie module provides a simple
HTTP Cookie
handling mechanism. It really also is an excersize in showing how libwww
can be extended with something like cookies in a modular manner. An important
thing to note about this implementation is that it does not provide
storage for cookies - this is left to the application as normally cookies
have to be kept under lock.
*/

#include "HTCookie.h"

/*

End of HTTP module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWHTTP.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWInit.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Default Initialization


!
  Default Initialization Modules and Profiles
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

As mentioned in the Library Architecture,
libwww consists of a small core and a large set of hooks for adding
functionality. By itself, the core it not capable of performing any Web related
tasks like accessing a HTTP server or parsing a HTML document. All this
functionality must be registered by the application. This way, the core of
libwww is kept application independent and can be used as the basic building
block for any kind of Web application. The Library comes with a large set
of default functions, for example for accessing HTTP and FTP servers, parsing
MIME headers etc. This module helps the application programmer setting up
all this functionality, but it is important to note that none of it is
required in order to use libwww.
*/

#ifndef WWWINIT_H
#define WWWINIT_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  Default Protocols, Transports, MIME Headers, Dialogs etc.
.

This module contains a large set of default initialization functions for
protocol modules, stream converters, event managers etc.
*/

#include "HTInit.h"

/*
.
  Application Profiles
.

Application profiles are initialization functions that are "preset" to initialize
the Library with the set of features often used in clients,
servers, robots, and proxy servers. They are basically
collections of the more detailed initialization functions that you can find
later in this interface description. In many cases you do not need to use
anything else than the profiles, but if you have more specific requirements
then you can always fall back on using the initialization functions below
or even werite your own extensions.
*/

#include "HTProfil.h"

/*
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWInit.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWLib.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library libwww Basic libwww Interface


!
  Basic Libwww Interface
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the basic include files and the core include files necessary in order
to use the W3C Sample Code Library. It contains all core specific modules which
are required to compile and build the Library. No converter streams or protocol
modules are included in this file as they are for the application to set
up. The Library has a special include file called
WWWApp.h which contains all converters and protocol
modules known to the Library. You can include this one if the application
is to use all the functionality of the Library.
*/

#ifndef WWWLIB_H
#define WWWLIB_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
.
  General Utilities
.

The Basic Utility interface is mostly container
modules, dynamic strings and other stuff that you can't live without when
building applications. The modules are used by the core part of the W3C Sample Code
Library but can also be used by the application. 
*/
#include "WWWUtil.h"

/*
.
  Core Modules
.

This is the basic include file for the core of the W3C Sample Code Library.
The core part of the Library is designed as a set of registration modules
with no real functionality in itself. Instead all the functionality comes
when the application registeres the modules that provides a desired functionaly,
for example accessing HTTP servers or the local file system. 
*/
#include "WWWCore.h"

/*
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWLib.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWMIME.h
::::::::::::::
/*

  					W3C Sample Code Library libwww MIME and RFC822


!
  Declaration of W3C Sample Code MIME and RFC822
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the module for basic RFC822/MIME parsing that can be used together
with the core of the W3C Sample Code Library. It contains all MIME specific
modules which are required to compile and build the MIME DLL.
*/

#ifndef WWWMIME_H
#define WWWMIME_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
(
  MIME Entity Header Parsing
)

The libwww MIME parsers are completely generic in that they don't know about
any particular headers - they are all registered at run-time by the application.
There are two parsers: the first is for parsing MIME headers and the
second is for parsing MIME footers. They are both converters that
can be set up using the HTConverterInit
function in the libwww setup module

There is also a default set of the headers defined by the
HTTP/1.1 specification
which can be initialized using the
HTMIMEInit() function in the
libwww setup module.
*/
#include "HTMIME.h"			/* Generic MIME parser */
#include "HTHeader.h"			/* Header parser registration */

/*
(
  MIME Entity Header Generation
)

When sending a MIME entity along with a request, for example using NNTP or
HTTP, the entity headers are generated by the MIME generator stream. This
stream will be added to the output stream pipe in order to decorate the outgoing
request.
*/
#include "HTMIMERq.h"			/* MIME request generator */

/*
(
  Default MIME Header Parsers
)

The Library's MIME parser is divided into two parts: A generic MIME parser
that knows how to unwrap all RFC822 headers and specialized header parsers
that knows how to parse Content-Length, for example. This is
the default set of the specialized MIME header parsers that can be registered
as part of the generic MIME. Note that these functions are not registered
by default - they must be registered by the application. This can be done
using the HTMIMEInit() function in the
WWWInit interface. Of course this can also be
used to register new headers that are not represented below - or if you want
to replace a default parser then this is also very easy.
*/
#include "HTMIMImp.h"

/*
(
  Multipart MIME Parsing and Generation
)

Libwww supports MIME multipart generation and parsing using two streams.
The parser stream is a converter that can be setup for"converting" the MIME
body parts into separate documents. The MIME multipart stream parser can
be set up by using the HTConverterInit
function in the libwww setup module.
*/

#include "HTBound.h"			/* Multipart MIME parser */
#include "HTMulpar.h"			/* Multipart MIME generator stream */

/*

End of MIME modules
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWMIME.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWMux.h
::::::::::::::
/*

  					W3C Sample Code Library libwww MUX Transport


!
  Declaration of W3C Sample Code Library MUX Transport
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*
*/

#ifndef WWWMUX_H
#define WWWMUX_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  System dependencies
.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*

*/

#include "HTMuxCh.h"
#include "HTMuxTx.h"
#include "HTDemux.h"

/*

*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWMux.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWNews.h
::::::::::::::
/*

  					W3C Sample Code Library libwww News/NNTP Client


!
  Declaration of W3C Sample Code News/NNTP Client
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This application interface defines a News client which &nbsp;can be used
together with the Library core.The module itself
is not part of the Library core. It may
be registered by the application if wanted. The application may also use
the application profiles to initialize this module.
*/

#ifndef WWWNEWS_H
#define WWWNEWS_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
(
  NNTP Protocol State machine
)

The state machine handles requests and responses to an NNTP server according
to the NNTP specifications.
*/
#include "HTNews.h"

/*
(
  News Request Stream
)

The request stream generates a request which may or may not include a message
body to be posted to the server
*/
#include "HTNewsRq.h"

/*
(
  News Response Stream for Messages and group Listings
)

The News response streams parses the output from an NNTP server. The two
formats understood are News groups and News articles.
*/
#include "HTNewsLs.h"

/*
(
  Presentation of News Listings in HTML
)

When the output has been received then we convert it to HTML by parsing it
through the following stream.
*/
#include "HTNDir.h"

/*

End of News module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWNews.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWSQL.h
::::::::::::::
/*

  					W3C Sample Code Library libwww SQL Interface


!
  W3C Sample Code Library libwww SQL Interface
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This module is an easy to use interface to SQL databases. It contains both
a generic interface and some specific examples of how this can be used to
connect a Web client to an SQL server. This requires that you have linked
against the MySQL library. See the
installation instructions for details.
*/

#ifndef WWWSQL_H
#define WWWSQL_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/
#include "wwwsys.h"

/*
(
  Basic SQL Interface
)

This module interacts with the MYSQL C client library to perform SQL operations.
It is not intended as a complete SQL API but handles most of the typical
error situations talking to an SQL server so that the caller doesn't have
to think about it.
*/

#ifdef HT_MYSQL
#include "HTSQL.h"
#endif

/*
(
  SQL Client Side Logging
)

This SQL based log class generates a SQL database and a set of tables storing
the results of a request. The result is stored in different tables depending
on whether it is information about the request or the resource returned.
*/

#ifdef HT_MYSQL
#include "HTSQLLog.h"
#endif

/*
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif
#endif /* WWWSQL_H */

/*

  

  @(#) $Id: WWWSQL.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWStream.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww Streams


!
  Declaration of W3C Sample Code Library Streams
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The stream part of the Library is a set of streams that can be used in many
contexts throughout the Library. It also contains conversions between streams
and other memory containers, for example Chunks.
*/

#ifndef WWWSTREAM_H
#define WWWSTREAM_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/
#include "wwwsys.h"

/*
(
  Content Length Counter
)

This stream also buffers the result to find out the content length. If a
maximum buffer limit is reached Content-Length is calculated for logs but
it is not sent to the client -- rather the buffer is flushed right away.
*/

#include "HTConLen.h"			/* Content Length Counter */

/*
(
  File Writer Streams
)

This module contains a set of basic file writer streams that are used to
dump data objects to disk at various places within the Library core. Most
notably, we use these streams in the Format Manager
in order to handle external presenters, for example post script viewers etc.
These streams can of course also be used in other contexts by the application.
*/

#include "HTFWrite.h"
#include "HTFSave.h"

/*
(
  Content Guess Stream
)

This interface provides functionality for guessing unknown media types from
magic words. The stream is a one that reads first a chunk of stuff, tries
to figure out the format, and calls HTStreamStack(). This is
a kind of lazy-evaluation of HTStreamStack(). This could be
extended arbitrarily to recognize all the possible file formats in the world,
if someone only had time to do it.
*/

#include "HTGuess.h"			/* Guess stream */

/*
(
  Tee Stream
)

The Tee stream just writes everything you put into it into two oter streams.
One use (the only use?!) is for taking a cached copey on disk while loading
the main copy, without having to wait for the disk copy to be finished and
reread it.
*/

#include "HTTee.h"

/*
(
  Merge Stream
)

The Merge stream can be used to merge multiple streams into a single target
stream. The Merge stream does not prevent any of the streams from writing
and no ordering is imposed. The main feature is basically that the free and
abort methods can be called n times where n equals the number
of feeds that put data to the stream.
*/

#include "HTMerge.h"

/*
(
  Stream to Chunk Conversion
)

If you do not like the stream model in libwww, then you can use this stream
to convert a stream object into a
Chunk object which is a dynamic character string
buffer in memory.
*/

#include "HTSChunk.h"

/*
(
  Stream to Memory Object Conversion
)

This version of the stream object is a hook for clients that want an unparsed
stream from libwww. The HTXParse_put_* and HTXParse_write routines copy the
content of the incoming buffer into a buffer that is realloced whenever
necessary. This buffer is handed over to the client in
HTXParse_free.
*/

#include "HTXParse.h"			/* External parse stream */
#include "HTEPtoCl.h"			/* Client callbacks */

/*
(
  Network Telnet To Internal Character Text
)

This is a filter stream suitable for taking text from a socket and passing
it into a stream which expects text in the local C representation.
*/

#include "HTNetTxt.h"

/*
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWStream.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
wwwsys.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww System Dependencies


!
  System Dependencies
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This file makes up for the differencies in the systems and platforms supported
by libwww. On Unix, it is a question of using
autoconf to figure out what environment we are in. This is done by running
the configure script which creates a wwwconf.h file. This
configuration include file contains a large set of macro definitions telling
what features we have and don't have. On platforms not supported by autoconf
(Windows, Mac, VMS etc.) you will find the information normally contained
in the wwwconf.h file directly included below. The
second part of this file uses all the information
that we either have from the wwwconf.h file or directly coded and actually
does the includes etc.

	 
	   o 
	     Unix
  o 
	     Microsoft Windows Win32 API
  o 
	     Macintosh
  o 
	     Vax VMS

	 
This module is a part of the  W3C Sample
Code Library.
(
  Authors
)

  
    TBL
  
    Tim Berners-Lee, W3 project, CERN, <timbl@w3.org>
  
    EvA
  
    Eelco van Asperen <evas@cs.few.eur.nl>
  
    MA
  
    Marc Andreesen NCSA
  
    MD
  
    Mark Donszelmann <duns@vxcern.cern.ch>
  
    AT
  
    Aleksandar Totic <atotic@ncsa.uiuc.edu>
  
    SCW
  
    Susan C. Weber <sweber@kyle.eitech.com>
  
    HF
  
    Henrik Frystyk, <frystyk@w3.org>
  
    CLB
  
    Charlie Brooks, <cbrooks@osf.org>

(
  History:
)

  
    22 Feb 91
  
    Written (TBL) as part of the WWW library.
  
    16 Jan 92
  
    PC code from (EvA)
  
    22 Apr 93
  
    Merged diffs bits from xmosaic release
  
    29 Apr 93
  
    Windows/NT code from (SCW)
  
    29 Sep 93
  
    Mar 96 CLB - changed SLEEP() macro for Windows/NT MSC compiler added
    BOOLEAN_DEFINED macro to avoid duplicate definitions in HUtils.h changed
    netread() macros to support reading from stdin,etc. as well as sockets. (Required
    for linemode browser to work).
  
    Henrik
  
    Changed to support autoconf for Unix

*/

#ifndef SYSDEP_H
#define SYSDEP_H

/*
!
  Platform Specific Stuff
!
.
  Unix
.

We rely on autoconf to do the dirty job. If you have any changhes
then please add them to the configure
script
*/

#ifdef HAVE_CONFIG_H
#include <wwwconf.h>
#endif

/*
.
  Microsoft Windows Win32 API
.

Help provided by Eric Prud'hommeaux, Susan C. Weber
<sweber@kyle.eitech.com>, Paul Hounslow
<P.M.Hounslow@reading.ac.uk>, and a lot of other PC people.
*/

#if defined(_WINDOWS) || defined(_CONSOLE)
#define WWW_MSWINDOWS
#endif

#if defined(_WINDOWS) && !defined (_CONSOLE)
#define WWW_WIN_WINDOW
#endif

#if defined(_CONSOLE)
#define WWW_WIN_CONSOLE
#endif

#ifdef WWW_MSWINDOWS

#include <windows.h>
#include <io.h>
#include <process.h>
#include <winsock.h>

#include "windows/config.h"

#define NETREAD(s,b,l)  recv((s),(b),(l),0)
#define NETWRITE(s,b,l) send((s),(b),(l),0)
#define NETCLOSE(s)     closesocket(s)
#define IOCTL(s,c,a)	ioctlsocket(s,c, (long *) a)

#define MKDIR(a,b)	mkdir((a))
#define REMOVE(a)	remove((a))
#define DEFAULT_SUFFIXES	"."

#ifndef _CONSOLE
#define NO_STDIO
#endif

#define SOCKET SOCKET			/* WinSocks socket descriptor */
#define INVSOC INVALID_SOCKET		/* WinSocks invalid socket */

#define DESIRED_WINSOCK_VERSION	0x0101  /* we'd like winsock ver 1.1... */
#define MINIMUM_WINSOCK_VERSION	0x0101  /* ...but we'll take ver 1.1 :) */

/*
(
  File and Directory Access
)

These next defintions are because the UNIX stuff is not supplied with BC4
(Paul Hounslow <P.M.Hounslow@reading.ac.uk>)
*/

#define NO_UNIX_IO

#define	_IFMT		0170000	/* type of file */
#define	_IFDIR		0040000	/* directory */
#define	_IFCHR		0020000	/* character special */
#define	_IFBLK		0060000	/* block special */
#define	_IFREG		0100000	/* regular */
#define	_IFLNK		0120000	/* symbolic link */
#define	_IFSOCK		0140000	/* socket */
#define	_IFIFO		0010000	/* fifo */

#define	S_ISUID		0004000	/* set user id on execution */
#define	S_ISGID		0002000	/* set group id on execution */
#define	S_ISVTX		0001000	/* save swapped text even after use */

#ifdef S_IREAD
#undef S_IREAD
#define	S_IREAD		0000400	/* read permission, owner */
#endif

#ifdef S_IWRITE
#undef S_IWRITE
#define	S_IWRITE 	0000200	/* write permission, owner */
#endif

#ifdef S_IEXEC
#undef S_IEXEC
#define	S_IEXEC		0000100	/* execute/search permission, owner */
#endif

#define	S_ENFMT 	0002000	/* enforcement-mode locking */

#ifdef S_IFMT
#undef S_IFMT
#define	S_IFMT		_IFMT
#endif

#ifdef S_IDIR
#undef S_IDIR
#define	S_IFDIR		_IFDIR
#endif

#ifdef S_IFCHR
#undef S_IFCHR
#define	S_IFCHR		_IFCHR
#endif

#ifdef S_IBLK
#undef S_IBLK
#define	S_IFBLK		_IFBLK
#endif

#ifdef S_IREG
#undef S_IREG
#define	S_IFREG		_IFREG
#endif

#define	S_IFLNK		_IFLNK

#ifdef S_IFIFO
#undef S_IFIFO
#define	S_IFIFO		_IFIFO
#endif

#define	S_IRWXU 	0000700	/* rwx, owner */
#define		S_IRUSR	0000400	/* read permission, owner */
#define		S_IWUSR	0000200	/* write permission, owner */
#define		S_IXUSR	0000100	/* execute/search permission, owner */
#define	S_IRWXG		0000070	/* rwx, group */
#define		S_IRGRP	0000040	/* read permission, group */
#define		S_IWGRP	0000020	/* write permission, grougroup */
#define		S_IXGRP	0000010	/* execute/search permission, group */
#define	S_IRWXO		0000007	/* rwx, other */
#define		S_IROTH	0000004	/* read permission, other */
#define		S_IWOTH	0000002	/* write permission, other */
#define		S_IXOTH	0000001	/* execute/search permission, other */

#define	S_ISREG(m)	(((m)&_IFMT) == _IFREG)

#define DIR_SEPARATOR
#define DIR_SEPARATOR_CHAR	'\\'
#define DIR_SEPARATOR_STR	"\\"

/*
(
  Errno and Return Codes
)

Winsock has its own errno codes and it returns them through WSAGetLastError().
However, it does also support BSD error codes, so we make a compromise. WSA
definitions moved from _WIN32 ifdef by EGP
*/

#define socerrno WSAGetLastError()
#define ERRNO_DONE

/*

Return code for socket functions. We can't use -1 as return value

*/

#define EWOULDBLOCK     WSAEWOULDBLOCK
#define EINPROGRESS     WSAEINPROGRESS
#define ECONNREFUSED    WSAECONNREFUSED
#define ETIMEDOUT       WSAETIMEDOUT
#define ENETUNREACH     WSAENETUNREACH
#define EHOSTUNREACH    WSAEHOSTUNREACH
#define EHOSTDOWN       WSAEHOSTDOWN
#define EISCONN         WSAEISCONN
#define EINVAL          WSAEINVAL
#define ECONNRESET      WSAECONNRESET
#define ECONNABORTED    WSAECONNABORTED
#define ESHUTDOWN       WSAESHUTDOWN

/* Some compilers do only define WIN32 and NOT _WINDOWS */
#define NO_GROUPS

#ifdef _WIN32
#define MKDIR(a,b)	mkdir((a))     /* CLB NT has mkdir, but only one arg */
#define SLEEP(n)        Sleep((n)*1000)
#else
#define MKDIR(a,b)	_mkdir((a))    /* CLB NT has mkdir, but only one arg */
#endif /* WIN32 */

#endif /* WWW_MSWINDOWS */

/*
.
  Macintosh
.
(
  mingw32 - Minimalist GNU for Windows
)

A bit like Cygwin, except it uses the native Windows API, which means
the programs do not need the huge Cygwin DLL to run.

Patch by Richard Atterer <richard@atterer.net>, October 2001
*/

#ifdef __MINGW32__

#include <winsock2.h>

#define WWW_MSWINDOWS
/* #define WWW_WIN_CONSOLE */
#define WWW_WIN_WINDOW
/* #define WWW_WIN_ASYNC */
/* #define WWW_WIN_DLL */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_
#endif

#define NETREAD(s,b,l)  recv((s),(b),(l),0)
#define NETWRITE(s,b,l) send((s),(b),(l),0)
#define NETCLOSE(s)     closesocket(s)
#define IOCTL(s,c,a)	ioctlsocket(s,c, (long *) a)

#define MKDIR(a,b)      mkdir(a)
#define REMOVE(a)	remove((a))
#define DEFAULT_SUFFIXES	"."

#define SOCKET SOCKET			/* WinSocks socket descriptor */
#define INVSOC INVALID_SOCKET		/* WinSocks invalid socket */

#define DESIRED_WINSOCK_VERSION 0x0101  /* we'd like winsock ver 1.1... */
#define MINIMUM_WINSOCK_VERSION 0x0101  /* ...but we'll take ver 1.1 :) */

#define DIR_SEPARATOR
#define DIR_SEPARATOR_CHAR     '\\'
#define DIR_SEPARATOR_STR      "\\"

#define socerrno WSAGetLastError()
#define ERRNO_DONE

/* Taken from the WIN32 stuff above. */
#define EWOULDBLOCK     WSAEWOULDBLOCK
#define EINPROGRESS     WSAEINPROGRESS
#define ECONNREFUSED    WSAECONNREFUSED
#define ETIMEDOUT       WSAETIMEDOUT
#define ENETUNREACH     WSAENETUNREACH
#define EHOSTUNREACH    WSAEHOSTUNREACH
#define EHOSTDOWN       WSAEHOSTDOWN
#define EISCONN         WSAEISCONN
/*#define EINVAL          WSAEINVAL*/
#define ECONNRESET      WSAECONNRESET
#define ECONNABORTED    WSAECONNABORTED
#define ESHUTDOWN       WSAESHUTDOWN

/* The configure.in script is wrong to default to #define GETGROUPS_T int */
#ifdef GETGROUPS_T
#undef GETGROUPS_T
#endif

#define HT_LSTAT stat

#endif /* __MINGW32__ */

/*
.
  Macintosh
.

We have two environments on Macintosh: Codeworrior and MPV.
(
  Metrowerks Codewarrior 6
)

Metrowerks Codewarrior is one development environment on the Mac. We are
using GUSI (1.5.9) by Matthias Neeracher <neeri@iis.ee.ethz.ch> for
our socket lib. You can find more information about the
GUSI Library from
Switzerland.

Compiles on PPC. Should compile on 68K.

August 31, 1995 by Steven T. Roussey <sroussey@eng.uci.edu> (STR).
and jeff@macalot.com (Jeff Dripps). Thanks a bunch!
*/

#ifdef __MWERKS__
#include <gusi.h>
#include <dirent.h>
#include <errno.h>
#include <sys/errno.h>
#include <sioux.h>

#define INCLUDES_DONE
#define TCP_INCLUDES_DONE

#define GUSI                    /* Identifies changes made for GUSI */

#undef  HAVE_GETDOMAINNAME      /* STR */
#undef  HAVE_GETPASS
#undef  HAVE_GETWD

#define HAVE_GETCWD
#define USE_DIRENT
#define NO_GROUPS
#define GOT_READ_DIR

#undef  HAVE_TIMEZONE           /* STR */
#define NO_GMTOFF
#define HAVE_STRERROR
#define HAVE_GETHOSTNAME

#define d_ino           d_fileno        /* backward compatibility */

#define SLEEP(n)        GUSIDefaultSpin( SP_SLEEP, n/60)

#define MKDIR(a,b)      mkdir(a)

#define HAVE_STRFTIME           // added JTD:5/1/96
#define HAVE_MKTIME             // added JTD:5/1/96
#define HAVE_STRCHR             // added JTD:5/1/96
#define STDC_HEADERS            // added JTD:5/1/96
#define HAVE_MEMCPY             // added JTD:5/1/96
#define TTY_IS_SELECTABLE       // added JTD:5/1/96
#define HAVE_READDIR            // added JTD:5/1/96
#define HAVE_DIRENT_INO         // added JTD:5/1/96
#define HAVE_DIRENT_H           // added JTD:5/1/96

#endif

/*
(
  MPW
)

MPW is one development environment on the Mac.

This entry was created by Aleksandar Totic (atotic@ncsa.uiuc.edu) this file
is compatible with sockets package released by NCSA. One major conflict is
that this library redefines write/read/etc as macros. In some of HTML code
these macros get executed when they should not be. Such files should define
NO_SOCKET_DEFS on top. This is a temporary hack.
*/

#ifdef applec			/* MPW  */
#undef HAVE_SYSTEM
#define DEBUG			/* Can't put it on the CC command line */

#define NO_UNIX_IO		/* getuid() missing */
#undef  HAVE_GETPID		/* getpid() does not exist */
#define NO_GETWD		/* getwd() does not exist */

#define NETCLOSE s_close    /* Routine to close a TCP-IP socket */
#define NETREAD  s_read	    /* Routine to read from a TCP-IP socket */
#define NETWRITE s_write    /* Routine to write to a TCP-IP socket */

#define _ANSI_SOURCE
#define GUI
#define LINEFEED 10
#define ANON_FTP_HOSTNAME
#ifndef NO_SOCKET_DEFS
#include <MacSockDefs.h>
#endif /* NO_SOCKET_DEFS */

#include <socket.ext.h>
#include <string.h>

#endif /* applec MPW */

/*
.
  VAX/VMS
.

Under VMS, there are many versions of TCP-IP. Define one if you do not use
Digital's UCX product:

  
    UCX
  
    DEC's "Ultrix connection" (default)
  
    WIN_TCP
  
    From Wollongong, now GEC software.
  
    MULTINET
  
    From SRI, now from TGV Inv.
  
    DECNET
  
    Cern's TCP socket emulation over DECnet


The last three do not interfere with the unix i/o library, and so they need
special calls to read, write and close sockets. In these cases the socket
number is a VMS channel number, so we make the @@@ HORRIBLE @@@ assumption
that a channel number will be greater than 10 but a unix file descriptor
less than 10. It works.
*/

#ifdef VMS
#include "HTVMSUtils.h"
#define CACHE_FILE_PREFIX	"SYS$LOGIN:Z_"
#define DEFAULT_SUFFIXES	"._"

#define HAVE_CUSERID

#ifdef WIN_TCP
#define NETREAD(s,b,l)	((s)>10 ? netread((s),(b),(l)) : read((s),(b),(l)))
#define NETWRITE(s,b,l)	((s)>10 ? netwrite((s),(b),(l)) : write((s),(b),(l)))
#define NETCLOSE(s) 	((s)>10 ? netclose(s) : close(s))
#endif /* WIN_TCP */

#ifdef MULTINET
#undef NETCLOSE
#undef NETREAD
#undef NETWRITE
#define NETREAD(s,b,l)	((s)>10 ? socket_read((s),(b),(l)) : read((s),(b),(l)))
#define NETWRITE(s,b,l)	((s)>10 ? socket_write((s),(b),(l)) : \
				write((s),(b),(l)))
#define NETCLOSE(s) 	((s)>10 ? socket_close(s) : close(s))
#define IOCTL(s,c,a)	socket_ioctl(s,c,a);
#endif /* MULTINET */

#ifdef DECNET
#define DNP_OBJ 80	/* This one doesn't look busy, but we must check */
			/* That one was for decnet */
#undef SELECT		/* not supported */
#define NETREAD(s,b,l)	((s)>10 ? recv((s),(b),(l),0) : read((s),(b),(l)))
#define NETWRITE(s,b,l)	((s)>10 ? send((s),(b),(l),0) : write((s),(b),(l)))
#define NETCLOSE(s) 	((s)>10 ? socket_close(s) : close(s))

#undef HAVE_GETHOSTNAME			/* Decnet doesn't have a name server */
#endif /* Decnet */

#undef HAVE_GETDOMAINNAME
         
/*	Certainly this works for UCX and Multinet; not tried for Wollongong
*/
#ifdef MULTINET
#include <time.h>
#ifdef __TIME_T
#define __TYPES
#define __TYPES_LOADED
#endif /* __TIME_T */
#include <multinet_root:[multinet.include.sys]types.h>
#include <multinet_root:[multinet.include]errno.h>
#ifdef __TYPES
#define __TIME_T
#endif /* __TYPE */
#ifdef __TIME_LOADED
#define __TIME
#endif /* __TIME_LOADED */
#include <multinet_root:[multinet.include.sys]time.h>
#else /* not MULTINET */
#include <types.h>
#include <errno.h>
#include <time.h>
#endif /* not MULTINET */

#include string

#ifndef STDIO_H
#include <stdio>
#define STDIO_H
#endif

#include file

#ifndef DECNET  /* Why is it used at all ? Types conflict with "types.h> */
#include unixio
#endif

#define INCLUDES_DONE

#ifdef MULTINET  /* Include from standard Multinet directories */
#include <multinet_root:[multinet.include.sys]socket.h>
#ifdef __TIME_LOADED  /* defined by sys$library:time.h */
#define __TIME  /* to avoid double definitions in next file */
#endif
#include <multinet_root:[multinet.include.netinet]in.h>
#include <multinet_root:[multinet.include.arpa]inet.h>
#include <multinet_root:[multinet.include]netdb.h>
#include <multinet_root:[multinet.include.sys]ioctl.h>

#else  /* not multinet */
#ifdef DECNET
#include <types.h>  /* for socket.h */
#include <socket.h>
#include <dn>
#include <dnetdb>

#else /* UCX or WIN */
#ifdef CADDR_T
#define __CADDR_T
#endif /* problem with xlib.h inclusion */
#include <socket.h>
#include <in.h>
#include <inet.h>
#include <netdb.h>
#include <ucx$inetdef.h>

#endif  /* not DECNET */
#endif  /* of Multinet or other TCP includes */

#define TCP_INCLUDES_DONE

#ifdef UCX
#define SIMPLE_TELNET
#endif

/*

On VMS directory browsing is available through a separate copy of dirent.c.
The definition of R_OK seem to be missing from the system include files...
*/

#define USE_DIRENT
#define GOT_READ_DIR
#include <dirent.h>
#define DIR struct dirent
#define R_OK 4

/*

On VMS machines, the linker needs to be told to put global data sections
into a data segment using these storage classes. (MarkDonszelmann)
*/

#ifdef VAXC
#define GLOBALDEF globaldef
#define GLOBALREF globalref
#endif /*  VAXC */
#endif	/* vms */

/*

On non-VMS machines, the GLOBALDEF and GLOBALREF storage types default to
normal C storage types.
*/

#ifndef GLOBALREF
#define GLOBALDEF
#define GLOBALREF extern
#endif

/*

On non-VMS machines STAT should be stat, unless that was overridden
somewhere above. On VMS machines STAT is a function that converts
directories and devices so that you can stat them.
*/

#ifdef VMS
typedef unsigned long mode_t;
#define HT_STAT		HTStat
#define HT_LSTAT	HTStat
#else
#ifndef HT_STAT
#define HT_STAT		stat
#endif
#ifndef HT_LSTAT
#define HT_LSTAT	lstat
#endif
#endif /* non VMS */

/*
(
  Dynamic Memory
)

Replace memory allocation and free C RTL functions with VAXC$xxx_OPT alternatives
for VAXC (but not DECC) on VMS. This makes a big performance difference.
(Foteos Macrides). Also have a look at the Dynamic
Memory Module for how to handle malloc and
calloc.
*/

#ifdef VMS
#include <stdio.h>
#include <stdlib.h>
#include <unixlib.h>
#include <ctype.h>
#if defined(VAXC) && !defined(__DECC)
#define malloc	VAXC$MALLOC_OPT
#define calloc	VAXC$CALLOC_OPT
#define free	VAXC$FREE_OPT
#define cfree	VAXC$CFREE_OPT
#define realloc	VAXC$REALLOC_OPT
#endif /* VAXC but not DECC */
#define unlink remove
#define gmtime localtime
#include <stat.h>
#define S_ISDIR(m)      (((m)&S_IFMT) == S_IFDIR)
#define S_ISREG(m)      (((m)&S_IFMT) == S_IFREG)
#define putenv HTVMS_putenv
#endif /* VMS */

/*
(
  Strftime and other time stuff
)
*/

#ifdef VMS
#ifndef DECC
#undef  HAVE_STRFTIME
#endif
#undef  HAVE_MKTIME
#undef  HAVE_TIMEGM
#define NO_GMTOFF
#undef  HAVE_TIMEZONE
#endif


/*
(
  Definition of Errno
)
*/

#ifdef VMS
#ifndef __DECC
extern int uerrno;	/* Deposit of error info (as per errno.h) */
extern volatile noshare int socket_errno; /* socket VMS error info 
                                          (used for translation of vmserrno) */
extern volatile noshare int vmserrno;	/* Deposit of VMS error info */
extern volatile noshare int errno;  /* noshare to avoid PSECT conflict */
#define ERRNO_DONE
#endif /* not DECC */
#endif /* VMS */

/*

  
!
  Platform Independent Stuff
!

Here we use all the knowledge we got above...
.
  Include Files
.

This file includes all system header files that are needed, iff they exist.
Their existance is discovered by configure.
*/

/* stdio.h */
#ifdef HAVE_STDIO_H
#include <stdio.h>
#endif

/* types.h */
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#else
#ifdef HAVE_TYPES_H
#include <types.h>
#endif
#endif

/* unistd.h */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#else
#ifdef HAVE_SYS_UNISTD_H
#include <sys/unistd.h>
#endif
#endif

/* fcntl.h */
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#else
#ifdef HAVE_SYS_FCNTL_H
#include <sys/fcntl.h>
#endif
#endif

/* sys/machine.h */
#ifdef HAVE_SYS_MACHINE_H
#include <sys/machine.h>
#endif

/* limits.h */
#ifdef HAVE_SYS_LIMITS_H
#include <sys/limits.h>
#else
#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif
#endif

/* stat.h */
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#else
#ifdef HAVE_STAT_H
#include <stat.h>
#endif
#endif

/* Patch for problems in glibc6 */
#if defined(__GLIBC__)
#undef S_IFMT
#undef S_IFDIR
#define S_IFMT __S_IFMT
#define S_IFDIR __S_IFDIR
#endif

/* in.h */
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#else
#ifdef HAVE_IN_H
#include <in.h>
#endif
#endif

/* tcp.h */
#ifdef HAVE_NETINET_TCP_H
#include <netinet/tcp.h>
#else
#ifdef HAVE_TCP_H
#include <tcp.h>
#endif
#endif

/* file.h */
#ifdef HAVE_SYS_FILE_H
#include <sys/file.h>
#endif

/* systeminfo.h */
#ifdef HAVE_SYS_SYSTEMINFO_H
#include <sys/systeminfo.h>
#endif

/* ioctl.h */
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

/* termios.h */
#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif

/* time.h */
#ifdef TIME_WITH_SYS_TIME
#include <sys/time.h>
#include <time.h>
#else
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#else
#ifdef HAVE_TIME_H
#include <time.h>
#endif
#endif
#endif

/* string{,s}.h */
#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

/* syslog.h */
#ifdef HAVE_SYSLOG_H
#include <syslog.h>
#else
#ifdef HAVE_SYS_SYSLOG_H
#include <sys/socket.h>
#endif
#endif

/* socket.h */
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#else
#ifdef HAVE_SOCKET_H
#include <socket.h>
#endif
#endif

/* socket.ext.h */
#ifdef HAVE_SOCKET_EXT_H
#include <socket.ext.h>
#endif

/* appkit.h */
#ifdef HAVE_APPKIT_APPKIT_H
#include <appkit/appkit.h>
#else
#ifdef HAVE_APPKIT_H
#include <appkit.h>
#endif
#endif

/* dn.h */
#ifdef HAVE_DN_H
#include <dn.h>
#endif

/* ipc.h */
#ifdef HAVE_SYS_IPC_H
#include <sys/ipc.h>
#endif

/* errno.h */
#ifdef HAVE_ERRNO_H
#include <errno.h>
#else
#ifdef HAVE_SYS_ERRNO_H
#include <sys/errno.h>
#else
#ifdef HAVE_NET_ERRNO_H
#include <net/errno.h>
#endif
#endif
#endif

/* pwd.h */
#ifdef HAVE_PWD_H
#include <pwd.h>
#endif

/* grp.h */
#ifdef HAVE_GRP_H
#include <grp.h>
#endif

/* inet.h */
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#else
#ifdef HAVE_INET_H
#include <inet.h>
#endif
#endif

/* netdb.h */
#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif

/* manifest.h */
#ifdef HAVE_MANIFEST_H
#include <manifest.h>
#endif

/* bsdtypes.h */
#ifdef HAVE_BSDTYPES_H
#include <bsdtypes.h>
#endif

/* stdefs.h */
#ifdef HAVE_STDEFS_H
#include <stdefs.h>
#endif

/* bsdtime.h */
#ifdef HAVE_BSDTIME_H
#include <bsdtime.h>
#endif

/* select.h */
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#else
#ifdef HAVE_SELECT_H
#include <select.h>
#endif
#endif

/* dnetdb.h */
#ifdef HAVE_DNETDB_H
#include <dnetdb.h>
#endif

/* ucx$inetdef.h */
#ifdef HAVE_UCX_INETDEF_H
#include <ucx$inetdef.h>
#endif

/* libc.h */
#ifdef HAVE_LIBC_H
#include <libc.h>
#endif

/* stdlib.h */
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

/* malloc.h */
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif

/* memory.h */
#ifdef HAVE_MEMORY_H
#include <memory.h>
#endif

/* unixlib.h */
#ifdef HAVE_UNIXLIB_H
#include <unixlib.h>
#endif

/* direct.h */
#ifdef HAVE_DIRECT_H
#include <direct.h>
#endif

/* ctype.h */
#ifdef HAVE_CTYPE_H
#include <ctype.h>
#endif

/* curses.h */
#ifdef CURSES
#ifdef HAVE_CURSESX_H
#include <cursesX.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
#endif

/* resource.h (some wait.h's require it) */
#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#else
#ifdef HAVE_RESOURCE_H
#include <resource.h>
#endif
#endif

/* dirent.h / ndir.h / dir.h */
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#define NAMLEN(dirent) strlen((dirent)->d_name)
#else
#define dirent direct
#define NAMLEN(dirent) (dirent)->d_namlen
#ifdef HAVE_SYS_NDIR_H
#include <sys/ndir.h>
#endif
#ifdef HAVE_SYS_DIR_H
#include <sys/dir.h>
#endif
#ifdef HAVE_DIR_H
#include <dir.h>
#endif
#ifdef HAVE_NDIR_H
#include <ndir.h>
#endif
#endif

#if !defined(HAVE_STRCHR)
#define strchr index
#define strrchr rindex
#endif
#if !defined(HAVE_MEMCPY)
#define memcpy(d, s, n) bcopy((s), (d), (n))
#define memmove(d, s, n) bcopy((s), (d), (n))
#endif

/* Definition of var args */
#if defined(STDC_HEADERS) || defined(__STDC__)
#include <stdarg.h>
#else
#ifndef WWW_MSWINDOWS
#include <varargs.h>
#endif
#endif

/* wait.h */
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(stat_val) (((unsigned)(stat_val) >> 8) & 255)
#endif
#ifndef WIFEXITED
#define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
#endif

#ifdef HT_POSIX_REGEX
#ifdef HAVE_RXPOSIX_H
#include <rxposix.h>
#else
#ifdef HAVE_REGEX_H
#include <regex.h>
#endif
#endif
#define W3C_DEFAULT_REGEX_FLAGS		(REG_EXTENDED | REG_NEWLINE)
#endif

/*
.
  Booleans
.
*/

#ifndef __MINGW32__ /* has a typedef for BOOLEAN */
#ifndef BOOLEAN
typedef char	BOOLEAN;				    /* Logical value */
#endif
#endif

#ifndef CURSES
#ifndef TRUE
#define TRUE	(BOOLEAN)1
#define	FALSE	(BOOLEAN)0
#endif
#endif	 /*  CURSES  */

#if !defined(BOOL) && !defined(WWW_MSWINDOWS)
#define BOOL BOOLEAN
#endif

#ifndef YES
#define YES             (BOOL)1
#define NO              (BOOL)0
#endif

/*
.
  Integers
.

If we don't have these (for some mysterious reason) then define them. This
should (is?) be handled by the configure script already.
*/

/* Richard Atterer  
   Disabled - caused problems because mingw32 has typedefs for these. 
   They seem useless now. */

/* 
#ifndef u_short
#define u_short unsigned short
#endif

#ifndef u_long
#define u_long unsigned long
#endif

*/

/*
.
  NULL Definition
.
*/

#ifndef NULL
#define NULL ((void *)0)
#endif

/*
.
  Sleep System Call
.

Some systems use milliseconds instead of seconds
*/

#ifndef SLEEP
#define SLEEP(n)	sleep(n)
#endif

/*
.
  SOCKS
.

SOCKS is a package for allowing socket connections to tunnel through firewalls
in carefully controlled situations. This package can be optionally compiled
with SOCKS support; these definitions replace the normal socket calls with
the SOCKS ones. Initial modification of the library is credited to Ian Dunkin
<imd1707@ggr.co.uk>.
*/

#ifdef SOCKS
#ifdef SOCKS4
#define connect	        Rconnect
#define getsockname	Rgetsockname
#define getpeername	Rgetpeername
#define bind		Rbind
#define accept		Raccept
#define listen		Rlisten
#define select		Rselect
#define recvfrom	Rrecvfrom
#define sendto		Rsendto
#define recv		Rrecv
#define send		Rsend
#define read		Rread
#define write		Rwrite
#define rresvport	Rrresvport
#define shutdown	Rshutdown
#define listen		Rlisten
#define close		Rclose
#define dup		Rdup
#define dup2		Rdup2
#define fclose		Rfclose
#define gethostbyname	Rgethostbyname
#else
#ifdef SOCKS5
#define connect		SOCKSconnect
#define getsockname	SOCKSgetsockname
#define getpeername	SOCKSgetpeername
#define bind		SOCKSbind
#define accept		SOCKSaccept
#define listen		SOCKSlisten
#define select		SOCKSselect
#define recvfrom	SOCKSrecvfrom
#define sendto		SOCKSsendto
#define recv		SOCKSrecv
#define send		SOCKSsend
#define read		SOCKSread
#define write		SOCKSwrite
#define rresvport	SOCKSrresvport
#define shutdown	SOCKSshutdown
#define listen		SOCKSlisten
#define close		SOCKSclose
#define dup		SOCKSdup
#define dup2		SOCKSdup2
#define fclose		SOCKSfclose
#define gethostbyname	SOCKSgethostbyname
#endif /* SOCKS5 */
#endif /* SOCKS4 */
#endif /* SOCKS */

/*
.
  Network Family
.
*/

#ifdef DECNET
typedef struct sockaddr_dn SockA;  /* See netdnet/dn.h or custom vms.h */
#else /* Internet */
typedef struct sockaddr_in SockA;  /* See netinet/in.h */
#endif

/*
.
  Default Values of Network Access
.
*/

#ifndef NETCLOSE
#define NETCLOSE close		/* Routine to close a TCP-IP socket */
#endif

#ifndef NETREAD
#define NETREAD  read		/* Routine to read from a TCP-IP socket	*/
#endif

#ifndef NETWRITE
#define NETWRITE write		/* Routine to write to a TCP-IP socket */
#endif

#ifndef NETWRITEV
#define NETWRITEV writev
#endif

/*
.
  Definition of errno and Return Code
.

This is the definition of error codes and the corresponding string constants.
If we do not have the strerror function then try the error list
table.
*/

#ifndef ERRNO_DONE
extern int errno;
#define socerrno errno
#endif

#ifndef HAVE_STRERROR				  /* Otherwise use the table */
extern char *sys_errlist[];
extern int sys_nerr;
#endif

/*
.
  Definition of Socket Desrciptores
.

This is necessary in order to support Windows NT...
*/

#ifndef SOCKET
#define SOCKET int		/* Unix like socket descriptor */
#define INVSOC (-1)		/* Unix invalid socket */
#endif

#ifdef __svr4__
#define HT_BACKLOG 32		 /* Number of pending connect requests (TCP) */
#else
#define HT_BACKLOG 5		 /* Number of pending connect requests (TCP) */
#endif /* __svr4__ */

/*
.
  Additional Network variables for SOCKET, file access bits
.
*/

#if 0
#ifndef _WINSOCKAPI_
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20
#endif /* _WINSOCKAPI_ */
#endif

/*
.
  Rough estimate of max path length
.
*/

#ifndef HT_MAX_PATH
#ifdef MAXPATHLEN
#define HT_MAX_PATH MAXPATHLEN
#else
#ifdef PATH_MAX
#define HT_MAX_PATH PATH_MAX
#else
#define HT_MAX_PATH 1024	 	      	/* Any better ideas? */
#endif
#endif
#endif /* HT_MAX_PATH */

#ifndef HT_MAX_TMPNAM
#ifdef L_tmpnam
#define HT_MAX_TMPNAM	L_tmpnam
#else
#define HT_MAX_TMPNAM	128
#endif
#endif

/*
.
  Hash Table Sizes
.

The size of the hash tables used by the various libwww classes like the
HTNet class, the HTHost
class etc. is a speed-size compromize. Here you can set the sizes depending
on whether you have a lot of memory or not. The values must be prime numbers,
of course.
*/

#ifdef LIBWWW_SMALL
#define HT_XL_HASH_SIZE		101
#define HT_L_HASH_SIZE		67
#define HT_M_HASH_SIZE		31
#define HT_S_HASH_SIZE		5
#else
#ifdef LIBWWW_LARGE
#define HT_XL_HASH_SIZE		1499
#define HT_L_HASH_SIZE		599
#define HT_M_HASH_SIZE		101
#define HT_S_HASH_SIZE		67
#else
#ifdef LIBWWW_EXTRA_LARGE
#define HT_XL_HASH_SIZE		9973
#define HT_L_HASH_SIZE		1499
#define HT_M_HASH_SIZE		599
#define HT_S_HASH_SIZE		101
#else
#define HT_XL_HASH_SIZE		599
#define HT_L_HASH_SIZE		101
#define HT_M_HASH_SIZE		67
#define HT_S_HASH_SIZE		11
#endif
#endif
#endif

/*
.
  Definition of NGROUPS
.
*/

#ifdef GETGROUPS_T
#ifndef NGROUPS
#ifdef NGROUPS_MAX
#define NGROUPS		NGROUPS_MAX
#else
#define NGROUPS		20			/* Any better ideas? */
#endif
#endif
#endif

/*
.
  Definition of Max Domain Name Length
.
*/

#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN 64			/* Any better ideas? */
#endif

/*
.
  File/Directory Management
.
*/

#ifndef MKDIR
#define MKDIR(a,b)	mkdir((a), (b))
#endif

#ifndef RMDIR
#define RMDIR(a)	rmdir((a))
#endif

#ifndef REMOVE
#define REMOVE(a)	unlink((a))
#endif

#ifndef DEFAULT_SUFFIXES
#define DEFAULT_SUFFIXES	".,_"
#endif

#ifndef DIR_SEPARATOR
#define DIR_SEPARATOR_CHAR	'/'
#define DIR_SEPARATOR_STR	"/"
#endif

#ifndef F_OK
#define R_OK    4
#define W_OK    2
#define X_OK    1
#define F_OK    0
#endif

/*
.
  Macros for manipulating masks for select()
.
*/

#ifndef FD_SET
#define FD_SET(fd, m) (*(unsigned*)(m) |=  (1 << (fd)))
#endif

#ifndef FD_CLR
#define FD_CLR(fd, m) (*(unsigned*)(m) &= ~(1 << (fd)))
#endif

#ifndef FD_ZERO
#define FD_ZERO(m)    (*(unsigned*)(m)) = 0
#endif

#ifndef FD_ISSET
#define FD_ISSET(fd, m) (*(unsigned*)(m) & (1 << (fd)))
#endif

/*
.
  Macros for converting characters
.
*/

#ifndef TOASCII
#define TOASCII(c) (c)
#define FROMASCII(c) (c)                                   
#endif

/*
.
  Cache file prefix
.

This is something onto which we tag something meaningful to make a cache
file name. used in HTWSRC.c at least. If it is not defined at all, caching
is turned off.
*/

#ifndef CACHE_FILE_PREFIX
#ifdef unix
#define CACHE_FILE_PREFIX  "/usr/wsrc/"
#endif
#endif

/*
.
  Thread Safe Setup
.

These are some constants setting the size of buffers used by thread safe
versions of some system calls.
*/

#ifdef HT_REENTRANT

#ifdef _POSIX_LOGIN_NAME_MAX
#define HT_LOGNAME_MAX  _POSIX_LOGIN_NAME_MAX
#else
#ifdef LOGNAME_MAX
#define HT_LOGNAME_MAX  (LOGNAME_MAX+1)
#else
#define HT_LOGNAME_MAX  64
#endif
#endif

#define HOSTENT_MAX	1024
#define CTIME_MAX	26
#endif /* HT_REENTRANT */

/*
.
  Types
.

We define some types here so we son't have to worry about it later
*/

typedef unsigned long ms_t;

/*
*/

#endif

/*

  

  @(#) $Id: wwwsys.html,v 1.1.1.2 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWTelnt.h
::::::::::::::
/*

					W3C Sample Code Library libwww TELNET, RLOGIN, AND TN3270 CLIENTS





!Declaration of W3C Sample Code Telnet, rlogin, and TN3270 MODULE!

*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the include file for the basic Telnet, rlogin, and TN3270
module that can be used together with the core of the W3C Sample Code
Library. It contains all Telnet, rlogin, and TN3270 specific modules
which are required to compile and build the Telnet, rlogin, and TN3270
DLL.

*/

#ifndef WWWTELNET_H
#define WWWTELNET_H

/*

*/

#ifdef __cplusplus
extern "C" { 
#endif

/*

.System dependencies.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this
file is that the Internet world is more complicated than Posix and
ANSI.

*/

#include "wwwsys.h"

/*

.Library Includes.

*/

#include "HTTelnet.h"			      /* TELNET client state machine */

/*

End of TELNET module

*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*



@(#) $Id: WWWTelnt.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $


*/
::::::::::::::
WWWTrans.h
::::::::::::::
/*

  					W3C Sample Code Library libwww Transports


!
  Declaration of W3C Sample Code Library Transports
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*
*/

#ifndef WWWTRANS_H
#define WWWTRANS_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  System dependencies
.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
.
  Transport Modules
.

These are the transports describing this interface
(
  Local File Transport
)
*/

#include "HTANSI.h"
#include "HTLocal.h"

/*
(
  BSD Socket Transport
)
*/

#include "HTTCP.h"
#include "HTSocket.h"
#include "HTReader.h"
#include "HTWriter.h"
#include "HTBufWrt.h"

/*
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWTrans.html,v 1.1.1.1 1998/08/14 21:54:39 cvs Exp $

*/
::::::::::::::
WWWUtil.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library libwww Basic Utilities


!
  Declaration of W3C Sample Code Library Basic Utilities
!
*/
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The Basic Utility modules are mostly container modules, dynamic strings and
other stuff that you can't live without when building applications. The modules
are used by the core part of the W3C Sample Code Library but can also be used
by the application. See also the main Library include file called
WWWLib.h which contains all converters and protocol
modules known to the Library. You can include this one if the application
is to use all the functionality of the Library.
*/

#ifndef WWWUTIL_H
#define WWWUTIL_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  System dependencies
.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
.
  Library Includes
.
(
  Basic Macros etc
)

This module includes file contains things we need everywhere, generally macros
for declarations, booleans, etc.
*/

#include "HTUtils.h"

/*
(
  Dynamic Arrays
)

This module implements a flexible array of pointers. It is a general utility
module. An array is a structure which may be extended. These routines create
and append data to arrays, automatically reallocating them as necessary.
It is garanteed that the last entry in an array is NULL
*/

#include "HTArray.h"

/*
(
  Association Lists
)

This is a small module build on top of the HTList
module that provides a way to store Name-Value pairs in an easy
way.
*/

#include "HTAssoc.h"

/*
(
  Atoms
)

Atoms are strings which are given representative pointer values so that they
can be stored more efficiently, and comparisons for equality done more
efficiently. The pointer values are in fact entries into a hash table.
*/

#include "HTAtom.h"

/*
(
  Dynamic Strings
)

A Chunk is a block wise expandable array of type (char *) and is a sort of
apology for real strings in C. Chunks make it easier to handle dynamic strings
of unknown size. It is often faster than using the String Copy Routines.
*/

#include "HTChunk.h"

/*
(
  Linked Lists
)

This module provides the functionality for managing a generic list of data
objects. The module is implemented as a single linked list using the scheme
first in - last out (FILO).
*/

#include "HTList.h"

/*
(
  Dymamic Memory Management
)

This module defines any memory handler to be used by libwww for allocating
and de-allocating dynamic memory. As dynamic memory may be a scarce resource,
it is required that an application can handle memory exhaustion gracefully.
*/

#include "HTMemory.h"

/*
(
  String Utilities
)

Routines for dynamic arrays of characters include string copy, case insensitive
comparison etc.
*/

#include "HTString.h"

/*
(
  UU encode and decode
)

File module provides functions functions for uuencode and decode strings
which convert a buffer of bytes to/from
RFC
1113 printable encoding format. This technique is similar to the familiar
Unix uuencode format in that it maps 6 binary bits to one ASCII character
(or more aptly, 3 binary bytes to 4 ASCII characters). However, RFC 1113
does not use the same mapping to printable characters as uuencode.
*/

#include "HTUU.h"

/*

End of utility modules
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWUtil.html,v 1.1.1.1 1998/08/14 21:54:40 cvs Exp $

*/
::::::::::::::
WWWWAIS.h
::::::::::::::
/*

  
  
  					W3C Sample Code Library libwww WAIS CLIENT


!
  Declaration of W3C Sample Code WAIS MODULE
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

This is the include file for the basic WAIS module that can be used together
with the core of the W3C Sample Code Library.
It contains all WAIS specific modules which are required to compile and build
the WAIS DLL.
*/

#ifndef WWWWAIS_H
#define WWWWAIS_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  System dependencies
.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
.
  Library Includes
.
*/

#include "HTWAIS.h"			        /* WAIS client state machine */

/*

End of WAIS module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWWAIS.html,v 1.1.1.1 1998/08/14 21:54:40 cvs Exp $

*/
::::::::::::::
WWWXML.h
::::::::::::::
/*

  					W3C Sample Code Library libwww XML/RDF Module


!
  Declaration of W3C Sample Code XML/RDF Module
!
*/

/*
**	(c) COPYRIGHT MIT 1999.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

Thanks so much to John Punin for writing this code!

We use James Clark's expat
XML parser which is very neat indeed. As the code doesn't come as a separate
library, I included it in the libwww CVS code base where I compile is as
one library: libexpat.a. See
the external modules that libwww works with for
details.
*/

#ifndef WWWXML_H
#define WWWXML_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
.
  System dependencies
.

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/

#include "wwwsys.h"

/*
(
  The Libwww Expat Wrapper Stream
)
*/

#ifdef HT_EXPAT
#include "HTXML.h"
#endif /* HT_EXPAT */

/*
(
  The RDF Parser Using The XML Parser
)

This RDF parser is based on Janne Saarela's Java based
SiRPAC and
James Clark's expat XML
parser
*/

#ifdef HT_EXPAT
#include "HTRDF.h"
#endif /* HT_EXPAT */

/*

End of XML module
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWXML.html,v 1.1.1.1 2005/07/06 09:34:02 gully Exp $

*/
::::::::::::::
WWWZip.h
::::::::::::::
/*

  
  					W3C Sample Code Library libwww ZLib Streams


!
  W3C Sample Code Library libwww ZLib Streams
!
*/

/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/

/*

The stream part of the Library is a set of streams that can be used to
encode/decode, or compress/decompress content. Many of the streams are based
on zlib which is a freely
available compression library.
*/

#ifndef WWWZIP_H
#define WWWZIP_H

/*
*/

#ifdef __cplusplus
extern "C" { 
#endif

/*
(
  System dependencies
)

The wwwsys.h file includes system-specific include
files and flags for I/O to network and disk. The only reason for this file
is that the Internet world is more complicated than Posix and ANSI.
*/
#include "wwwsys.h"

/*
(
  GZip Compression / Decompression
)

This stream can encode / decode gzipped content.
*/
#include "HTZip.h"

/*
*/

#ifdef __cplusplus
} /* end extern C definitions */
#endif

#endif

/*

  

  @(#) $Id: WWWZip.html,v 1.1.1.1 1998/08/14 21:54:40 cvs Exp $

*/
