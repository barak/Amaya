<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Creator     : groff version 1.18.1 --><!-- CreationDate: Mon Feb 23 20:35:44 2004 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Raptor RDF Parser Toolkit - Raptor API</title>
</head>
<body bgcolor="#ffffff" text="#000085">
<h1>Raptor RDF Parser Toolkit - Raptor API</h1>

<hr />
<a id="NAME" name="NAME"></a> 

<h2>NAME</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>libraptor &minus; Raptor RDF parser toolkit library</p>
</td>
</tr>
</table>

<a id="SYNOPSIS" name="SYNOPSIS"></a> 

<h2>SYNOPSIS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>
<b>#include &lt;raptor.h&gt;

raptor_init();
raptor_parser *</b><i>p</i><b>=raptor_new_parser("rdfxml");
raptor_set_statement_handler(</b><i>p</i><b>,</b><i>NULL</i><b>,</b><i>print_statements</i><b>);
raptor_uri *</b><i>file_uri</i><b>=raptor_new_uri("http://example.org/");
raptor_parse_file(</b><i>p</i><b>,</b><i>file_uri</i><b>,</b><i>base_uri</i><b>);
raptor_parse_uri(</b><i>p</i><b>,</b><i>uri</i><b>,</b><i>NULL</i><b>);
raptor_free_parser(</b><i>p</i><b>);
raptor_free_uri(</b><i>file_uri</i><b>);
raptor_finish();

cc file.c -lraptor
</b>
</pre>
</td>
</tr>
</table>

<a id="DESCRIPTION" name="DESCRIPTION"></a> 

<h2>DESCRIPTION</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <i>Raptor</i> library provides a high-level interface to a set of RDF format parsers, presently RDF/XML and N-Triples. The parsers turn the syntax into a sequence of RDF triples/statements. The RDF/XML parser uses either <i>expat</i> or <i>libxml</i> XML parser for providing the SAX event stream. The library functions are arranged in an object-oriented style with constructors, destructors and method calls. The statements and error messages are delivered via callback functions.</p>

<!-- INDENTATION -->
<p>Raptor contains a URI-reference parsing and resolving (not retrieval) class (raptor_uri) sufficient for dealing with URI-references inside RDF. This functionality is modular and can be transparently replaced with another existing and compatible URI implementation.</p>

<!-- INDENTATION -->
<p>It also provides a URI-retrieval class (raptor_www) for wrapping existing library such as libcurl, libxml2 or BSD libfetch that provides full or partial retrieval of data from URIs.</p>
</td>
</tr>
</table>

<a id="LIBRARY_INITIALISATION_AND_CLEANUP" name="LIBRARY_INITIALISATION_AND_CLEANUP"></a> 

<h2>LIBRARY INITIALISATION AND CLEANUP</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_init()</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_finish()</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Initialise and cleanup the library. These must be called before any raptor_parser or raptor_uri is created or used.</p>
</td>
</tr>
</table>

<a id="PARSER_CONSTRUCTORS" name="PARSER_CONSTRUCTORS"></a> 

<h2>PARSER CONSTRUCTORS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_parser* raptor_new_parser(name)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor parser object for the parser with name <i>name</i> currently either "rdfxml", "turtle" or "rss-tag-soup" for the RSS Tag Soup parser.</p>
</td>
</tr>
</table>

<a id="PARSER_DESTRUCTORS" name="PARSER_DESTRUCTORS"></a> 

<h2>PARSER DESTRUCTORS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_parser(raptor_parser *</b><i>parser</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a Raptor parser object.</p>
</td>
</tr>
</table>

<a id="PARSER_MESSAGE_CALLBACK_METHODS" name="PARSER_MESSAGE_CALLBACK_METHODS"></a> 

<h2>PARSER MESSAGE CALLBACK METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Several methods can be registered for the parser that return a variable-argument message in the style of printf(3). These also return a <i>raptor_locator</i> that can contain URI, file, line, column and byte counts of where the message is about. This structure can be used with the raptor_format_locator, raptor_print_locator functions below or the structures fields directly, which are defined in raptor.h</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_fatal_error_handler(raptor_parser*</b> <i>parser, void *user_data, raptor_message_handler handler)</i></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set fatal error handler callback.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_error_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set non-fatal error handler callback.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_warning_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set warning message handler callback.</p>
</td>
</tr>
</table>

<a id="PARSER_STATEMENT_CALLBACK_METHOD" name="PARSER_STATEMENT_CALLBACK_METHOD"></a> 

<h2>PARSER STATEMENT CALLBACK METHOD</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The parser allows the registration of a callback function to return the statements to the application.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_statement_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_statement_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the statement callback function for the parser. The <i>raptor_statement</i> structure is defined in raptor.h and includes fields for the subject, predicate, object of the statements along with their types and for literals, language and datatype.</p>
</td>
</tr>
</table>

<a id="PARSER_PARSING_METHODS" name="PARSER_PARSING_METHODS"></a> 

<h2>PARSER PARSING METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>These methods perform the entire parsing in one method. Statements warnings, errors and fatal errors are delivered via the registered statement, error etc. handler functions.</p>

<!-- INDENTATION -->
<p>In both of these methods, the base URI is required for the RDF/XML parser (name "rdfxml") and Turtle parser (name "turtle"). The N-Triples parser (name "ntriples") or RSS Tag Soup parser (name "rss-tag-soup") do not use this.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_file(raptor_parser*</b> <i>parser</i><b>, raptor_uri *</b><i>uri</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the given filename (a URI like file:filename) according to the optional base URI <i>base_uri</i>. If <i>uri</i> is NULL, read from standard input and <i>base_uri</i> is then required.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_file_stream(raptor_parser*</b> <i>parser</i><b>, FILE*</b> <i>stream</i><b>, const char*</b> <i>filename</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the given C FILE* stream according to the base URI <i>base_uri</i> (required). <i>filename</i> is optional and if given, is used for error messages via the raptor_locator structure.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_uri(raptor_parser*</b> <i>parser</i><b>, raptor_uri*</b> <i>uri</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the URI according to the base URI <i>base_uri</i>, or NULL if not needed. If no base URI is given, the <i>uri</i> is used. This method depends on the raptor_www subsystem (see <b>WWW Class</b> section below) and an existing underlying URI retrieval implementation such as libcurl, libxml or BSD libfetch to retrieve the content.</p>
</td>
</tr>
</table>

<a id="PARSER_CHUNKED_PARSING_METHODS" name="PARSER_CHUNKED_PARSING_METHODS"></a> 

<h2>PARSER CHUNKED PARSING METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>These methods perform the parsing in parts by working on multiple chunks of memory passed by the application. Statements warnings, errors and fatal errors are delivered via the registered statement, error etc. handler functions.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_start_parse(raptor_parser*</b> <i>parser</i><b>, const char *</b><i>uri</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start a parse of chunked content with the base URI <i>uri</i> or NULL if not needed. The base URI is required for the RDF/XML parser (name "rdfxml") and Turtle parser (name "turtle"). The N-Triples parser (name "ntriples") or RSS Tag Soup parser (name "rss-tag-soup") do not use this.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_chunk(raptor_parser*</b> <i>parser</i><b>, const unsigned char *buffer, size_t</b> <i>len</i><b>, int</b> <i>is_end</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the memory at <i>buffer</i> of size <i>len</i> returning statements via the statement handler callback. If <i>is_end</i> is non-zero, it indicates the end of the parsing stream. This method can only be called after raptor_start_parse.</p>
</td>
</tr>
</table>

<a id="PARSER_UTILITY_METHODS" name="PARSER_UTILITY_METHODS"></a> 

<h2>PARSER UTILITY METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_parser_strict(raptor_parser *</b><i>parser</i><b>, int</b> <i>is_strict</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the parser to strict (<i>is_strict</i> not zero) or lax (default) mode. The detail of the strictness can be controlled by raptor_set_feature.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_feature(raptor_parser *</b><i>parser</i><b>, raptor_feature</b> <i>feature</i><b>, int</b> <i>value</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set a parser feature <i>feature</i> to a particular <i>value</i>. The current defined features are: <i>Feature Values</i> <b>RAPTOR_FEATURE_SCANNING</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ASSUME_IS_RDF</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ALLOW_BAGID</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_NORMALIZE_LANGUAGE</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_NON_NFC_FATAL</b> Boolean (non 0 true) If the <i>scanning</i> feature is true (default false), then the RDF/XML parser will look for embedded rdf:RDF elements inside the XML content, and not require that the XML start with an rdf:RDF root element.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If the <i>assume_is_rdf</i> feature is true (default false), then the RDF/XML parser will assume the content is RDF/XML, not require that rdf:RDF root element, and immediately interpret the content as RDF/XML.</p>

<!-- INDENTATION -->
<p>If the <i>allow_non_ns_attributes</i> feature is true (default true), then the RDF/XML parser will allow non-XML namespaced attributes to be accepted as well as rdf: namespaced ones. For example, &rsquo;about&rsquo; and &rsquo;ID&rsquo; will be interpreted as if they were rdf:about and rdf:ID respectively.</p>

<!-- INDENTATION -->
<p>If the <i>allow_other_parsetypes</i> feature is true (default true) then the RDF/XML parser will allow unknown parsetypes to be present and will pass them on to the user. Unimplemented at present.</p>

<!-- INDENTATION -->
<p>If the <i>allow_bagid</i> feature is true (default true) then the RDF/XML parser will support the rdf:bagID attribute that was removed from the RDF/XML language when it was revised. This support may be removed in future.</p>

<!-- INDENTATION -->
<p>If the <i>allow_rdf_type_rdf_list</i> feature is true (default false) then the RDF/XML parser will generate the idList rdf:type rdf:List triple in the handling of rdf:parseType="Collection". This triple was removed during the revising of RDF/XML after collections were initially added.</p>

<!-- INDENTATION -->
<p>If the <i>normalize_language</i> feature is true (default true) then XML language values such as from xml:lang will be normalized to lowercase.</p>

<!-- INDENTATION -->
<p>If the <i>non_nfc_fatal</i> feature is true (default false) then illegal Unicode Normal Form C in literals will give a fatal error, otherwise it gives a warning.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_locator* raptor_get_locator(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the current raptor_locator object for the parser. This is a public structure defined in raptor.h that can be used directly, or formatted via raptor_print_locator.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_get_name(raptor_parser *</b><i>parser</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the string short name for the parser.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_get_label(raptor_parser *</b><i>parser</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a string label for the parser.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_default_generate_id_parameters(raptor_parser*</b> <i>rdf_parser</i><b>, char *</b><i>prefix</i><b>, int</b> <i>base</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Control the default method for generation of IDs for blank nodes and bags. The method uses a short string <i>prefix</i> and an integer <i>base</i> to generate the identifier which is not guaranteed to be a strict concatenation. If <i>prefix</i> is NULL, the default is used. If base is less than 1, it is initialised to 1.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_generate_id_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_generate_id_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Allow full customisation of the generated IDs by setting a callback <i>handler</i> and associated <i>user_data</i> that is called whenever a blank node or bag identifier is required.</p>
</td>
</tr>
</table>

<a id="PARSER_UTILITY_FUNCTIONS" name="PARSER_UTILITY_FUNCTIONS"></a> 

<h2>PARSER UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parsers_enumerate(const unsigned int</b> <i>counter</i><b>, const char **name, const char **</b><i>label</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the parser name/label for a parser with a given integer counter, returning non-zero if no such parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_syntaxes_enumerate(const unsigned int</b> <i>counter</i><b>, const char **name, const char **</b><i>label</i><b>, const char **</b><i>mime_type</i><b>, const unsigned char **</b><i>uri-string</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the name, label, mime type or URI string (all optional) for a parser syntax with a given integer counter, returning non-zero if no such syntax parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
</td>
</tr>
</table>

<a id="STATEMENT_UTILITY_FUNCTIONS" name="STATEMENT_UTILITY_FUNCTIONS"></a> 

<h2>STATEMENT UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_statement(const raptor_statement* const</b> <i>statement</i><b>, FILE *</b><i>stream</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Print a raptor statement object in a simple format for debugging only. The format of this output is not guaranteed to remain the same between releases.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_statement_as_ntriples(const raptor_statement*</b> <i>statement</i><b>, FILE *</b><i>stream</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Print a raptor statement object in N-Triples format, using all the escapes as defined in http://www.w3.org/TR/rdf-testcases/#ntriples</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_statement_part_as_counted_string(const void *</b><i>term</i><b>, raptor_identifier_type</b> <i>type</i><b>, raptor_uri*</b> <i>literal_datatype</i><b>, const unsigned char *</b><i>literal_language</i><b>, size_t*</b> <i>len_p</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char* raptor_statement_part_as_string(const void *</b><i>term</i><b>, raptor_identifier_type</b> <i>type</i><b>, raptor_uri*</b> <i>literal_datatype</i><b>, const unsigned char *</b><i>literal_language</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Turns part of raptor statement into N-Triples format, using all the escapes as defined in http://www.w3.org/TR/rdf-testcases/#ntriples The part (subject, predicate, object) of the raptor_statement is passed in as <i>term</i>, the part type (subject_type, predicate_type, object_type) is passed in as <i>type</i>. When the part is a literal, the <i>literal_datatype</i> and <i>literal_language</i> fields are set, otherwise NULL (usually object_datatype, object_literal_language).</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>If <b>raptor_statement_part_as_counted_string</b> is used, the length of the returned string is stored in *<i>len_p</i> if not NULL.</p>
</td>
</tr>
</table>

<a id="LOCATOR_UTILITY_FUNCTIONS" name="LOCATOR_UTILITY_FUNCTIONS"></a> 

<h2>LOCATOR UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_format_locator(char *</b><i>buffer</i><b>, size_t</b> <i>length</i><b>, raptor_locator*</b> <i>locator</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This method takes a <i>raptor_locator</i> object as passed to an error, warning or other handler callback and formats it into the <i>buffer</i> of size <i>length</i> bytes. If <i>buffer</i> is NULL or <i>length</i> is insufficient for the size of the formatted locator, returns the number of additional bytes required in the buffer to write the locator.</p>

<!-- INDENTATION -->
<p>In particular, if this form is used: length=raptor_format_locator(NULL, 0, locator) it will return in <i>length</i> the size of a buffer that can be allocated for <i>locator</i> and a second call will perform the formatting: raptor_format_locator(buffer, length, locator)</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_locator(FILE *</b><i>stream</i><b>, raptor_locator*</b> <i>locator</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This method takes a <i>raptor_locator</i> object as passed to an error, warning or other handler callback, formats and prints it to the given stdio <i>stream</i>.</p>
</td>
</tr>
</table>

<a id="N-TRIPLES_UTILITY_FUNCTIONS" name="N-TRIPLES_UTILITY_FUNCTIONS"></a> 

<h2>N-TRIPLES UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_ntriples_string(FILE*</b> <i>stream</i><b>, const char*</b> <i>string</i><b>, const char</b> <i>delim</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This is a standalone function that prints the given string according to N-Triples escaping rules, expecting to be delimited by the character <i>delim</i> which is usually either " or &lt;</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char* raptor_ntriples_term_as_string (raptor_ntriples_term_type term)</b></p>
</td>
</tr>
</table>

<a id="XML_UTILITY_FUNCTIONS" name="XML_UTILITY_FUNCTIONS"></a> 

<h2>XML UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>size_t raptor_xml_escape_string(const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>, unsigned char *</b><i>buffer</i><b>, size_t</b> <i>length</i><b>, char</b> <i>quote</i><b>, raptor_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Apply the XML escaping rules to the string given in (string, len) into the buffer of size length. If quote is given, the escaped content is for an XML attribute and the appropriate quote character XML element content (CDATA). The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given. If buffer is NULL, returns the size of the buffer required to escape. Otherwise the return value is the number of bytes used or 0 on failure.</p>
</td>
</tr>
</table>

<a id="STATIC_VARIABLES" name="STATIC_VARIABLES"></a> 

<h2>STATIC VARIABLES</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>There are several read-only static variables in the raptor library:</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_short_copyright_string</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Short copyright string, suitable for one line.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_copyright_string</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Full copyright over several lines including URLs.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_version_string</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The version as a string</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_major</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The major version number as an integer.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_minor</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The minor version number as an integer.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_release</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The release version number as an integer.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_decimal</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The version number as a single decimal.</p>
</td>
</tr>
</table>

<a id="URI_CLASS" name="URI_CLASS"></a> 

<h2>URI CLASS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Raptor has a raptor_uri class must be used for manipulating and passing URI references. The default internal implementation uses char* strings for URIs, manipulating them and constructing them. This URI implementation can be replaced by any other that provides the equivalent functionality, using the raptor_uri_set_handler function.</p>
</td>
</tr>
</table>

<a id="URI_CONSTRUCTORS" name="URI_CONSTRUCTORS"></a> 

<h2>URI CONSTRUCTORS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>There a several constructors for raptor_uri to build them from char* strings and existing raptor_uri objects.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string URI-reference <i>uri_string</i>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_from_uri_local_name(raptor_uri*</b> <i>uri</i><b>, const unsigned char*</b> <i>local_name</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string URI-reference <i>local_name</i> relative to an existing URI-reference. This performs concatenation of the <i>local_name</i> to the <i>uri</i> and not relative URI resolution, which is done by the raptor_new_uri_relative_to_base constructor.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_relative_to_base(raptor_uri*</b> <i>base_uri, const unsigned char* uri_string</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string URI-reference <i>uri_string</i> using relative URI resolution to the <i>base_uri</i>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_from_id(raptor_uri*</b> <i>base_uri</i><b>, const unsigned char*</b> <i>id</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string RDF ID <i>id</i> concatenated to the <i>base_uri</i> base URI.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_for_rdf_concept(const char*</b> <i>name</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI for the RDF namespace concept <i>name</i>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_for_xmlbase(raptor_uri*</b> <i>old_uri</i><b>))</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI suitable for use with xml:base (throw away fragment)</p>
</td>
</tr>
</table>

<a id="URI_DESTRUCTOR" name="URI_DESTRUCTOR"></a> 

<h2>URI DESTRUCTOR</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_uri(raptor_uri*</b> <i>uri</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor URI object.</p>
</td>
</tr>
</table>

<a id="URI_METHODS" name="URI_METHODS"></a> 

<h2>URI METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_uri_equals(raptor_uri*</b> <i>uri1</i><b>, raptor_uri*</b> <i>uri2</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-zero if the given URIs are equal.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_uri_copy(raptor_uri*</b> <i>uri</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a copy of the given raptor URI <i>uri</i>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_as_counted_string(raptor_uri *uri, size_t* len_p)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_as_string(raptor_uri*</b> <i>uri</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a shared pointer to a string representation of the given raptor URI <i>uri</i>. This string is shared and must not be freed. If raptor_uri_as_counted_string is used, the length of the returned string is stored in *len_p if not NULL.</p>
</td>
</tr>
</table>

<a id="URI_UTILITY_FUNCTIONS" name="URI_UTILITY_FUNCTIONS"></a> 

<h2>URI UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_uri_resolve_uri_reference (const unsigned char*</b> <i>base_uri</i><b>, const unsigned char*</b> <i>reference_uri</i><b>, char unsigned*</b> <i>buffer</i><b>, size_t</b> <i>length</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This is a standalone function that resolves the relative URI <i>reference_uri</i> against the base URI <i>base_uri</i> according to the URI resolution rules in RFC2396. The resulting URI is stored in <i>buffer</i> which is of <i>length</i> bytes. If this is too small, no work will be done.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char *raptor_uri_filename_to_uri_string(const unsigned char*</b> <i>filename</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This is a standalone function that turns a local filename (Windows or Unix style as appropriate for platform) into a URI string (file). The returned string must be freed by the caller.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char *raptor_uri_uri_string_to_filename(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This is a standalone function that turns a URI string that represents a local filename (file:) into a filename. The returned string must be freed by the caller.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_uri_is_file_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Returns non-zero if the given URI string represents a filename, is a file: URI.</p>
</td>
</tr>
</table>

<a id="URI_CLASS_IMPLEMENTATION" name="URI_CLASS_IMPLEMENTATION"></a> 

<h2>URI CLASS IMPLEMENTATION</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_uri_set_handler(raptor_uri_handler *</b><i>handler</i><b>, void *</b><i>context</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Change the URI class implementation to the functions provided by the <i>handler</i> URI implementation. The <i>context</i> user data is passed in to the handler URI implementation calls.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_uri_get_handler(raptor_uri_handler **</b><i>handler</i><b>, void **</b><i>context</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the current raptor URI class implementation <i>handler</i> and <i>context</i></p>
</td>
</tr>
</table>

<a id="WWW_CLASS" name="WWW_CLASS"></a> 

<h2>WWW CLASS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This is a small wrapper class around existing WWW libraries in order to provide HTTP GET or better URI retrieval for Raptor. It is not intended to be a general purpose WWW retrieval interface.</p>
</td>
</tr>
</table>

<a id="WWW_CLASS_INITIALISATION_AND_CLEANUP" name="WWW_CLASS_INITIALISATION_AND_CLEANUP"></a> 

<h2>WWW CLASS INITIALISATION AND CLEANUP</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_init(void)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_finish(void)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Initialise or terminate the raptor_www infrastructure. raptor_www_init and raptor_finish are called by raptor_init and raptor_finish respecitively, otherwise must be called once each.</p>
</td>
</tr>
</table>

<!-- TABS -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="5%">
<p>NOTE</p>
</td>
<td width="4%"></td>
<td width="77%">
<p>Several of the WWW library implementations require once-only initialisation and termination functions to be called, however raptor cannot determine whether this is already done before the library is initialised in <b>raptor_www_init</b> or terminated in <b>raptor_www_finish</b>, so always performs it. This can be changed by <b>raptor_www_no_www_library_init_finish</b>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_no_www_library_init_finish(void)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>If this is called before <b>raptor_www_init</b>, it will not call the underlying WWW library global initialise or terminate functions. The application code must perform both operations.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>For example with curl, after this function is called, neither <b>curl_global_init</b> nor <b>curl_global_cleanup</b> will be called during <b>raptor_www_init</b> or <b>raptor_www_finish</b> respectively.</p>
</td>
</tr>
</table>

<a id="WWW_CONSTRUCTORS" name="WWW_CONSTRUCTORS"></a> 

<h2>WWW CONSTRUCTORS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_www *raptor_www_new(void)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_www *raptor_www_new_with_connection(void*</b> <i>connection</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor WWW object capable of URI retrieval. If <i>connection</i> is given, it must match the connection object of the underlying WWW implementation. At present, this is only for libcurl, and allows you to re-use an existing curl handle, or use one which has been set up with some desired qualities.</p>
</td>
</tr>
</table>

<a id="WWW_DESTRUCTOR" name="WWW_DESTRUCTOR"></a> 

<h2>WWW DESTRUCTOR</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_free(raptor_www *</b><i>www</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor WWW object.</p>
</td>
</tr>
</table>

<a id="WWW_METHODS" name="WWW_METHODS"></a> 

<h2>WWW METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_user_agent(raptor_www *</b><i>www</i><b>, const char *</b><i>user_agent</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the user agent, for HTTP requests typically.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_proxy(raptor_www *</b><i>www</i><b>, const char *</b><i>proxy</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the HTTP proxy - usually a string of the form http://server:port</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_www_set_write_bytes_handler(raptor_www *</b><i>www</i><b>, raptor_www_write_bytes_handler</b> <i>handler</i><b>, void *</b><i>user_data</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the handler to receive bytes written by the raptor_www implementation.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_content_type_handler(raptor_www *</b><i>www</i><b>, raptor_www_content_type_handler</b> <i>handler</i><b>, void *</b><i>user_data</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the handler to receive the HTTP Content-Type value, when/if discovered during retrieval by the raptor_www implementation.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_error_handler(raptor_www *www, raptor_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the error handler routine for the raptor_www class. This takes the same arguments as the raptor_parser error, warning handler methods.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_www_get_connection(raptor_www *</b><i>www</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the underlying WWW library connection object. For example, for libcurl this is the curl_handle.</p>
</td>
</tr>
</table>

<a id="WWW_ACTION_METHODS" name="WWW_ACTION_METHODS"></a> 

<h2>WWW ACTION METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_www_fetch(raptor_www *www, raptor_uri *uri)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Retrieve the given URL, returning non zero on failure.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_abort(raptor_www *www, const char *reason)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Abort an ongoing raptor WWW operation. Typically used within one of the raptor WWW handlers.</p>
</td>
</tr>
</table>

<a id="QNAME_CLASS" name="QNAME_CLASS"></a> 

<h2>QNAME CLASS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This is a class for handling XML QNames consisting of the pair of (a URI from a namespace, a local name) along with an optional value -- useful for XML attributes. This is used with the raptor_namespace_stack and raptor_namespace classes to handle a stack of raptor_namespace that build on raptor_qname.</p>
</td>
</tr>
</table>

<a id="QNAME_CONSTRUCTORS" name="QNAME_CONSTRUCTORS"></a> 

<h2>QNAME CONSTRUCTORS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>There are two constructors for raptor_qname to build qnames with optional values on a stack of names.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname* raptor_new_qname(raptor_namespace_stack *</b><i>nstack</i><b>, const unsigned char *</b><i>name</i><b>, const unsigned char *</b><i>value</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor QName <i>name</i> (a possibly :-separated name) with name to be resolved against the given <i>nstack</i> namespace stack. An optional <i>value</i> can be given, and if there is an error, the <i>error_handler</i> <b>and</b> <i>error_data</i> will be used to invoke the callback.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname* raptor_new_qname_from_namespace_local_name (raptor_namespace *</b><i>ns</i><b>, const unsigned char *</b><i>local_name</i><b>, const unsigned char *</b><i>value</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor QName using the namespace name of the raptor_namespace <i>ns</i> and the local name <i>local_name</i>, along with optional value <i>value</i>. Errors are reported using the error handling and data of the namespace.</p>
</td>
</tr>
</table>

<a id="QNAME_DESTRUCTOR" name="QNAME_DESTRUCTOR"></a> 

<h2>QNAME DESTRUCTOR</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_qname(raptor_qname*</b> <i>name</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor qname object</p>
</td>
</tr>
</table>

<a id="QNAME_METHODS" name="QNAME_METHODS"></a> 

<h2>QNAME METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_qname_equal(raptor_qname *</b><i>name1</i>, raptor_qname *<i>name2</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-zero if the given QNames are equal.</p>
</td>
</tr>
</table>

<a id="QNAME_UTILITY_FUNCTIONS" name="QNAME_UTILITY_FUNCTIONS"></a> 

<h2>QNAME UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_qname_string_to_uri(raptor_namespace_stack *</b><i>nstack</i><b>, const unsigned char *</b><i>name</i><b>, size_t</b> <i>name_len</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the URI corresponding to the QName according to the RDF method; concatenating the namespace&rsquo;s name (URI) with the local name. Takes the same arguments as <b>raptor_new_qname</b> but does not create a raptor_qname object.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_CLASS" name="NAMESPACE_CLASS"></a> 

<h2>NAMESPACE CLASS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>An XML namespace class - each entry is on a stack and consists of a name (URI) and prefix. The prefix or the name but not both may be empty. If the prefix is empty, it defines the default prefix. If the name is empty, it undefines the given prefix.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_CONSTRUCTOR" name="NAMESPACE_CONSTRUCTOR"></a> 

<h2>NAMESPACE CONSTRUCTOR</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace* raptor_new_namespace(raptor_namespace_stack *nstack, const unsigned char *prefix, const unsigned char *ns_uri_string, int depth)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor_namespace object on the given namespace stack <i>nstack</i> with prefix <i>prefix</i> and namespace name (URI string) <i>ns_uri_string</i>. If <i>prefix</i> is NULL, it defines the URI for the default namespace prefix. If the <i>ns_uri_string</i> is NULL, it undefines the given <i>prefix</i> in the current scope. Both may not be NULL. <i>depth</i> signifies the position of the namespace on the stack; 0 is the bottom of the stack and generally the first depth for user namespace declarations. Namespaces declared on the same depth (such as on the same XML element, typically) can be handily freed with <i>raptor_namespaces_end_for_depth</i> method on the namespace stack class.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_DESTRUCTOR" name="NAMESPACE_DESTRUCTOR"></a> 

<h2>NAMESPACE DESTRUCTOR</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_namespace(raptor_namespace *ns)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor namespace object.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_METHODS" name="NAMESPACE_METHODS"></a> 

<h2>NAMESPACE METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_namespace_get_uri(const raptor_namespace *ns)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the namespace name (URI) of the namespace.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_namespace_get_prefix(const raptor_namespace *ns)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the prefix of the namespace.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char *raptor_namespaces_format(const raptor_namespace *ns, size_t *length_p)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Format the namespace as a string and return it as a new string, returning the length of the resulting string in <i>length_p</i> if it is not NULL. The string format is suitable for emitting in XML to declare the namespace.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_UTILITY_FUNCTIONS" name="NAMESPACE_UTILITY_FUNCTIONS"></a> 

<h2>NAMESPACE UTILITY FUNCTIONS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_namespace_copy(raptor_namespace_stack *nstack, raptor_namespace *ns, int new_depth)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Copy the namespace from the current stack to the new one, <i>nstack</i> at depth <i>new_depth</i>.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_STACK_CLASS" name="NAMESPACE_STACK_CLASS"></a> 

<h2>NAMESPACE STACK CLASS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A stack of raptor_namespace objects where the namespaces on top of the stack have wider scope and override earlier (lower) namespace declarations. Intended to match the XML namespace declaring semantics using xmlns attributes.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_STACK_CONSTRUCTORS" name="NAMESPACE_STACK_CONSTRUCTORS"></a> 

<h2>NAMESPACE STACK CONSTRUCTORS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace_stack* raptor_new_namespaces(raptor_uri_handler *uri_handler, void *uri_context, raptor_simple_message_handler error_handler, void *error_data, int defaults)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_namespaces_init(raptor_namespace_stack *nstack, raptor_uri_handler *handler, void *context, raptor_simple_message_handler error_handler, void *error_data, int defaults)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create or initialise a new raptor_namespace_stack object with the given URI and error handlers. <b>raptor_namespaces_new</b> allocates new memory for the namespace stack and <b>raptor_namespaces_init</b> initialises an existing declared <i>nstack</i>, which could be statically allocated. Note that <b>raptor_uri_get_handler</b> can be useful to return the current raptor URI handler/context. The <i>defaults</i> argument describes which default namespaces are declared in the empty stack. At present, 0 is none, 1 for just the XML namespace and 2 is for a typical set of namespaces used for RDF, RDFS, Dublin Core, OWL, ... that may vary over time.</p>
</td>
</tr>
</table>

<a id="NAMESPACE_STACK_DESTRUCTORS" name="NAMESPACE_STACK_DESTRUCTORS"></a> 

<h2>NAMESPACE STACK DESTRUCTORS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_namespaces(raptor_namespace_stack *nstack)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a namespace stack object, freeing the <i>nstack</i> (goes with <b>raptor_new_namespaces</b>).</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_namespaces_clear(raptor_namespace_stack *nstack)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Clear a statically allocated namespace stack; does not free the <i>nstack</i>. (goes with <b>raptor_namespaces_init</b>).</p>
</td>
</tr>
</table>

<a id="NAMESPACE_STACK_METHODS" name="NAMESPACE_STACK_METHODS"></a> 

<h2>NAMESPACE STACK METHODS</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_namespaces_start_namespace(raptor_namespace_stack *nstack, raptor_namespace *nspace)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start the given <i>nspace</i> on the stack, at the depth already defined.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_namespaces_start_namespace_full(raptor_namespace_stack *nstack, const unsigned char *prefix, const unsigned char *nspace, int depth)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor_namespace and start it on the stack. See <b>raptor_new_namespace</b> for the meaning of the argumens.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_namespaces_end_for_depth(raptor_namespace_stack *nstack, int depth)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>End (and free) all namespaces on the stack at the given <i>depth</i>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace* raptor_namespaces_get_default_namespace (raptor_namespace_stack *nstack)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the current default raptor_namespace of the namespace stack or NULL if there is none.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace *raptor_namespaces_find_namespace (raptor_namespace_stack *nstack, const unsigned char *prefix, int prefix_length)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Find the first namespace on the stack with the given namespace <i>prefix</i> or NULL if there is none.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_namespaces_namespace_in_scope(raptor_namespace_stack *nstack, const raptor_namespace *nspace)</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-zero if the raptor_namespace <i>nspace</i> is declared on the stack; i.e. in scope if this is a stack of XML namespaces.</p>
</td>
</tr>
</table>

<a id="API_CHANGES" name="API_CHANGES"></a> 

<h2>API CHANGES</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.2.0</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_syntaxes_enumerate</b> to get full information on syntax mime type and URIs as well as name and label.<br />
N-Triples Plus parser renamed to Turtle (name turtle)</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.1.0</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added N-Triples Plus parser (name ntriples-plus)<br />
Made URI class constructors, methods and factory methods as well as some other utility functions using or returning URIs or literals take unsigned char* rather than char*. The affected calls are:<b><br />
raptor_new_uri_func raptor_new_uri_from_local_name_func raptor_new_uri_relative_to_base_func raptor_uri_as_string_func raptor_uri_as_counted_string_func</b> URI factory methods changed to all take/return unsigned char* for URI strings. <b>raptor_statement_part_as_counted_string raptor_statement_part_as_string raptor_new_uri raptor_new_uri_from_uri_local_name raptor_new_uri_relative_to_base raptor_uri_as_string raptor_uri_as_counted_string raptor_print_ntriples_string</b> Constructors and methods changed to take/return unsigned char* for URI strings. <b>raptor_uri_resolve_uri_reference raptor_uri_filename_to_uri_string raptor_uri_uri_string_to_filename raptor_uri_uri_string_to_filename_fragment raptor_uri_is_file_uri</b> Changed to use unsigned char* for URI strings, char* for filenames. <b>raptor_ntriples_string_as_utf8_string</b> Changed to return unsigned char* for UTF8 string.<br />
Added <b>raptor_parsers_enumerate</b> to discover supported parsers.<br />
Added <b>raptor_uri_uri_string_to_filename_fragment</b> with fragment arg to return the URI fragment.<br />
Made the raptor_namespace, raptor_namespace_stack and raptor_qname class and APIs public.<br />
Added feature non_nfc_fatal (see raptor_set_feature documentation).</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.0.0</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Removed the following deprecated methods and functions (see 0.9.6 changes for the new names):<b><br />
raptor_free</b>, <b>raptor_new</b>, <b>raptor_ntriples_free</b>, <b>raptor_ntriples_new</b>, <b>raptor_ntriples_parse_file</b>, <b>raptor_ntriples_set_error_handler</b>, <b>raptor_ntriples_set_fatal_error_handler</b>, <b>raptor_ntriples_set_statement_handler</b> and <b>raptor_parser_abort</b>.<br />
Added <b>raptor_parse_file_stream</b> for reading FILE* streams without necessarily having a file.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.12</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_new_uri_for_retrieval</b> to turn URI references into URIs suitable for retrieval (no fragments).</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.11</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_get_name</b> and <b>raptor_get_label</b>.<b><br />
raptor_xml_escape_string</b> now takes error message handler, data pointer, loses parser argument.<br />
Added <b>raptor_set_default_generate_id_parameters</b> and <b>raptor_set_generate_id_handler</b> to control the default generation of IDs, allow full customisation.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.10</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_set_parser_strict</b> and <b>raptor_www_no_www_library_init_finish</b>.<b><br />
raptor_xml_escape_string</b> now takes an output string length pointer.<br />
Added <b>raptor_statement_part_as_counted_string</b>, <b>raptor_statement_part_as_string and raptor_parse_abort</b>.<br />
Deprecated <b>raptor_parser_abort</b>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.9</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added raptor_www class and all its constructors, destructor, methods, calls.<br />
Added <b>raptor_parse_uri</b>, <b>raptor_parser_abort</b>, <b>raptor_ntriples_term_as_string</b> and <b>raptor_xml_escape_string</b>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.7</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_parse_chunk, raptor_new_uri_from_id</b>, arguments are now unsigned char.<br />
Added <b>raptor_new_uri_for_xmlbase</b>.</p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.6</b></p>
</td>
</tr>
</table>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>In this version, the raptor/ntriples parser calling APIs were modified. The following table lists the changes:</p>

<!-- INDENTATION -->
<p><i>OLD API NEW API (0.9.6+)</i><b><br />
raptor_new() raptor_new_parser("rdfxml")<br />
ntriples_new() raptor_new_parser("ntriples")<br />
raptor_free raptor_free_parser<br />
ntriples_free raptor_ntriples_parser<br />
raptor_ntriples_parse_file raptor_parse_file<br />
raptor_ntriples_set_error_handler raptor_set_error_handler<br />
raptor_ntriples_set_fatal_error_handler raptor_set_fatal_error_handler<br />
raptor_ntriples_set_statement_handler raptor_set_statement_handler</b></p>
</td>
</tr>
</table>

<a id="CONFORMING_TO" name="CONFORMING_TO"></a> 

<h2>CONFORMING TO</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><i>RDF/XML Syntax (Revised)</i>, Dave Beckett (ed.) W3C Proposed Recommendation, http://www.w3.org/TR/rdf-syntax-grammar/</p>

<!-- INDENTATION -->
<p><i>N-Triples</i>, in <i>RDF Test Cases</i>, Jan Grant and Dave Beckett (eds.) W3C Proposed Recommendation, http://www.w3.org/TR/rdf-testcases/#ntriples</p>

<!-- INDENTATION -->
<p><i>Turtle - Terse RDF Triple Language</i>, Dave Beckett, http://www.ilrt.bristol.ac.uk/discovery/2004/01/turtle/</p>
</td>
</tr>
</table>

<a id="SEE_ALSO" name="SEE_ALSO"></a> 

<h2>SEE ALSO</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>rapper</b>(1),<b>raptor-config</b>(1)</p>
</td>
</tr>
</table>

<a id="AUTHOR" name="AUTHOR"></a> 

<h2>AUTHOR</h2>

<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><a href="http://purl.org/net/dajobe/">Dave Beckett</a><br />
<a href="http://www.ilrt.bristol.ac.uk/">Institute for Learning and Research Technology (ILRT)</a><br />
<a href="http://www.bristol.ac.uk/">University of Bristol</a></p>
</td>
</tr>
</table>

<hr />

<p>Copyright 2002-2004 <a href="http://purl.org/net/dajobe/">Dave Beckett</a>, <a href="http://www.ilrt.bristol.ac.uk/">Institute for Learning and Research Technology</a>, <a href="http://www.bristol.ac.uk/">University of Bristol</a></p>

</body>
</html>

